// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// Section: imports

use super::*;
use crate::api::electrum::*;
use crate::api::esplora::*;
use crate::api::store::*;
use crate::api::types::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate_io!();

// Section: dart2rust

impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
    for *mut wire_cst_list_prim_u_8_strict
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
        unimplemented!()
    }
}
impl CstDecode<flutter_rust_bridge::DartOpaque> for *const std::ffi::c_void {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> flutter_rust_bridge::DartOpaque {
        unsafe { flutter_rust_bridge::for_generated::cst_decode_dart_opaque(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_core::bitcoin::Address>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_core::bitcoin::Address> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>>>
    for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::Update>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::Update> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::keys::KeyMap>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::KeyMap> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
        >,
    > {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<
        std::sync::Mutex<Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>>,
    > {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
        >,
    > {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
        >,
    > {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<
        std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
    > {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>> {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> String {
        let vec: Vec<u8> = self.cst_decode();
        String::from_utf8(vec).unwrap()
    }
}
impl CstDecode<crate::api::error::AddressParseError> for wire_cst_address_parse_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::AddressParseError {
        match self.tag {
            0 => crate::api::error::AddressParseError::Base58,
            1 => crate::api::error::AddressParseError::Bech32,
            2 => {
                let ans = unsafe { self.kind.WitnessVersion };
                crate::api::error::AddressParseError::WitnessVersion {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            3 => {
                let ans = unsafe { self.kind.WitnessProgram };
                crate::api::error::AddressParseError::WitnessProgram {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            4 => crate::api::error::AddressParseError::UnknownHrp,
            5 => crate::api::error::AddressParseError::LegacyAddressTooLong,
            6 => crate::api::error::AddressParseError::InvalidBase58PayloadLength,
            7 => crate::api::error::AddressParseError::InvalidLegacyPrefix,
            8 => crate::api::error::AddressParseError::NetworkValidation,
            9 => crate::api::error::AddressParseError::OtherAddressParseErr,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::Bip32Error> for wire_cst_bip_32_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::Bip32Error {
        match self.tag {
            0 => crate::api::error::Bip32Error::CannotDeriveFromHardenedKey,
            1 => {
                let ans = unsafe { self.kind.Secp256k1 };
                crate::api::error::Bip32Error::Secp256k1 {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.InvalidChildNumber };
                crate::api::error::Bip32Error::InvalidChildNumber {
                    child_number: ans.child_number.cst_decode(),
                }
            }
            3 => crate::api::error::Bip32Error::InvalidChildNumberFormat,
            4 => crate::api::error::Bip32Error::InvalidDerivationPathFormat,
            5 => {
                let ans = unsafe { self.kind.UnknownVersion };
                crate::api::error::Bip32Error::UnknownVersion {
                    version: ans.version.cst_decode(),
                }
            }
            6 => {
                let ans = unsafe { self.kind.WrongExtendedKeyLength };
                crate::api::error::Bip32Error::WrongExtendedKeyLength {
                    length: ans.length.cst_decode(),
                }
            }
            7 => {
                let ans = unsafe { self.kind.Base58 };
                crate::api::error::Bip32Error::Base58 {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            8 => {
                let ans = unsafe { self.kind.Hex };
                crate::api::error::Bip32Error::Hex {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            9 => {
                let ans = unsafe { self.kind.InvalidPublicKeyHexLength };
                crate::api::error::Bip32Error::InvalidPublicKeyHexLength {
                    length: ans.length.cst_decode(),
                }
            }
            10 => {
                let ans = unsafe { self.kind.UnknownError };
                crate::api::error::Bip32Error::UnknownError {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::Bip39Error> for wire_cst_bip_39_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::Bip39Error {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.BadWordCount };
                crate::api::error::Bip39Error::BadWordCount {
                    word_count: ans.word_count.cst_decode(),
                }
            }
            1 => {
                let ans = unsafe { self.kind.UnknownWord };
                crate::api::error::Bip39Error::UnknownWord {
                    index: ans.index.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.BadEntropyBitCount };
                crate::api::error::Bip39Error::BadEntropyBitCount {
                    bit_count: ans.bit_count.cst_decode(),
                }
            }
            3 => crate::api::error::Bip39Error::InvalidChecksum,
            4 => {
                let ans = unsafe { self.kind.AmbiguousLanguages };
                crate::api::error::Bip39Error::AmbiguousLanguages {
                    languages: ans.languages.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::electrum::ElectrumClient> for *mut wire_cst_electrum_client {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::electrum::ElectrumClient {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::electrum::ElectrumClient>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::esplora::EsploraClient> for *mut wire_cst_esplora_client {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::esplora::EsploraClient {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::esplora::EsploraClient>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::bitcoin::FfiAddress> for *mut wire_cst_ffi_address {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiAddress {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::bitcoin::FfiAddress>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::store::FfiConnection> for *mut wire_cst_ffi_connection {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::store::FfiConnection {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::store::FfiConnection>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::key::FfiDerivationPath> for *mut wire_cst_ffi_derivation_path {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDerivationPath {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::key::FfiDerivationPath>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::descriptor::FfiDescriptor> for *mut wire_cst_ffi_descriptor {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::descriptor::FfiDescriptor {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::descriptor::FfiDescriptor>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::key::FfiDescriptorPublicKey>
    for *mut wire_cst_ffi_descriptor_public_key
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDescriptorPublicKey {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::key::FfiDescriptorPublicKey>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::key::FfiDescriptorSecretKey>
    for *mut wire_cst_ffi_descriptor_secret_key
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDescriptorSecretKey {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::key::FfiDescriptorSecretKey>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::FfiFullScanRequest> for *mut wire_cst_ffi_full_scan_request {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiFullScanRequest {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::FfiFullScanRequest>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>
    for *mut wire_cst_ffi_full_scan_request_builder
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiFullScanRequestBuilder {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::FfiFullScanRequestBuilder>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::key::FfiMnemonic> for *mut wire_cst_ffi_mnemonic {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiMnemonic {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::key::FfiMnemonic>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::bitcoin::FfiPsbt> for *mut wire_cst_ffi_psbt {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiPsbt {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::bitcoin::FfiPsbt>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::bitcoin::FfiScriptBuf> for *mut wire_cst_ffi_script_buf {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiScriptBuf {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::bitcoin::FfiScriptBuf>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::FfiSyncRequest> for *mut wire_cst_ffi_sync_request {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiSyncRequest {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::FfiSyncRequest>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::FfiSyncRequestBuilder>
    for *mut wire_cst_ffi_sync_request_builder
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiSyncRequestBuilder {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::FfiSyncRequestBuilder>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::bitcoin::FfiTransaction> for *mut wire_cst_ffi_transaction {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiTransaction {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::bitcoin::FfiTransaction>::cst_decode(*wrap).into()
    }
}
impl CstDecode<u64> for *mut u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
    }
}
impl CstDecode<crate::api::error::CreateWithPersistError> for wire_cst_create_with_persist_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::CreateWithPersistError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Persist };
                crate::api::error::CreateWithPersistError::Persist {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            1 => crate::api::error::CreateWithPersistError::DataAlreadyExists,
            2 => {
                let ans = unsafe { self.kind.Descriptor };
                crate::api::error::CreateWithPersistError::Descriptor {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::DescriptorError> for wire_cst_descriptor_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::DescriptorError {
        match self.tag {
            0 => crate::api::error::DescriptorError::InvalidHdKeyPath,
            1 => crate::api::error::DescriptorError::MissingPrivateData,
            2 => crate::api::error::DescriptorError::InvalidDescriptorChecksum,
            3 => crate::api::error::DescriptorError::HardenedDerivationXpub,
            4 => crate::api::error::DescriptorError::MultiPath,
            5 => {
                let ans = unsafe { self.kind.Key };
                crate::api::error::DescriptorError::Key {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            6 => {
                let ans = unsafe { self.kind.Generic };
                crate::api::error::DescriptorError::Generic {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            7 => {
                let ans = unsafe { self.kind.Policy };
                crate::api::error::DescriptorError::Policy {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            8 => {
                let ans = unsafe { self.kind.InvalidDescriptorCharacter };
                crate::api::error::DescriptorError::InvalidDescriptorCharacter {
                    char: ans.char.cst_decode(),
                }
            }
            9 => {
                let ans = unsafe { self.kind.Bip32 };
                crate::api::error::DescriptorError::Bip32 {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            10 => {
                let ans = unsafe { self.kind.Base58 };
                crate::api::error::DescriptorError::Base58 {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            11 => {
                let ans = unsafe { self.kind.Pk };
                crate::api::error::DescriptorError::Pk {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            12 => {
                let ans = unsafe { self.kind.Miniscript };
                crate::api::error::DescriptorError::Miniscript {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            13 => {
                let ans = unsafe { self.kind.Hex };
                crate::api::error::DescriptorError::Hex {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            14 => crate::api::error::DescriptorError::ExternalAndInternalAreTheSame,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::DescriptorKeyError> for wire_cst_descriptor_key_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::DescriptorKeyError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Parse };
                crate::api::error::DescriptorKeyError::Parse {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            1 => crate::api::error::DescriptorKeyError::InvalidKeyType,
            2 => {
                let ans = unsafe { self.kind.Bip32 };
                crate::api::error::DescriptorKeyError::Bip32 {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::electrum::ElectrumClient> for wire_cst_electrum_client {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::electrum::ElectrumClient {
        crate::api::electrum::ElectrumClient(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::error::ElectrumError> for wire_cst_electrum_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::ElectrumError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.IOError };
                crate::api::error::ElectrumError::IOError {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            1 => {
                let ans = unsafe { self.kind.Json };
                crate::api::error::ElectrumError::Json {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.Hex };
                crate::api::error::ElectrumError::Hex {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            3 => {
                let ans = unsafe { self.kind.Protocol };
                crate::api::error::ElectrumError::Protocol {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            4 => {
                let ans = unsafe { self.kind.Bitcoin };
                crate::api::error::ElectrumError::Bitcoin {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            5 => crate::api::error::ElectrumError::AlreadySubscribed,
            6 => crate::api::error::ElectrumError::NotSubscribed,
            7 => {
                let ans = unsafe { self.kind.InvalidResponse };
                crate::api::error::ElectrumError::InvalidResponse {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            8 => {
                let ans = unsafe { self.kind.Message };
                crate::api::error::ElectrumError::Message {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            9 => {
                let ans = unsafe { self.kind.InvalidDNSNameError };
                crate::api::error::ElectrumError::InvalidDNSNameError {
                    domain: ans.domain.cst_decode(),
                }
            }
            10 => crate::api::error::ElectrumError::MissingDomain,
            11 => crate::api::error::ElectrumError::AllAttemptsErrored,
            12 => {
                let ans = unsafe { self.kind.SharedIOError };
                crate::api::error::ElectrumError::SharedIOError {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            13 => crate::api::error::ElectrumError::CouldntLockReader,
            14 => crate::api::error::ElectrumError::Mpsc,
            15 => {
                let ans = unsafe { self.kind.CouldNotCreateConnection };
                crate::api::error::ElectrumError::CouldNotCreateConnection {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            16 => crate::api::error::ElectrumError::RequestAlreadyConsumed,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::esplora::EsploraClient> for wire_cst_esplora_client {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::esplora::EsploraClient {
        crate::api::esplora::EsploraClient(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::error::EsploraError> for wire_cst_esplora_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::EsploraError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Minreq };
                crate::api::error::EsploraError::Minreq {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            1 => {
                let ans = unsafe { self.kind.HttpResponse };
                crate::api::error::EsploraError::HttpResponse {
                    status: ans.status.cst_decode(),
                    error_message: ans.error_message.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.Parsing };
                crate::api::error::EsploraError::Parsing {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            3 => {
                let ans = unsafe { self.kind.StatusCode };
                crate::api::error::EsploraError::StatusCode {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            4 => {
                let ans = unsafe { self.kind.BitcoinEncoding };
                crate::api::error::EsploraError::BitcoinEncoding {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            5 => {
                let ans = unsafe { self.kind.HexToArray };
                crate::api::error::EsploraError::HexToArray {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            6 => {
                let ans = unsafe { self.kind.HexToBytes };
                crate::api::error::EsploraError::HexToBytes {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            7 => crate::api::error::EsploraError::TransactionNotFound,
            8 => {
                let ans = unsafe { self.kind.HeaderHeightNotFound };
                crate::api::error::EsploraError::HeaderHeightNotFound {
                    height: ans.height.cst_decode(),
                }
            }
            9 => crate::api::error::EsploraError::HeaderHashNotFound,
            10 => {
                let ans = unsafe { self.kind.InvalidHttpHeaderName };
                crate::api::error::EsploraError::InvalidHttpHeaderName {
                    name: ans.name.cst_decode(),
                }
            }
            11 => {
                let ans = unsafe { self.kind.InvalidHttpHeaderValue };
                crate::api::error::EsploraError::InvalidHttpHeaderValue {
                    value: ans.value.cst_decode(),
                }
            }
            12 => crate::api::error::EsploraError::RequestAlreadyConsumed,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::ExtractTxError> for wire_cst_extract_tx_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::ExtractTxError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.AbsurdFeeRate };
                crate::api::error::ExtractTxError::AbsurdFeeRate {
                    fee_rate: ans.fee_rate.cst_decode(),
                }
            }
            1 => crate::api::error::ExtractTxError::MissingInputValue,
            2 => crate::api::error::ExtractTxError::SendingTooMuch,
            3 => crate::api::error::ExtractTxError::OtherExtractTxErr,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::FfiAddress> for wire_cst_ffi_address {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiAddress {
        crate::api::bitcoin::FfiAddress(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::store::FfiConnection> for wire_cst_ffi_connection {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::store::FfiConnection {
        crate::api::store::FfiConnection(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::key::FfiDerivationPath> for wire_cst_ffi_derivation_path {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDerivationPath {
        crate::api::key::FfiDerivationPath {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::descriptor::FfiDescriptor> for wire_cst_ffi_descriptor {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::descriptor::FfiDescriptor {
        crate::api::descriptor::FfiDescriptor {
            extended_descriptor: self.extended_descriptor.cst_decode(),
            key_map: self.key_map.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::key::FfiDescriptorPublicKey> for wire_cst_ffi_descriptor_public_key {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDescriptorPublicKey {
        crate::api::key::FfiDescriptorPublicKey {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::key::FfiDescriptorSecretKey> for wire_cst_ffi_descriptor_secret_key {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiDescriptorSecretKey {
        crate::api::key::FfiDescriptorSecretKey {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::FfiFullScanRequest> for wire_cst_ffi_full_scan_request {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiFullScanRequest {
        crate::api::types::FfiFullScanRequest(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>
    for wire_cst_ffi_full_scan_request_builder
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiFullScanRequestBuilder {
        crate::api::types::FfiFullScanRequestBuilder(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::key::FfiMnemonic> for wire_cst_ffi_mnemonic {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::FfiMnemonic {
        crate::api::key::FfiMnemonic {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::FfiPsbt> for wire_cst_ffi_psbt {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiPsbt {
        crate::api::bitcoin::FfiPsbt {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::FfiScriptBuf> for wire_cst_ffi_script_buf {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiScriptBuf {
        crate::api::bitcoin::FfiScriptBuf {
            bytes: self.bytes.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::FfiSyncRequest> for wire_cst_ffi_sync_request {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiSyncRequest {
        crate::api::types::FfiSyncRequest(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::types::FfiSyncRequestBuilder> for wire_cst_ffi_sync_request_builder {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FfiSyncRequestBuilder {
        crate::api::types::FfiSyncRequestBuilder(self.field0.cst_decode())
    }
}
impl CstDecode<crate::api::bitcoin::FfiTransaction> for wire_cst_ffi_transaction {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::FfiTransaction {
        crate::api::bitcoin::FfiTransaction {
            s: self.s.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::wallet::FfiWallet> for wire_cst_ffi_wallet {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::wallet::FfiWallet {
        crate::api::wallet::FfiWallet {
            ptr: self.ptr.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::error::FromScriptError> for wire_cst_from_script_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::FromScriptError {
        match self.tag {
            0 => crate::api::error::FromScriptError::UnrecognizedScript,
            1 => {
                let ans = unsafe { self.kind.WitnessProgram };
                crate::api::error::FromScriptError::WitnessProgram {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.WitnessVersion };
                crate::api::error::FromScriptError::WitnessVersion {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            3 => crate::api::error::FromScriptError::OtherFromScriptErr,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<Vec<u8>> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}
impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}
impl CstDecode<Vec<crate::api::bitcoin::TxIn>> for *mut wire_cst_list_tx_in {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::bitcoin::TxIn> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<Vec<crate::api::bitcoin::TxOut>> for *mut wire_cst_list_tx_out {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::bitcoin::TxOut> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<crate::api::types::LockTime> for wire_cst_lock_time {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LockTime {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Blocks };
                crate::api::types::LockTime::Blocks(ans.field0.cst_decode())
            }
            1 => {
                let ans = unsafe { self.kind.Seconds };
                crate::api::types::LockTime::Seconds(ans.field0.cst_decode())
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::OutPoint> for wire_cst_out_point {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::OutPoint {
        crate::api::bitcoin::OutPoint {
            txid: self.txid.cst_decode(),
            vout: self.vout.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::error::PsbtError> for wire_cst_psbt_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::PsbtError {
        match self.tag {
            0 => crate::api::error::PsbtError::InvalidMagic,
            1 => crate::api::error::PsbtError::MissingUtxo,
            2 => crate::api::error::PsbtError::InvalidSeparator,
            3 => crate::api::error::PsbtError::PsbtUtxoOutOfBounds,
            4 => {
                let ans = unsafe { self.kind.InvalidKey };
                crate::api::error::PsbtError::InvalidKey {
                    key: ans.key.cst_decode(),
                }
            }
            5 => crate::api::error::PsbtError::InvalidProprietaryKey,
            6 => {
                let ans = unsafe { self.kind.DuplicateKey };
                crate::api::error::PsbtError::DuplicateKey {
                    key: ans.key.cst_decode(),
                }
            }
            7 => crate::api::error::PsbtError::UnsignedTxHasScriptSigs,
            8 => crate::api::error::PsbtError::UnsignedTxHasScriptWitnesses,
            9 => crate::api::error::PsbtError::MustHaveUnsignedTx,
            10 => crate::api::error::PsbtError::NoMorePairs,
            11 => crate::api::error::PsbtError::UnexpectedUnsignedTx,
            12 => {
                let ans = unsafe { self.kind.NonStandardSighashType };
                crate::api::error::PsbtError::NonStandardSighashType {
                    sighash: ans.sighash.cst_decode(),
                }
            }
            13 => {
                let ans = unsafe { self.kind.InvalidHash };
                crate::api::error::PsbtError::InvalidHash {
                    hash: ans.hash.cst_decode(),
                }
            }
            14 => crate::api::error::PsbtError::InvalidPreimageHashPair,
            15 => {
                let ans = unsafe { self.kind.CombineInconsistentKeySources };
                crate::api::error::PsbtError::CombineInconsistentKeySources {
                    xpub: ans.xpub.cst_decode(),
                }
            }
            16 => {
                let ans = unsafe { self.kind.ConsensusEncoding };
                crate::api::error::PsbtError::ConsensusEncoding {
                    encoding_error: ans.encoding_error.cst_decode(),
                }
            }
            17 => crate::api::error::PsbtError::NegativeFee,
            18 => crate::api::error::PsbtError::FeeOverflow,
            19 => {
                let ans = unsafe { self.kind.InvalidPublicKey };
                crate::api::error::PsbtError::InvalidPublicKey {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            20 => {
                let ans = unsafe { self.kind.InvalidSecp256k1PublicKey };
                crate::api::error::PsbtError::InvalidSecp256k1PublicKey {
                    secp256k1_error: ans.secp256k1_error.cst_decode(),
                }
            }
            21 => crate::api::error::PsbtError::InvalidXOnlyPublicKey,
            22 => {
                let ans = unsafe { self.kind.InvalidEcdsaSignature };
                crate::api::error::PsbtError::InvalidEcdsaSignature {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            23 => {
                let ans = unsafe { self.kind.InvalidTaprootSignature };
                crate::api::error::PsbtError::InvalidTaprootSignature {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            24 => crate::api::error::PsbtError::InvalidControlBlock,
            25 => crate::api::error::PsbtError::InvalidLeafVersion,
            26 => crate::api::error::PsbtError::Taproot,
            27 => {
                let ans = unsafe { self.kind.TapTree };
                crate::api::error::PsbtError::TapTree {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            28 => crate::api::error::PsbtError::XPubKey,
            29 => {
                let ans = unsafe { self.kind.Version };
                crate::api::error::PsbtError::Version {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            30 => crate::api::error::PsbtError::PartialDataConsumption,
            31 => {
                let ans = unsafe { self.kind.Io };
                crate::api::error::PsbtError::Io {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            32 => crate::api::error::PsbtError::OtherPsbtErr,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::PsbtParseError> for wire_cst_psbt_parse_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::PsbtParseError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.PsbtEncoding };
                crate::api::error::PsbtParseError::PsbtEncoding {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            1 => {
                let ans = unsafe { self.kind.Base64Encoding };
                crate::api::error::PsbtParseError::Base64Encoding {
                    error_message: ans.error_message.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::SqliteError> for wire_cst_sqlite_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::SqliteError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Sqlite };
                crate::api::error::SqliteError::Sqlite {
                    rusqlite_error: ans.rusqlite_error.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::TransactionError> for wire_cst_transaction_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::TransactionError {
        match self.tag {
            0 => crate::api::error::TransactionError::Io,
            1 => crate::api::error::TransactionError::OversizedVectorAllocation,
            2 => {
                let ans = unsafe { self.kind.InvalidChecksum };
                crate::api::error::TransactionError::InvalidChecksum {
                    expected: ans.expected.cst_decode(),
                    actual: ans.actual.cst_decode(),
                }
            }
            3 => crate::api::error::TransactionError::NonMinimalVarInt,
            4 => crate::api::error::TransactionError::ParseFailed,
            5 => {
                let ans = unsafe { self.kind.UnsupportedSegwitFlag };
                crate::api::error::TransactionError::UnsupportedSegwitFlag {
                    flag: ans.flag.cst_decode(),
                }
            }
            6 => crate::api::error::TransactionError::OtherTransactionErr,
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::TxIn> for wire_cst_tx_in {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::TxIn {
        crate::api::bitcoin::TxIn {
            previous_output: self.previous_output.cst_decode(),
            script_sig: self.script_sig.cst_decode(),
            sequence: self.sequence.cst_decode(),
            witness: self.witness.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::bitcoin::TxOut> for wire_cst_tx_out {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::bitcoin::TxOut {
        crate::api::bitcoin::TxOut {
            value: self.value.cst_decode(),
            script_pubkey: self.script_pubkey.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::Update> for wire_cst_update {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Update {
        crate::api::types::Update(self.field0.cst_decode())
    }
}
impl NewWithNullPtr for wire_cst_address_parse_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: AddressParseErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_address_parse_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bip_32_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: Bip32ErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bip_32_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bip_39_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: Bip39ErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bip_39_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_create_with_persist_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: CreateWithPersistErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_create_with_persist_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_descriptor_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: DescriptorErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_descriptor_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_descriptor_key_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: DescriptorKeyErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_descriptor_key_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_electrum_client {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_electrum_client {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_electrum_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: ElectrumErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_electrum_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_esplora_client {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_esplora_client {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_esplora_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: EsploraErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_esplora_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_extract_tx_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: ExtractTxErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_extract_tx_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_address {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_address {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_connection {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_connection {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_derivation_path {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_derivation_path {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_descriptor {
    fn new_with_null_ptr() -> Self {
        Self {
            extended_descriptor: Default::default(),
            key_map: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_descriptor {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_descriptor_public_key {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_descriptor_public_key {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_descriptor_secret_key {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_descriptor_secret_key {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_full_scan_request {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_full_scan_request {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_full_scan_request_builder {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_full_scan_request_builder {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_mnemonic {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_mnemonic {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_psbt {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_psbt {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_script_buf {
    fn new_with_null_ptr() -> Self {
        Self {
            bytes: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_ffi_script_buf {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_sync_request {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_sync_request {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_sync_request_builder {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_sync_request_builder {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_transaction {
    fn new_with_null_ptr() -> Self {
        Self {
            s: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_ffi_transaction {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_ffi_wallet {
    fn new_with_null_ptr() -> Self {
        Self {
            ptr: Default::default(),
        }
    }
}
impl Default for wire_cst_ffi_wallet {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_from_script_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: FromScriptErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_from_script_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_lock_time {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: LockTimeKind { nil__: () },
        }
    }
}
impl Default for wire_cst_lock_time {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_out_point {
    fn new_with_null_ptr() -> Self {
        Self {
            txid: core::ptr::null_mut(),
            vout: Default::default(),
        }
    }
}
impl Default for wire_cst_out_point {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_psbt_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: PsbtErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_psbt_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_psbt_parse_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: PsbtParseErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_psbt_parse_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_sqlite_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: SqliteErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_sqlite_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_transaction_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: TransactionErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_transaction_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_tx_in {
    fn new_with_null_ptr() -> Self {
        Self {
            previous_output: Default::default(),
            script_sig: Default::default(),
            sequence: Default::default(),
            witness: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_tx_in {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_tx_out {
    fn new_with_null_ptr() -> Self {
        Self {
            value: Default::default(),
            script_pubkey: Default::default(),
        }
    }
}
impl Default for wire_cst_tx_out {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_update {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_update {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_as_string(
    that: *mut wire_cst_ffi_address,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_address_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_from_script(
    port_: i64,
    script: *mut wire_cst_ffi_script_buf,
    network: i32,
) {
    wire__crate__api__bitcoin__ffi_address_from_script_impl(port_, script, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_from_string(
    port_: i64,
    address: *mut wire_cst_list_prim_u_8_strict,
    network: i32,
) {
    wire__crate__api__bitcoin__ffi_address_from_string_impl(port_, address, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_is_valid_for_network(
    that: *mut wire_cst_ffi_address,
    network: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_address_is_valid_for_network_impl(that, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_script(
    ptr: *mut wire_cst_ffi_address,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_address_script_impl(ptr)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_to_qr_uri(
    that: *mut wire_cst_ffi_address,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_address_to_qr_uri_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_as_string(
    port_: i64,
    that: *mut wire_cst_ffi_psbt,
) {
    wire__crate__api__bitcoin__ffi_psbt_as_string_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_combine(
    port_: i64,
    ptr: *mut wire_cst_ffi_psbt,
    other: *mut wire_cst_ffi_psbt,
) {
    wire__crate__api__bitcoin__ffi_psbt_combine_impl(port_, ptr, other)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_extract_tx(
    ptr: *mut wire_cst_ffi_psbt,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_psbt_extract_tx_impl(ptr)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_fee_amount(
    that: *mut wire_cst_ffi_psbt,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_psbt_fee_amount_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_from_str(
    port_: i64,
    psbt_base64: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__bitcoin__ffi_psbt_from_str_impl(port_, psbt_base64)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_json_serialize(
    that: *mut wire_cst_ffi_psbt,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_psbt_json_serialize_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_serialize(
    that: *mut wire_cst_ffi_psbt,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_psbt_serialize_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_as_string(
    that: *mut wire_cst_ffi_script_buf,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_script_buf_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_empty(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__bitcoin__ffi_script_buf_empty_impl()
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_with_capacity(
    port_: i64,
    capacity: usize,
) {
    wire__crate__api__bitcoin__ffi_script_buf_with_capacity_impl(port_, capacity)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_compute_txid(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_compute_txid_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_from_bytes(
    port_: i64,
    transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
) {
    wire__crate__api__bitcoin__ffi_transaction_from_bytes_impl(port_, transaction_bytes)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_input(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_input_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_coinbase(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_is_coinbase_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_lock_time(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_lock_time_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_output(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_output_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_serialize(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_serialize_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_version(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_version_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_vsize(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_vsize_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_weight(
    port_: i64,
    that: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__bitcoin__ffi_transaction_weight_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_as_string(
    that: *mut wire_cst_ffi_descriptor,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__descriptor__ffi_descriptor_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight(
    that: *mut wire_cst_ffi_descriptor,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new(
    port_: i64,
    descriptor: *mut wire_cst_list_prim_u_8_strict,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_impl(port_, descriptor, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip44(
    port_: i64,
    secret_key: *mut wire_cst_ffi_descriptor_secret_key,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip44_impl(
        port_,
        secret_key,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip44_public(
    port_: i64,
    public_key: *mut wire_cst_ffi_descriptor_public_key,
    fingerprint: *mut wire_cst_list_prim_u_8_strict,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip44_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip49(
    port_: i64,
    secret_key: *mut wire_cst_ffi_descriptor_secret_key,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip49_impl(
        port_,
        secret_key,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip49_public(
    port_: i64,
    public_key: *mut wire_cst_ffi_descriptor_public_key,
    fingerprint: *mut wire_cst_list_prim_u_8_strict,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip49_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip84(
    port_: i64,
    secret_key: *mut wire_cst_ffi_descriptor_secret_key,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip84_impl(
        port_,
        secret_key,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip84_public(
    port_: i64,
    public_key: *mut wire_cst_ffi_descriptor_public_key,
    fingerprint: *mut wire_cst_list_prim_u_8_strict,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip84_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip86(
    port_: i64,
    secret_key: *mut wire_cst_ffi_descriptor_secret_key,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip86_impl(
        port_,
        secret_key,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip86_public(
    port_: i64,
    public_key: *mut wire_cst_ffi_descriptor_public_key,
    fingerprint: *mut wire_cst_list_prim_u_8_strict,
    keychain_kind: i32,
    network: i32,
) {
    wire__crate__api__descriptor__ffi_descriptor_new_bip86_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret(
    that: *mut wire_cst_ffi_descriptor,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__electrum_client_broadcast(
    port_: i64,
    that: *mut wire_cst_electrum_client,
    transaction: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__electrum__electrum_client_broadcast_impl(port_, that, transaction)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__electrum_client_full_scan(
    port_: i64,
    that: *mut wire_cst_electrum_client,
    request: *mut wire_cst_ffi_full_scan_request,
    stop_gap: u64,
    batch_size: u64,
    fetch_prev_txouts: bool,
) {
    wire__crate__api__electrum__electrum_client_full_scan_impl(
        port_,
        that,
        request,
        stop_gap,
        batch_size,
        fetch_prev_txouts,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__electrum_client_new(
    port_: i64,
    url: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__electrum__electrum_client_new_impl(port_, url)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__electrum_client_sync(
    port_: i64,
    that: *mut wire_cst_electrum_client,
    request: *mut wire_cst_ffi_sync_request,
    batch_size: u64,
    fetch_prev_txouts: bool,
) {
    wire__crate__api__electrum__electrum_client_sync_impl(
        port_,
        that,
        request,
        batch_size,
        fetch_prev_txouts,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__esplora_client_broadcast(
    port_: i64,
    that: *mut wire_cst_esplora_client,
    transaction: *mut wire_cst_ffi_transaction,
) {
    wire__crate__api__esplora__esplora_client_broadcast_impl(port_, that, transaction)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__esplora_client_full_scan(
    port_: i64,
    that: *mut wire_cst_esplora_client,
    request: *mut wire_cst_ffi_full_scan_request,
    stop_gap: u64,
    parallel_requests: u64,
) {
    wire__crate__api__esplora__esplora_client_full_scan_impl(
        port_,
        that,
        request,
        stop_gap,
        parallel_requests,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__esplora_client_new(
    port_: i64,
    url: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__esplora__esplora_client_new_impl(port_, url)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__esplora_client_sync(
    port_: i64,
    that: *mut wire_cst_esplora_client,
    request: *mut wire_cst_ffi_sync_request,
    parallel_requests: u64,
) {
    wire__crate__api__esplora__esplora_client_sync_impl(port_, that, request, parallel_requests)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_derivation_path_as_string(
    that: *mut wire_cst_ffi_derivation_path,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_derivation_path_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_derivation_path_from_string(
    port_: i64,
    path: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__key__ffi_derivation_path_from_string_impl(port_, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_as_string(
    that: *mut wire_cst_ffi_descriptor_public_key,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_descriptor_public_key_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_derive(
    port_: i64,
    ptr: *mut wire_cst_ffi_descriptor_public_key,
    path: *mut wire_cst_ffi_derivation_path,
) {
    wire__crate__api__key__ffi_descriptor_public_key_derive_impl(port_, ptr, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_extend(
    port_: i64,
    ptr: *mut wire_cst_ffi_descriptor_public_key,
    path: *mut wire_cst_ffi_derivation_path,
) {
    wire__crate__api__key__ffi_descriptor_public_key_extend_impl(port_, ptr, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_from_string(
    port_: i64,
    public_key: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__key__ffi_descriptor_public_key_from_string_impl(port_, public_key)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_as_public(
    ptr: *mut wire_cst_ffi_descriptor_secret_key,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_descriptor_secret_key_as_public_impl(ptr)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_as_string(
    that: *mut wire_cst_ffi_descriptor_secret_key,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_descriptor_secret_key_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_create(
    port_: i64,
    network: i32,
    mnemonic: *mut wire_cst_ffi_mnemonic,
    password: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__key__ffi_descriptor_secret_key_create_impl(port_, network, mnemonic, password)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_derive(
    port_: i64,
    ptr: *mut wire_cst_ffi_descriptor_secret_key,
    path: *mut wire_cst_ffi_derivation_path,
) {
    wire__crate__api__key__ffi_descriptor_secret_key_derive_impl(port_, ptr, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_extend(
    port_: i64,
    ptr: *mut wire_cst_ffi_descriptor_secret_key,
    path: *mut wire_cst_ffi_derivation_path,
) {
    wire__crate__api__key__ffi_descriptor_secret_key_extend_impl(port_, ptr, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_from_string(
    port_: i64,
    secret_key: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__key__ffi_descriptor_secret_key_from_string_impl(port_, secret_key)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes(
    that: *mut wire_cst_ffi_descriptor_secret_key,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_as_string(
    that: *mut wire_cst_ffi_mnemonic,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    wire__crate__api__key__ffi_mnemonic_as_string_impl(that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_from_entropy(
    port_: i64,
    entropy: *mut wire_cst_list_prim_u_8_loose,
) {
    wire__crate__api__key__ffi_mnemonic_from_entropy_impl(port_, entropy)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_from_string(
    port_: i64,
    mnemonic: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__key__ffi_mnemonic_from_string_impl(port_, mnemonic)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_new(
    port_: i64,
    word_count: i32,
) {
    wire__crate__api__key__ffi_mnemonic_new_impl(port_, word_count)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__store__ffi_connection_new(
    port_: i64,
    path: *mut wire_cst_list_prim_u_8_strict,
) {
    wire__crate__api__store__ffi_connection_new_impl(port_, path)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__store__ffi_connection_new_in_memory(
    port_: i64,
) {
    wire__crate__api__store__ffi_connection_new_in_memory_impl(port_)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_full_scan_request_builder_build(
    port_: i64,
    that: *mut wire_cst_ffi_full_scan_request_builder,
) {
    wire__crate__api__types__ffi_full_scan_request_builder_build_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains(
    port_: i64,
    that: *mut wire_cst_ffi_full_scan_request_builder,
    inspector: *const std::ffi::c_void,
) {
    wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains_impl(
        port_, that, inspector,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_sync_request_builder_build(
    port_: i64,
    that: *mut wire_cst_ffi_sync_request_builder,
) {
    wire__crate__api__types__ffi_sync_request_builder_build_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_sync_request_builder_inspect_spks(
    port_: i64,
    that: *mut wire_cst_ffi_sync_request_builder,
    inspector: *const std::ffi::c_void,
) {
    wire__crate__api__types__ffi_sync_request_builder_inspect_spks_impl(port_, that, inspector)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_new(
    port_: i64,
    descriptor: *mut wire_cst_ffi_descriptor,
    change_descriptor: *mut wire_cst_ffi_descriptor,
    network: i32,
    connection: *mut wire_cst_ffi_connection,
) {
    wire__crate__api__wallet__ffi_wallet_new_impl(
        port_,
        descriptor,
        change_descriptor,
        network,
        connection,
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_corebitcoinAddress(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_core::bitcoin::Address>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_corebitcoinAddress(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_core::bitcoin::Address>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_electrum :: BdkElectrumClient < bdk_electrum :: electrum_client :: Client >>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_electrum :: BdkElectrumClient < bdk_electrum :: electrum_client :: Client >>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_esplora::esplora_client::BlockingClient>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_esplora::esplora_client::BlockingClient>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletUpdate(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::Update>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletUpdate(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::Update>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::bitcoin::bip32::DerivationPath>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::bitcoin::bip32::DerivationPath>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::descriptor::ExtendedDescriptor>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::descriptor::ExtendedDescriptor>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::DescriptorPublicKey>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::DescriptorPublicKey>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::DescriptorSecretKey>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::DescriptorSecretKey>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysKeyMap(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::KeyMap>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysKeyMap(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::KeyMap>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::bip39::Mnemonic>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bdk_wallet::keys::bip39::Mnemonic>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        >::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        >::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        >::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        >::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std :: sync :: Mutex < bdk_wallet :: PersistedWallet < bdk_wallet :: rusqlite :: Connection > >>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std :: sync :: Mutex < bdk_wallet :: PersistedWallet < bdk_wallet :: rusqlite :: Connection > >>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>::increment_strong_count(
            ptr as _,
        );
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>::decrement_strong_count(
            ptr as _,
        );
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_electrum_client(
) -> *mut wire_cst_electrum_client {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_electrum_client::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_esplora_client(
) -> *mut wire_cst_esplora_client {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_esplora_client::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_address() -> *mut wire_cst_ffi_address
{
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_ffi_address::new_with_null_ptr())
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_connection(
) -> *mut wire_cst_ffi_connection {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_connection::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_derivation_path(
) -> *mut wire_cst_ffi_derivation_path {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_derivation_path::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor(
) -> *mut wire_cst_ffi_descriptor {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_descriptor::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor_public_key(
) -> *mut wire_cst_ffi_descriptor_public_key {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_descriptor_public_key::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor_secret_key(
) -> *mut wire_cst_ffi_descriptor_secret_key {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_descriptor_secret_key::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_full_scan_request(
) -> *mut wire_cst_ffi_full_scan_request {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_full_scan_request::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_full_scan_request_builder(
) -> *mut wire_cst_ffi_full_scan_request_builder {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_full_scan_request_builder::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_mnemonic() -> *mut wire_cst_ffi_mnemonic
{
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_ffi_mnemonic::new_with_null_ptr())
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_psbt() -> *mut wire_cst_ffi_psbt {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_ffi_psbt::new_with_null_ptr())
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_script_buf(
) -> *mut wire_cst_ffi_script_buf {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_script_buf::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_sync_request(
) -> *mut wire_cst_ffi_sync_request {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_sync_request::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_sync_request_builder(
) -> *mut wire_cst_ffi_sync_request_builder {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_sync_request_builder::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_transaction(
) -> *mut wire_cst_ffi_transaction {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_ffi_transaction::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_list_prim_u_8_strict(
    len: i32,
) -> *mut wire_cst_list_list_prim_u_8_strict {
    let wrap = wire_cst_list_list_prim_u_8_strict {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_loose(
    len: i32,
) -> *mut wire_cst_list_prim_u_8_loose {
    let ans = wire_cst_list_prim_u_8_loose {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_strict(
    len: i32,
) -> *mut wire_cst_list_prim_u_8_strict {
    let ans = wire_cst_list_prim_u_8_strict {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
    let wrap = wire_cst_list_tx_in {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <wire_cst_tx_in>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
    let wrap = wire_cst_list_tx_out {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <wire_cst_tx_out>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_address_parse_error {
    tag: i32,
    kind: AddressParseErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union AddressParseErrorKind {
    WitnessVersion: wire_cst_AddressParseError_WitnessVersion,
    WitnessProgram: wire_cst_AddressParseError_WitnessProgram,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_AddressParseError_WitnessVersion {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_AddressParseError_WitnessProgram {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bip_32_error {
    tag: i32,
    kind: Bip32ErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union Bip32ErrorKind {
    Secp256k1: wire_cst_Bip32Error_Secp256k1,
    InvalidChildNumber: wire_cst_Bip32Error_InvalidChildNumber,
    UnknownVersion: wire_cst_Bip32Error_UnknownVersion,
    WrongExtendedKeyLength: wire_cst_Bip32Error_WrongExtendedKeyLength,
    Base58: wire_cst_Bip32Error_Base58,
    Hex: wire_cst_Bip32Error_Hex,
    InvalidPublicKeyHexLength: wire_cst_Bip32Error_InvalidPublicKeyHexLength,
    UnknownError: wire_cst_Bip32Error_UnknownError,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_Secp256k1 {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_InvalidChildNumber {
    child_number: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_UnknownVersion {
    version: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_WrongExtendedKeyLength {
    length: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_Base58 {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_Hex {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_InvalidPublicKeyHexLength {
    length: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip32Error_UnknownError {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bip_39_error {
    tag: i32,
    kind: Bip39ErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union Bip39ErrorKind {
    BadWordCount: wire_cst_Bip39Error_BadWordCount,
    UnknownWord: wire_cst_Bip39Error_UnknownWord,
    BadEntropyBitCount: wire_cst_Bip39Error_BadEntropyBitCount,
    AmbiguousLanguages: wire_cst_Bip39Error_AmbiguousLanguages,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip39Error_BadWordCount {
    word_count: u64,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip39Error_UnknownWord {
    index: u64,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip39Error_BadEntropyBitCount {
    bit_count: u64,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Bip39Error_AmbiguousLanguages {
    languages: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_create_with_persist_error {
    tag: i32,
    kind: CreateWithPersistErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union CreateWithPersistErrorKind {
    Persist: wire_cst_CreateWithPersistError_Persist,
    Descriptor: wire_cst_CreateWithPersistError_Descriptor,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_CreateWithPersistError_Persist {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_CreateWithPersistError_Descriptor {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_descriptor_error {
    tag: i32,
    kind: DescriptorErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union DescriptorErrorKind {
    Key: wire_cst_DescriptorError_Key,
    Generic: wire_cst_DescriptorError_Generic,
    Policy: wire_cst_DescriptorError_Policy,
    InvalidDescriptorCharacter: wire_cst_DescriptorError_InvalidDescriptorCharacter,
    Bip32: wire_cst_DescriptorError_Bip32,
    Base58: wire_cst_DescriptorError_Base58,
    Pk: wire_cst_DescriptorError_Pk,
    Miniscript: wire_cst_DescriptorError_Miniscript,
    Hex: wire_cst_DescriptorError_Hex,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Key {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Generic {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Policy {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_InvalidDescriptorCharacter {
    char: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Bip32 {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Base58 {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Pk {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Miniscript {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorError_Hex {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_descriptor_key_error {
    tag: i32,
    kind: DescriptorKeyErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union DescriptorKeyErrorKind {
    Parse: wire_cst_DescriptorKeyError_Parse,
    Bip32: wire_cst_DescriptorKeyError_Bip32,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorKeyError_Parse {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_DescriptorKeyError_Bip32 {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_electrum_client {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_electrum_error {
    tag: i32,
    kind: ElectrumErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union ElectrumErrorKind {
    IOError: wire_cst_ElectrumError_IOError,
    Json: wire_cst_ElectrumError_Json,
    Hex: wire_cst_ElectrumError_Hex,
    Protocol: wire_cst_ElectrumError_Protocol,
    Bitcoin: wire_cst_ElectrumError_Bitcoin,
    InvalidResponse: wire_cst_ElectrumError_InvalidResponse,
    Message: wire_cst_ElectrumError_Message,
    InvalidDNSNameError: wire_cst_ElectrumError_InvalidDNSNameError,
    SharedIOError: wire_cst_ElectrumError_SharedIOError,
    CouldNotCreateConnection: wire_cst_ElectrumError_CouldNotCreateConnection,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_IOError {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_Json {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_Hex {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_Protocol {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_Bitcoin {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_InvalidResponse {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_Message {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_InvalidDNSNameError {
    domain: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_SharedIOError {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ElectrumError_CouldNotCreateConnection {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_esplora_client {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_esplora_error {
    tag: i32,
    kind: EsploraErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union EsploraErrorKind {
    Minreq: wire_cst_EsploraError_Minreq,
    HttpResponse: wire_cst_EsploraError_HttpResponse,
    Parsing: wire_cst_EsploraError_Parsing,
    StatusCode: wire_cst_EsploraError_StatusCode,
    BitcoinEncoding: wire_cst_EsploraError_BitcoinEncoding,
    HexToArray: wire_cst_EsploraError_HexToArray,
    HexToBytes: wire_cst_EsploraError_HexToBytes,
    HeaderHeightNotFound: wire_cst_EsploraError_HeaderHeightNotFound,
    InvalidHttpHeaderName: wire_cst_EsploraError_InvalidHttpHeaderName,
    InvalidHttpHeaderValue: wire_cst_EsploraError_InvalidHttpHeaderValue,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_Minreq {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_HttpResponse {
    status: u16,
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_Parsing {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_StatusCode {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_BitcoinEncoding {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_HexToArray {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_HexToBytes {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_HeaderHeightNotFound {
    height: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_InvalidHttpHeaderName {
    name: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_EsploraError_InvalidHttpHeaderValue {
    value: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_extract_tx_error {
    tag: i32,
    kind: ExtractTxErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union ExtractTxErrorKind {
    AbsurdFeeRate: wire_cst_ExtractTxError_AbsurdFeeRate,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ExtractTxError_AbsurdFeeRate {
    fee_rate: u64,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_address {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_connection {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_derivation_path {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_descriptor {
    extended_descriptor: usize,
    key_map: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_descriptor_public_key {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_descriptor_secret_key {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_full_scan_request {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_full_scan_request_builder {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_mnemonic {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_psbt {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_script_buf {
    bytes: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_sync_request {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_sync_request_builder {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_transaction {
    s: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_ffi_wallet {
    ptr: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_from_script_error {
    tag: i32,
    kind: FromScriptErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union FromScriptErrorKind {
    WitnessProgram: wire_cst_FromScriptError_WitnessProgram,
    WitnessVersion: wire_cst_FromScriptError_WitnessVersion,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_FromScriptError_WitnessProgram {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_FromScriptError_WitnessVersion {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_list_prim_u_8_strict {
    ptr: *mut *mut wire_cst_list_prim_u_8_strict,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_prim_u_8_loose {
    ptr: *mut u8,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_prim_u_8_strict {
    ptr: *mut u8,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_tx_in {
    ptr: *mut wire_cst_tx_in,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_tx_out {
    ptr: *mut wire_cst_tx_out,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_lock_time {
    tag: i32,
    kind: LockTimeKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union LockTimeKind {
    Blocks: wire_cst_LockTime_Blocks,
    Seconds: wire_cst_LockTime_Seconds,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_LockTime_Blocks {
    field0: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_LockTime_Seconds {
    field0: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_out_point {
    txid: *mut wire_cst_list_prim_u_8_strict,
    vout: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_psbt_error {
    tag: i32,
    kind: PsbtErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union PsbtErrorKind {
    InvalidKey: wire_cst_PsbtError_InvalidKey,
    DuplicateKey: wire_cst_PsbtError_DuplicateKey,
    NonStandardSighashType: wire_cst_PsbtError_NonStandardSighashType,
    InvalidHash: wire_cst_PsbtError_InvalidHash,
    CombineInconsistentKeySources: wire_cst_PsbtError_CombineInconsistentKeySources,
    ConsensusEncoding: wire_cst_PsbtError_ConsensusEncoding,
    InvalidPublicKey: wire_cst_PsbtError_InvalidPublicKey,
    InvalidSecp256k1PublicKey: wire_cst_PsbtError_InvalidSecp256k1PublicKey,
    InvalidEcdsaSignature: wire_cst_PsbtError_InvalidEcdsaSignature,
    InvalidTaprootSignature: wire_cst_PsbtError_InvalidTaprootSignature,
    TapTree: wire_cst_PsbtError_TapTree,
    Version: wire_cst_PsbtError_Version,
    Io: wire_cst_PsbtError_Io,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidKey {
    key: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_DuplicateKey {
    key: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_NonStandardSighashType {
    sighash: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidHash {
    hash: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_CombineInconsistentKeySources {
    xpub: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_ConsensusEncoding {
    encoding_error: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidPublicKey {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidSecp256k1PublicKey {
    secp256k1_error: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidEcdsaSignature {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_InvalidTaprootSignature {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_TapTree {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_Version {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtError_Io {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_psbt_parse_error {
    tag: i32,
    kind: PsbtParseErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union PsbtParseErrorKind {
    PsbtEncoding: wire_cst_PsbtParseError_PsbtEncoding,
    Base64Encoding: wire_cst_PsbtParseError_Base64Encoding,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtParseError_PsbtEncoding {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_PsbtParseError_Base64Encoding {
    error_message: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_sqlite_error {
    tag: i32,
    kind: SqliteErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union SqliteErrorKind {
    Sqlite: wire_cst_SqliteError_Sqlite,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_SqliteError_Sqlite {
    rusqlite_error: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_transaction_error {
    tag: i32,
    kind: TransactionErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union TransactionErrorKind {
    InvalidChecksum: wire_cst_TransactionError_InvalidChecksum,
    UnsupportedSegwitFlag: wire_cst_TransactionError_UnsupportedSegwitFlag,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_TransactionError_InvalidChecksum {
    expected: *mut wire_cst_list_prim_u_8_strict,
    actual: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_TransactionError_UnsupportedSegwitFlag {
    flag: u8,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_tx_in {
    previous_output: wire_cst_out_point,
    script_sig: wire_cst_ffi_script_buf,
    sequence: u32,
    witness: *mut wire_cst_list_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_tx_out {
    value: u64,
    script_pubkey: wire_cst_ffi_script_buf,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_update {
    field0: usize,
}
