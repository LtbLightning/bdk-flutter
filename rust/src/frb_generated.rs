// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::electrum::*;
use crate::api::esplora::*;
use crate::api::store::*;
use crate::api::types::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.4.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1125178077;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__bitcoin__ffi_address_as_string_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiAddress::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_address_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    script: impl CstDecode<crate::api::bitcoin::FfiScriptBuf>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_script = script.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::FromScriptError>((move || {
                    let output_ok =
                        crate::api::bitcoin::FfiAddress::from_script(api_script, api_network)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_address_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::AddressParseError>((move || {
                    let output_ok =
                        crate::api::bitcoin::FfiAddress::from_string(api_address, api_network)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_address_is_valid_for_network_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiAddress>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_is_valid_for_network",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bitcoin::FfiAddress::is_valid_for_network(&api_that, api_network),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_address_script_impl(
    opaque: impl CstDecode<crate::api::bitcoin::FfiAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_script",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiAddress::script(api_opaque))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_address_to_qr_uri_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_address_to_qr_uri",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiAddress::to_qr_uri(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_as_string_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiPsbt::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_combine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
    other: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_combine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_other = other.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::PsbtError>((move || {
                    let output_ok = crate::api::bitcoin::FfiPsbt::combine(api_opaque, api_other)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_extract_tx_impl(
    opaque: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_extract_tx",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            transform_result_dco::<_, _, crate::api::error::ExtractTxError>((move || {
                let output_ok = crate::api::bitcoin::FfiPsbt::extract_tx(api_opaque)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_fee_amount_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_fee_amount",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiPsbt::fee_amount(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_from_str_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    psbt_base64: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_from_str",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_psbt_base64 = psbt_base64.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::PsbtParseError>((move || {
                    let output_ok = crate::api::bitcoin::FfiPsbt::from_str(api_psbt_base64)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_json_serialize_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_json_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::PsbtError>((move || {
                let output_ok = crate::api::bitcoin::FfiPsbt::json_serialize(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_psbt_serialize_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_psbt_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiPsbt::serialize(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_script_buf_as_string_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiScriptBuf>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_script_buf_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiScriptBuf::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_script_buf_empty_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_script_buf_empty",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::bitcoin::FfiScriptBuf::empty())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_script_buf_with_capacity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    capacity: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_script_buf_with_capacity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_capacity = capacity.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::bitcoin::FfiScriptBuf::with_capacity(api_capacity),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_compute_txid_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_compute_txid",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bitcoin::FfiTransaction::compute_txid(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    transaction_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_transaction_bytes = transaction_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::TransactionError>((move || {
                    let output_ok =
                        crate::api::bitcoin::FfiTransaction::from_bytes(api_transaction_bytes)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_input_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_input",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::input(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_is_coinbase_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_is_coinbase",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bitcoin::FfiTransaction::is_coinbase(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_is_explicitly_rbf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bitcoin::FfiTransaction::is_explicitly_rbf(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_is_lock_time_enabled",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bitcoin::FfiTransaction::is_lock_time_enabled(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_lock_time_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_lock_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::lock_time(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    version: impl CstDecode<i32>,
    lock_time: impl CstDecode<crate::api::types::LockTime>,
    input: impl CstDecode<Vec<crate::api::bitcoin::TxIn>>,
    output: impl CstDecode<Vec<crate::api::bitcoin::TxOut>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_version = version.cst_decode();
            let api_lock_time = lock_time.cst_decode();
            let api_input = input.cst_decode();
            let api_output = output.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::TransactionError>((move || {
                    let output_ok = crate::api::bitcoin::FfiTransaction::new(
                        api_version,
                        api_lock_time,
                        api_input,
                        api_output,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_output_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_output",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::output(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_serialize_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::serialize(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_version_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_version",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::version(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_vsize_impl(
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_vsize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bitcoin::FfiTransaction::vsize(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bitcoin__ffi_transaction_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_transaction_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::bitcoin::FfiTransaction::weight(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_as_string_impl(
    that: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::descriptor::FfiDescriptor::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight_impl(
    that: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_max_satisfaction_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                let output_ok =
                    crate::api::descriptor::FfiDescriptor::max_satisfaction_weight(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok =
                        crate::api::descriptor::FfiDescriptor::new(api_descriptor, api_network)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip44_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip44",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip44(
                        api_secret_key,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip44_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip44_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip44_public(
                        api_public_key,
                        api_fingerprint,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip49_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip49",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip49(
                        api_secret_key,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip49_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip49_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip49_public(
                        api_public_key,
                        api_fingerprint,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip84_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip84",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip84(
                        api_secret_key,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip84_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip84_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip84_public(
                        api_public_key,
                        api_fingerprint,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip86_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip86",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip86(
                        api_secret_key,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_new_bip86_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_new_bip86_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::descriptor::FfiDescriptor::new_bip86_public(
                        api_public_key,
                        api_fingerprint,
                        api_keychain_kind,
                        api_network,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret_impl(
    that: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_to_string_with_secret",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::descriptor::FfiDescriptor::to_string_with_secret(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__electrum__ffi_electrum_client_broadcast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::electrum::FfiElectrumClient>,
    transaction: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_electrum_client_broadcast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_transaction = transaction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::ElectrumError>((move || {
                    let output_ok = crate::api::electrum::FfiElectrumClient::broadcast(
                        api_opaque,
                        &api_transaction,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__electrum__ffi_electrum_client_full_scan_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::electrum::FfiElectrumClient>,
    request: impl CstDecode<crate::api::types::FfiFullScanRequest>,
    stop_gap: impl CstDecode<u64>,
    batch_size: impl CstDecode<u64>,
    fetch_prev_txouts: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_electrum_client_full_scan",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_request = request.cst_decode();
            let api_stop_gap = stop_gap.cst_decode();
            let api_batch_size = batch_size.cst_decode();
            let api_fetch_prev_txouts = fetch_prev_txouts.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::ElectrumError>((move || {
                    let output_ok = crate::api::electrum::FfiElectrumClient::full_scan(
                        api_opaque,
                        api_request,
                        api_stop_gap,
                        api_batch_size,
                        api_fetch_prev_txouts,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__electrum__ffi_electrum_client_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_electrum_client_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_url = url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::ElectrumError>((move || {
                    let output_ok = crate::api::electrum::FfiElectrumClient::new(api_url)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__electrum__ffi_electrum_client_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::electrum::FfiElectrumClient>,
    request: impl CstDecode<crate::api::types::FfiSyncRequest>,
    batch_size: impl CstDecode<u64>,
    fetch_prev_txouts: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_electrum_client_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_request = request.cst_decode();
            let api_batch_size = batch_size.cst_decode();
            let api_fetch_prev_txouts = fetch_prev_txouts.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::ElectrumError>((move || {
                    let output_ok = crate::api::electrum::FfiElectrumClient::sync(
                        api_opaque,
                        api_request,
                        api_batch_size,
                        api_fetch_prev_txouts,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__esplora__ffi_esplora_client_broadcast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::esplora::FfiEsploraClient>,
    transaction: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_esplora_client_broadcast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_transaction = transaction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::EsploraError>((move || {
                    let output_ok = crate::api::esplora::FfiEsploraClient::broadcast(
                        api_opaque,
                        &api_transaction,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__esplora__ffi_esplora_client_full_scan_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::esplora::FfiEsploraClient>,
    request: impl CstDecode<crate::api::types::FfiFullScanRequest>,
    stop_gap: impl CstDecode<u64>,
    parallel_requests: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_esplora_client_full_scan",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_request = request.cst_decode();
            let api_stop_gap = stop_gap.cst_decode();
            let api_parallel_requests = parallel_requests.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::EsploraError>((move || {
                    let output_ok = crate::api::esplora::FfiEsploraClient::full_scan(
                        api_opaque,
                        api_request,
                        api_stop_gap,
                        api_parallel_requests,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__esplora__ffi_esplora_client_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_esplora_client_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_url = url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::esplora::FfiEsploraClient::new(api_url))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__esplora__ffi_esplora_client_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::esplora::FfiEsploraClient>,
    request: impl CstDecode<crate::api::types::FfiSyncRequest>,
    parallel_requests: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_esplora_client_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_request = request.cst_decode();
            let api_parallel_requests = parallel_requests.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::EsploraError>((move || {
                    let output_ok = crate::api::esplora::FfiEsploraClient::sync(
                        api_opaque,
                        api_request,
                        api_parallel_requests,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__ffi_derivation_path_as_string_impl(
    that: impl CstDecode<crate::api::key::FfiDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_derivation_path_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::key::FfiDerivationPath::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_derivation_path_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_derivation_path_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::Bip32Error>((move || {
                    let output_ok = crate::api::key::FfiDerivationPath::from_string(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_public_key_as_string_impl(
    that: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_public_key_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::key::FfiDescriptorPublicKey::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_public_key_derive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    path: impl CstDecode<crate::api::key::FfiDerivationPath>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_public_key_derive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorPublicKey::derive(api_opaque, api_path)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_public_key_extend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::key::FfiDescriptorPublicKey>,
    path: impl CstDecode<crate::api::key::FfiDerivationPath>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_public_key_extend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorPublicKey::extend(api_opaque, api_path)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_public_key_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_public_key_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorPublicKey::from_string(api_public_key)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_as_public_impl(
    opaque: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_as_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                let output_ok = crate::api::key::FfiDescriptorSecretKey::as_public(api_opaque)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_as_string_impl(
    that: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::key::FfiDescriptorSecretKey::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_create_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    network: impl CstDecode<crate::api::types::Network>,
    mnemonic: impl CstDecode<crate::api::key::FfiMnemonic>,
    password: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_create",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_network = network.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            let api_password = password.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorError>((move || {
                    let output_ok = crate::api::key::FfiDescriptorSecretKey::create(
                        api_network,
                        api_mnemonic,
                        api_password,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_derive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    path: impl CstDecode<crate::api::key::FfiDerivationPath>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_derive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorSecretKey::derive(api_opaque, api_path)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_extend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
    path: impl CstDecode<crate::api::key::FfiDerivationPath>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_extend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorSecretKey::extend(api_opaque, api_path)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                    let output_ok =
                        crate::api::key::FfiDescriptorSecretKey::from_string(api_secret_key)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes_impl(
    that: impl CstDecode<crate::api::key::FfiDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_descriptor_secret_key_secret_bytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::DescriptorKeyError>((move || {
                let output_ok = crate::api::key::FfiDescriptorSecretKey::secret_bytes(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_mnemonic_as_string_impl(
    that: impl CstDecode<crate::api::key::FfiMnemonic>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_mnemonic_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::key::FfiMnemonic::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__ffi_mnemonic_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entropy: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_mnemonic_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::Bip39Error>((move || {
                    let output_ok = crate::api::key::FfiMnemonic::from_entropy(api_entropy)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__ffi_mnemonic_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_mnemonic_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::Bip39Error>((move || {
                    let output_ok = crate::api::key::FfiMnemonic::from_string(api_mnemonic)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__ffi_mnemonic_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    word_count: impl CstDecode<crate::api::types::WordCount>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_mnemonic_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_word_count = word_count.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::Bip39Error>((move || {
                    let output_ok = crate::api::key::FfiMnemonic::new(api_word_count)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__store__ffi_connection_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_connection_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::SqliteError>((move || {
                    let output_ok = crate::api::store::FfiConnection::new(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__store__ffi_connection_new_in_memory_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_connection_new_in_memory",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, crate::api::error::SqliteError>((move || {
                    let output_ok = crate::api::store::FfiConnection::new_in_memory()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__tx_builder__finish_bump_fee_tx_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    txid: impl CstDecode<String>,
    fee_rate: impl CstDecode<crate::api::bitcoin::FeeRate>,
    wallet: impl CstDecode<crate::api::wallet::FfiWallet>,
    enable_rbf: impl CstDecode<bool>,
    n_sequence: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "finish_bump_fee_tx_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_txid = txid.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_wallet = wallet.cst_decode();
            let api_enable_rbf = enable_rbf.cst_decode();
            let api_n_sequence = n_sequence.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CreateTxError>((move || {
                    let output_ok = crate::api::tx_builder::finish_bump_fee_tx_builder(
                        api_txid,
                        api_fee_rate,
                        api_wallet,
                        api_enable_rbf,
                        api_n_sequence,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__tx_builder__tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet: impl CstDecode<crate::api::wallet::FfiWallet>,
    recipients: impl CstDecode<Vec<(crate::api::bitcoin::FfiScriptBuf, u64)>>,
    utxos: impl CstDecode<Vec<crate::api::bitcoin::OutPoint>>,
    un_spendable: impl CstDecode<Vec<crate::api::bitcoin::OutPoint>>,
    change_policy: impl CstDecode<crate::api::types::ChangeSpendPolicy>,
    manually_selected_only: impl CstDecode<bool>,
    fee_rate: impl CstDecode<Option<crate::api::bitcoin::FeeRate>>,
    fee_absolute: impl CstDecode<Option<u64>>,
    drain_wallet: impl CstDecode<bool>,
    drain_to: impl CstDecode<Option<crate::api::bitcoin::FfiScriptBuf>>,
    rbf: impl CstDecode<Option<crate::api::types::RbfValue>>,
    data: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.cst_decode();
            let api_recipients = recipients.cst_decode();
            let api_utxos = utxos.cst_decode();
            let api_un_spendable = un_spendable.cst_decode();
            let api_change_policy = change_policy.cst_decode();
            let api_manually_selected_only = manually_selected_only.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_fee_absolute = fee_absolute.cst_decode();
            let api_drain_wallet = drain_wallet.cst_decode();
            let api_drain_to = drain_to.cst_decode();
            let api_rbf = rbf.cst_decode();
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CreateTxError>((move || {
                    let output_ok = crate::api::tx_builder::tx_builder_finish(
                        api_wallet,
                        api_recipients,
                        api_utxos,
                        api_un_spendable,
                        api_change_policy,
                        api_manually_selected_only,
                        api_fee_rate,
                        api_fee_absolute,
                        api_drain_wallet,
                        api_drain_to,
                        api_rbf,
                        api_data,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__change_spend_policy_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_spend_policy_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::ChangeSpendPolicy::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__ffi_full_scan_request_builder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_full_scan_request_builder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::RequestBuilderError>((move || {
                    let output_ok = crate::api::types::FfiFullScanRequestBuilder::build(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>,
    inspector: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ffi_full_scan_request_builder_inspect_spks_for_all_keychains", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_inspector = decode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(inspector.cst_decode()); move |context|  {
                    transform_result_dco::<_, _, crate::api::error::RequestBuilderError>((move ||  {
                         let output_ok = crate::api::types::FfiFullScanRequestBuilder::inspect_spks_for_all_keychains(&api_that, api_inspector)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__types__ffi_sync_request_builder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::types::FfiSyncRequestBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_sync_request_builder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::RequestBuilderError>((move || {
                    let output_ok = crate::api::types::FfiSyncRequestBuilder::build(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__types__ffi_sync_request_builder_inspect_spks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::types::FfiSyncRequestBuilder>,
    inspector: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_sync_request_builder_inspect_spks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inspector =
                decode_DartFn_Inputs_ffi_script_buf_sync_progress_Output_unit_AnyhowException(
                    inspector.cst_decode(),
                );
            move |context| {
                transform_result_dco::<_, _, crate::api::error::RequestBuilderError>((move || {
                    let output_ok = crate::api::types::FfiSyncRequestBuilder::inspect_spks(
                        &api_that,
                        api_inspector,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__types__network_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "network_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::Network::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__sign_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::SignOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_apply_update_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
    update: impl CstDecode<crate::api::types::FfiUpdate>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_apply_update",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_update = update.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CannotConnectError>((move || {
                    let output_ok =
                        crate::api::wallet::FfiWallet::apply_update(&api_that, api_update)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_calculate_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::wallet::FfiWallet>,
    tx: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_calculate_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_tx = tx.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CalculateFeeError>((move || {
                    let output_ok =
                        crate::api::wallet::FfiWallet::calculate_fee(&api_opaque, api_tx)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_calculate_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::wallet::FfiWallet>,
    tx: impl CstDecode<crate::api::bitcoin::FfiTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_calculate_fee_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_tx = tx.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CalculateFeeError>((move || {
                    let output_ok =
                        crate::api::wallet::FfiWallet::calculate_fee_rate(&api_opaque, api_tx)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_get_balance_impl(
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_get_balance",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::get_balance(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_get_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
    txid: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_get_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_txid = txid.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::TxidParseError>((move || {
                    let output_ok = crate::api::wallet::FfiWallet::get_tx(&api_that, api_txid)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_is_mine_impl(
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
    script: impl CstDecode<crate::api::bitcoin::FfiScriptBuf>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_is_mine",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_script = script.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::is_mine(
                    &api_that, api_script,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_list_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_list_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::list_output(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_list_unspent_impl(
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_list_unspent",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::list_unspent(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_load_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
    change_descriptor: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
    connection: impl CstDecode<crate::api::store::FfiConnection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_load",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.cst_decode();
            let api_change_descriptor = change_descriptor.cst_decode();
            let api_connection = connection.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LoadWithPersistError>((move || {
                    let output_ok = crate::api::wallet::FfiWallet::load(
                        api_descriptor,
                        api_change_descriptor,
                        api_connection,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_network_impl(
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_network",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::network(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
    change_descriptor: impl CstDecode<crate::api::descriptor::FfiDescriptor>,
    network: impl CstDecode<crate::api::types::Network>,
    connection: impl CstDecode<crate::api::store::FfiConnection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.cst_decode();
            let api_change_descriptor = change_descriptor.cst_decode();
            let api_network = network.cst_decode();
            let api_connection = connection.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::CreateWithPersistError>(
                    (move || {
                        let output_ok = crate::api::wallet::FfiWallet::new(
                            api_descriptor,
                            api_change_descriptor,
                            api_network,
                            api_connection,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_persist_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::wallet::FfiWallet>,
    connection: impl CstDecode<crate::api::store::FfiConnection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_persist",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_connection = connection.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::SqliteError>((move || {
                    let output_ok =
                        crate::api::wallet::FfiWallet::persist(&api_opaque, api_connection)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_reveal_next_address_impl(
    opaque: impl CstDecode<crate::api::wallet::FfiWallet>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_reveal_next_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::reveal_next_address(
                        api_opaque,
                        api_keychain_kind,
                    ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    opaque: impl CstDecode<crate::api::wallet::FfiWallet>,
    psbt: impl CstDecode<crate::api::bitcoin::FfiPsbt>,
    sign_options: impl CstDecode<crate::api::types::SignOptions>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_opaque = opaque.cst_decode();
            let api_psbt = psbt.cst_decode();
            let api_sign_options = sign_options.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::SignerError>((move || {
                    let output_ok = crate::api::wallet::FfiWallet::sign(
                        &api_opaque,
                        api_psbt,
                        api_sign_options,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_start_full_scan_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_start_full_scan",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::wallet::FfiWallet::start_full_scan(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_start_sync_with_revealed_spks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_start_sync_with_revealed_spks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::wallet::FfiWallet::start_sync_with_revealed_spks(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__ffi_wallet_transactions_impl(
    that: impl CstDecode<crate::api::wallet::FfiWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_wallet_transactions",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::wallet::FfiWallet::transactions(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}

// Section: related_funcs

fn decode_DartFn_Inputs_ffi_script_buf_sync_progress_Output_unit_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(
    crate::api::bitcoin::FfiScriptBuf,
    crate::api::types::SyncProgress,
) -> flutter_rust_bridge::DartFnFuture<()> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: crate::api::bitcoin::FfiScriptBuf,
        arg1: crate::api::types::SyncProgress,
    ) -> () {
        let args = vec![
            arg0.into_into_dart().into_dart(),
            arg1.into_into_dart().into_dart(),
        ];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<()>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: crate::api::bitcoin::FfiScriptBuf, arg1: crate::api::types::SyncProgress| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
            arg1,
        ))
    }
}
fn decode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(
    crate::api::types::KeychainKind,
    u32,
    crate::api::bitcoin::FfiScriptBuf,
) -> flutter_rust_bridge::DartFnFuture<()> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: crate::api::types::KeychainKind,
        arg1: u32,
        arg2: crate::api::bitcoin::FfiScriptBuf,
    ) -> () {
        let args = vec![
            arg0.into_into_dart().into_dart(),
            arg1.into_into_dart().into_dart(),
            arg2.into_into_dart().into_dart(),
        ];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<()>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: crate::api::types::KeychainKind,
          arg1: u32,
          arg2: crate::api::bitcoin::FfiScriptBuf| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
            arg1,
            arg2,
        ))
    }
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::types::ChangeSpendPolicy> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ChangeSpendPolicy {
        match self {
            0 => crate::api::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::api::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::api::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<isize> for isize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> isize {
        self
    }
}
impl CstDecode<crate::api::types::KeychainKind> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::KeychainKind {
        match self {
            0 => crate::api::types::KeychainKind::ExternalChain,
            1 => crate::api::types::KeychainKind::InternalChain,
            _ => unreachable!("Invalid variant for KeychainKind: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Testnet,
            1 => crate::api::types::Network::Regtest,
            2 => crate::api::types::Network::Bitcoin,
            3 => crate::api::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<crate::api::error::RequestBuilderError> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::RequestBuilderError {
        match self {
            0 => crate::api::error::RequestBuilderError::RequestAlreadyConsumed,
            _ => unreachable!("Invalid variant for RequestBuilderError: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl CstDecode<crate::api::types::WordCount> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::WordCount {
        match self {
            0 => crate::api::types::WordCount::Words12,
            1 => crate::api::types::WordCount::Words18,
            2 => crate::api::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", self),
        }
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_dart_opaque(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_core::bitcoin::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_core::bitcoin::Transaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::Update> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::keys::KeyMap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        std::sync::Mutex<Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_address = <crate::api::bitcoin::FfiAddress>::sse_decode(deserializer);
        let mut var_keychain = <crate::api::types::KeychainKind>::sse_decode(deserializer);
        return crate::api::types::AddressInfo {
            index: var_index,
            address: var_address,
            keychain: var_keychain,
        };
    }
}

impl SseDecode for crate::api::error::AddressParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::AddressParseError::Base58;
            }
            1 => {
                return crate::api::error::AddressParseError::Bech32;
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::AddressParseError::WitnessVersion {
                    error_message: var_errorMessage,
                };
            }
            3 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::AddressParseError::WitnessProgram {
                    error_message: var_errorMessage,
                };
            }
            4 => {
                return crate::api::error::AddressParseError::UnknownHrp;
            }
            5 => {
                return crate::api::error::AddressParseError::LegacyAddressTooLong;
            }
            6 => {
                return crate::api::error::AddressParseError::InvalidBase58PayloadLength;
            }
            7 => {
                return crate::api::error::AddressParseError::InvalidLegacyPrefix;
            }
            8 => {
                return crate::api::error::AddressParseError::NetworkValidation;
            }
            9 => {
                return crate::api::error::AddressParseError::OtherAddressParseErr;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_immature = <u64>::sse_decode(deserializer);
        let mut var_trustedPending = <u64>::sse_decode(deserializer);
        let mut var_untrustedPending = <u64>::sse_decode(deserializer);
        let mut var_confirmed = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_total = <u64>::sse_decode(deserializer);
        return crate::api::types::Balance {
            immature: var_immature,
            trusted_pending: var_trustedPending,
            untrusted_pending: var_untrustedPending,
            confirmed: var_confirmed,
            spendable: var_spendable,
            total: var_total,
        };
    }
}

impl SseDecode for crate::api::error::Bip32Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::Bip32Error::CannotDeriveFromHardenedKey;
            }
            1 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::Secp256k1 {
                    error_message: var_errorMessage,
                };
            }
            2 => {
                let mut var_childNumber = <u32>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::InvalidChildNumber {
                    child_number: var_childNumber,
                };
            }
            3 => {
                return crate::api::error::Bip32Error::InvalidChildNumberFormat;
            }
            4 => {
                return crate::api::error::Bip32Error::InvalidDerivationPathFormat;
            }
            5 => {
                let mut var_version = <String>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::UnknownVersion {
                    version: var_version,
                };
            }
            6 => {
                let mut var_length = <u32>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::WrongExtendedKeyLength {
                    length: var_length,
                };
            }
            7 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::Base58 {
                    error_message: var_errorMessage,
                };
            }
            8 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::Hex {
                    error_message: var_errorMessage,
                };
            }
            9 => {
                let mut var_length = <u32>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::InvalidPublicKeyHexLength {
                    length: var_length,
                };
            }
            10 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::Bip32Error::UnknownError {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::Bip39Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_wordCount = <u64>::sse_decode(deserializer);
                return crate::api::error::Bip39Error::BadWordCount {
                    word_count: var_wordCount,
                };
            }
            1 => {
                let mut var_index = <u64>::sse_decode(deserializer);
                return crate::api::error::Bip39Error::UnknownWord { index: var_index };
            }
            2 => {
                let mut var_bitCount = <u64>::sse_decode(deserializer);
                return crate::api::error::Bip39Error::BadEntropyBitCount {
                    bit_count: var_bitCount,
                };
            }
            3 => {
                return crate::api::error::Bip39Error::InvalidChecksum;
            }
            4 => {
                let mut var_languages = <String>::sse_decode(deserializer);
                return crate::api::error::Bip39Error::AmbiguousLanguages {
                    languages: var_languages,
                };
            }
            5 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::Bip39Error::Generic {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::BlockId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_hash = <String>::sse_decode(deserializer);
        return crate::api::types::BlockId {
            height: var_height,
            hash: var_hash,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::error::CalculateFeeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CalculateFeeError::Generic {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                let mut var_outPoints =
                    <Vec<crate::api::bitcoin::OutPoint>>::sse_decode(deserializer);
                return crate::api::error::CalculateFeeError::MissingTxOut {
                    out_points: var_outPoints,
                };
            }
            2 => {
                let mut var_amount = <String>::sse_decode(deserializer);
                return crate::api::error::CalculateFeeError::NegativeFee { amount: var_amount };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::CannotConnectError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_height = <u32>::sse_decode(deserializer);
                return crate::api::error::CannotConnectError::Include { height: var_height };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChainPosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_confirmationBlockTime =
                    <crate::api::types::ConfirmationBlockTime>::sse_decode(deserializer);
                return crate::api::types::ChainPosition::Confirmed {
                    confirmation_block_time: var_confirmationBlockTime,
                };
            }
            1 => {
                let mut var_timestamp = <u64>::sse_decode(deserializer);
                return crate::api::types::ChainPosition::Unconfirmed {
                    timestamp: var_timestamp,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::api::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::api::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::ConfirmationBlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockId = <crate::api::types::BlockId>::sse_decode(deserializer);
        let mut var_confirmationTime = <u64>::sse_decode(deserializer);
        return crate::api::types::ConfirmationBlockTime {
            block_id: var_blockId,
            confirmation_time: var_confirmationTime,
        };
    }
}

impl SseDecode for crate::api::error::CreateTxError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::TransactionNotFound { txid: var_txid };
            }
            1 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::TransactionConfirmed { txid: var_txid };
            }
            2 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::IrreplaceableTransaction {
                    txid: var_txid,
                };
            }
            3 => {
                return crate::api::error::CreateTxError::FeeRateUnavailable;
            }
            4 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::Generic {
                    error_message: var_errorMessage,
                };
            }
            5 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::Descriptor {
                    error_message: var_errorMessage,
                };
            }
            6 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::Policy {
                    error_message: var_errorMessage,
                };
            }
            7 => {
                let mut var_kind = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::SpendingPolicyRequired { kind: var_kind };
            }
            8 => {
                return crate::api::error::CreateTxError::Version0;
            }
            9 => {
                return crate::api::error::CreateTxError::Version1Csv;
            }
            10 => {
                let mut var_requestedTime = <String>::sse_decode(deserializer);
                let mut var_requiredTime = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::LockTime {
                    requested_time: var_requestedTime,
                    required_time: var_requiredTime,
                };
            }
            11 => {
                return crate::api::error::CreateTxError::RbfSequence;
            }
            12 => {
                let mut var_rbf = <String>::sse_decode(deserializer);
                let mut var_csv = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::RbfSequenceCsv {
                    rbf: var_rbf,
                    csv: var_csv,
                };
            }
            13 => {
                let mut var_feeRequired = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::FeeTooLow {
                    fee_required: var_feeRequired,
                };
            }
            14 => {
                let mut var_feeRateRequired = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::FeeRateTooLow {
                    fee_rate_required: var_feeRateRequired,
                };
            }
            15 => {
                return crate::api::error::CreateTxError::NoUtxosSelected;
            }
            16 => {
                let mut var_index = <u64>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::OutputBelowDustLimit { index: var_index };
            }
            17 => {
                return crate::api::error::CreateTxError::ChangePolicyDescriptor;
            }
            18 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::CoinSelection {
                    error_message: var_errorMessage,
                };
            }
            19 => {
                let mut var_needed = <u64>::sse_decode(deserializer);
                let mut var_available = <u64>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::InsufficientFunds {
                    needed: var_needed,
                    available: var_available,
                };
            }
            20 => {
                return crate::api::error::CreateTxError::NoRecipients;
            }
            21 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::Psbt {
                    error_message: var_errorMessage,
                };
            }
            22 => {
                let mut var_key = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::MissingKeyOrigin { key: var_key };
            }
            23 => {
                let mut var_outpoint = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::UnknownUtxo {
                    outpoint: var_outpoint,
                };
            }
            24 => {
                let mut var_outpoint = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::MissingNonWitnessUtxo {
                    outpoint: var_outpoint,
                };
            }
            25 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateTxError::MiniscriptPsbt {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::CreateWithPersistError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateWithPersistError::Persist {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                return crate::api::error::CreateWithPersistError::DataAlreadyExists;
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::CreateWithPersistError::Descriptor {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::DescriptorError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::DescriptorError::InvalidHdKeyPath;
            }
            1 => {
                return crate::api::error::DescriptorError::MissingPrivateData;
            }
            2 => {
                return crate::api::error::DescriptorError::InvalidDescriptorChecksum;
            }
            3 => {
                return crate::api::error::DescriptorError::HardenedDerivationXpub;
            }
            4 => {
                return crate::api::error::DescriptorError::MultiPath;
            }
            5 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Key {
                    error_message: var_errorMessage,
                };
            }
            6 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Generic {
                    error_message: var_errorMessage,
                };
            }
            7 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Policy {
                    error_message: var_errorMessage,
                };
            }
            8 => {
                let mut var_charector = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::InvalidDescriptorCharacter {
                    charector: var_charector,
                };
            }
            9 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Bip32 {
                    error_message: var_errorMessage,
                };
            }
            10 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Base58 {
                    error_message: var_errorMessage,
                };
            }
            11 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Pk {
                    error_message: var_errorMessage,
                };
            }
            12 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Miniscript {
                    error_message: var_errorMessage,
                };
            }
            13 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Hex {
                    error_message: var_errorMessage,
                };
            }
            14 => {
                return crate::api::error::DescriptorError::ExternalAndInternalAreTheSame;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::DescriptorKeyError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorKeyError::Parse {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                return crate::api::error::DescriptorKeyError::InvalidKeyType;
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorKeyError::Bip32 {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::ElectrumError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::IOError {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::Json {
                    error_message: var_errorMessage,
                };
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::Hex {
                    error_message: var_errorMessage,
                };
            }
            3 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::Protocol {
                    error_message: var_errorMessage,
                };
            }
            4 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::Bitcoin {
                    error_message: var_errorMessage,
                };
            }
            5 => {
                return crate::api::error::ElectrumError::AlreadySubscribed;
            }
            6 => {
                return crate::api::error::ElectrumError::NotSubscribed;
            }
            7 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::InvalidResponse {
                    error_message: var_errorMessage,
                };
            }
            8 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::Message {
                    error_message: var_errorMessage,
                };
            }
            9 => {
                let mut var_domain = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::InvalidDNSNameError {
                    domain: var_domain,
                };
            }
            10 => {
                return crate::api::error::ElectrumError::MissingDomain;
            }
            11 => {
                return crate::api::error::ElectrumError::AllAttemptsErrored;
            }
            12 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::SharedIOError {
                    error_message: var_errorMessage,
                };
            }
            13 => {
                return crate::api::error::ElectrumError::CouldntLockReader;
            }
            14 => {
                return crate::api::error::ElectrumError::Mpsc;
            }
            15 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::ElectrumError::CouldNotCreateConnection {
                    error_message: var_errorMessage,
                };
            }
            16 => {
                return crate::api::error::ElectrumError::RequestAlreadyConsumed;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::EsploraError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::Minreq {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                let mut var_status = <u16>::sse_decode(deserializer);
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::HttpResponse {
                    status: var_status,
                    error_message: var_errorMessage,
                };
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::Parsing {
                    error_message: var_errorMessage,
                };
            }
            3 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::StatusCode {
                    error_message: var_errorMessage,
                };
            }
            4 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::BitcoinEncoding {
                    error_message: var_errorMessage,
                };
            }
            5 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::HexToArray {
                    error_message: var_errorMessage,
                };
            }
            6 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::HexToBytes {
                    error_message: var_errorMessage,
                };
            }
            7 => {
                return crate::api::error::EsploraError::TransactionNotFound;
            }
            8 => {
                let mut var_height = <u32>::sse_decode(deserializer);
                return crate::api::error::EsploraError::HeaderHeightNotFound {
                    height: var_height,
                };
            }
            9 => {
                return crate::api::error::EsploraError::HeaderHashNotFound;
            }
            10 => {
                let mut var_name = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::InvalidHttpHeaderName { name: var_name };
            }
            11 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::api::error::EsploraError::InvalidHttpHeaderValue {
                    value: var_value,
                };
            }
            12 => {
                return crate::api::error::EsploraError::RequestAlreadyConsumed;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::ExtractTxError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_feeRate = <u64>::sse_decode(deserializer);
                return crate::api::error::ExtractTxError::AbsurdFeeRate {
                    fee_rate: var_feeRate,
                };
            }
            1 => {
                return crate::api::error::ExtractTxError::MissingInputValue;
            }
            2 => {
                return crate::api::error::ExtractTxError::SendingTooMuch;
            }
            3 => {
                return crate::api::error::ExtractTxError::OtherExtractTxErr;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::bitcoin::FeeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_satKwu = <u64>::sse_decode(deserializer);
        return crate::api::bitcoin::FeeRate {
            sat_kwu: var_satKwu,
        };
    }
}

impl SseDecode for crate::api::bitcoin::FfiAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<bdk_core::bitcoin::Address>>::sse_decode(deserializer);
        return crate::api::bitcoin::FfiAddress(var_field0);
    }
}

impl SseDecode for crate::api::types::FfiCanonicalTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transaction = <crate::api::bitcoin::FfiTransaction>::sse_decode(deserializer);
        let mut var_chainPosition = <crate::api::types::ChainPosition>::sse_decode(deserializer);
        return crate::api::types::FfiCanonicalTx {
            transaction: var_transaction,
            chain_position: var_chainPosition,
        };
    }
}

impl SseDecode for crate::api::store::FfiConnection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>>::sse_decode(
                deserializer,
            );
        return crate::api::store::FfiConnection(var_field0);
    }
}

impl SseDecode for crate::api::key::FfiDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath>>::sse_decode(deserializer);
        return crate::api::key::FfiDerivationPath { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::descriptor::FfiDescriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_extendedDescriptor =
            <RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor>>::sse_decode(deserializer);
        let mut var_keyMap = <RustOpaqueNom<bdk_wallet::keys::KeyMap>>::sse_decode(deserializer);
        return crate::api::descriptor::FfiDescriptor {
            extended_descriptor: var_extendedDescriptor,
            key_map: var_keyMap,
        };
    }
}

impl SseDecode for crate::api::key::FfiDescriptorPublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey>>::sse_decode(deserializer);
        return crate::api::key::FfiDescriptorPublicKey { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::key::FfiDescriptorSecretKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey>>::sse_decode(deserializer);
        return crate::api::key::FfiDescriptorSecretKey { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::electrum::FfiElectrumClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque = <RustOpaqueNom<
            bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>,
        >>::sse_decode(deserializer);
        return crate::api::electrum::FfiElectrumClient { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::esplora::FfiEsploraClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient>>::sse_decode(deserializer);
        return crate::api::esplora::FfiEsploraClient { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::types::FfiFullScanRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        >>::sse_decode(deserializer);
        return crate::api::types::FfiFullScanRequest(var_field0);
    }
}

impl SseDecode for crate::api::types::FfiFullScanRequestBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        >>::sse_decode(deserializer);
        return crate::api::types::FfiFullScanRequestBuilder(var_field0);
    }
}

impl SseDecode for crate::api::key::FfiMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic>>::sse_decode(deserializer);
        return crate::api::key::FfiMnemonic { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::bitcoin::FfiPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>>::sse_decode(
                deserializer,
            );
        return crate::api::bitcoin::FfiPsbt { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::bitcoin::FfiScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::bitcoin::FfiScriptBuf { bytes: var_bytes };
    }
}

impl SseDecode for crate::api::types::FfiSyncRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >>::sse_decode(deserializer);
        return crate::api::types::FfiSyncRequest(var_field0);
    }
}

impl SseDecode for crate::api::types::FfiSyncRequestBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >>::sse_decode(deserializer);
        return crate::api::types::FfiSyncRequestBuilder(var_field0);
    }
}

impl SseDecode for crate::api::bitcoin::FfiTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<bdk_core::bitcoin::Transaction>>::sse_decode(deserializer);
        return crate::api::bitcoin::FfiTransaction { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::types::FfiUpdate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <RustOpaqueNom<bdk_wallet::Update>>::sse_decode(deserializer);
        return crate::api::types::FfiUpdate(var_field0);
    }
}

impl SseDecode for crate::api::wallet::FfiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque = <RustOpaqueNom<
            std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
        >>::sse_decode(deserializer);
        return crate::api::wallet::FfiWallet { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::error::FromScriptError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::FromScriptError::UnrecognizedScript;
            }
            1 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::FromScriptError::WitnessProgram {
                    error_message: var_errorMessage,
                };
            }
            2 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::FromScriptError::WitnessVersion {
                    error_message: var_errorMessage,
                };
            }
            3 => {
                return crate::api::error::FromScriptError::OtherFromScriptErr;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for isize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::KeychainKind::ExternalChain,
            1 => crate::api::types::KeychainKind::InternalChain,
            _ => unreachable!("Invalid variant for KeychainKind: {}", inner),
        };
    }
}

impl SseDecode for Vec<crate::api::types::FfiCanonicalTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::FfiCanonicalTx>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::LocalOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::LocalOutput>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bitcoin::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bitcoin::OutPoint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(crate::api::bitcoin::FfiScriptBuf, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(crate::api::bitcoin::FfiScriptBuf, u64)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bitcoin::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bitcoin::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bitcoin::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bitcoin::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::error::LoadWithPersistError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::LoadWithPersistError::Persist {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::LoadWithPersistError::InvalidChangeSet {
                    error_message: var_errorMessage,
                };
            }
            2 => {
                return crate::api::error::LoadWithPersistError::CouldNotLoad;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::LocalOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outpoint = <crate::api::bitcoin::OutPoint>::sse_decode(deserializer);
        let mut var_txout = <crate::api::bitcoin::TxOut>::sse_decode(deserializer);
        let mut var_keychain = <crate::api::types::KeychainKind>::sse_decode(deserializer);
        let mut var_isSpent = <bool>::sse_decode(deserializer);
        return crate::api::types::LocalOutput {
            outpoint: var_outpoint,
            txout: var_txout,
            keychain: var_keychain,
            is_spent: var_isSpent,
        };
    }
}

impl SseDecode for crate::api::types::LockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::LockTime::Blocks(var_field0);
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::LockTime::Seconds(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Testnet,
            1 => crate::api::types::Network::Regtest,
            2 => crate::api::types::Network::Bitcoin,
            3 => crate::api::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::bitcoin::FeeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::bitcoin::FeeRate>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::FfiCanonicalTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::FfiCanonicalTx>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::bitcoin::FfiScriptBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::bitcoin::FfiScriptBuf>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::RbfValue>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::bitcoin::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::bitcoin::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::error::PsbtError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::PsbtError::InvalidMagic;
            }
            1 => {
                return crate::api::error::PsbtError::MissingUtxo;
            }
            2 => {
                return crate::api::error::PsbtError::InvalidSeparator;
            }
            3 => {
                return crate::api::error::PsbtError::PsbtUtxoOutOfBounds;
            }
            4 => {
                let mut var_key = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidKey { key: var_key };
            }
            5 => {
                return crate::api::error::PsbtError::InvalidProprietaryKey;
            }
            6 => {
                let mut var_key = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::DuplicateKey { key: var_key };
            }
            7 => {
                return crate::api::error::PsbtError::UnsignedTxHasScriptSigs;
            }
            8 => {
                return crate::api::error::PsbtError::UnsignedTxHasScriptWitnesses;
            }
            9 => {
                return crate::api::error::PsbtError::MustHaveUnsignedTx;
            }
            10 => {
                return crate::api::error::PsbtError::NoMorePairs;
            }
            11 => {
                return crate::api::error::PsbtError::UnexpectedUnsignedTx;
            }
            12 => {
                let mut var_sighash = <u32>::sse_decode(deserializer);
                return crate::api::error::PsbtError::NonStandardSighashType {
                    sighash: var_sighash,
                };
            }
            13 => {
                let mut var_hash = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidHash { hash: var_hash };
            }
            14 => {
                return crate::api::error::PsbtError::InvalidPreimageHashPair;
            }
            15 => {
                let mut var_xpub = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::CombineInconsistentKeySources {
                    xpub: var_xpub,
                };
            }
            16 => {
                let mut var_encodingError = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::ConsensusEncoding {
                    encoding_error: var_encodingError,
                };
            }
            17 => {
                return crate::api::error::PsbtError::NegativeFee;
            }
            18 => {
                return crate::api::error::PsbtError::FeeOverflow;
            }
            19 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidPublicKey {
                    error_message: var_errorMessage,
                };
            }
            20 => {
                let mut var_secp256K1Error = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidSecp256k1PublicKey {
                    secp256k1_error: var_secp256K1Error,
                };
            }
            21 => {
                return crate::api::error::PsbtError::InvalidXOnlyPublicKey;
            }
            22 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidEcdsaSignature {
                    error_message: var_errorMessage,
                };
            }
            23 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::InvalidTaprootSignature {
                    error_message: var_errorMessage,
                };
            }
            24 => {
                return crate::api::error::PsbtError::InvalidControlBlock;
            }
            25 => {
                return crate::api::error::PsbtError::InvalidLeafVersion;
            }
            26 => {
                return crate::api::error::PsbtError::Taproot;
            }
            27 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::TapTree {
                    error_message: var_errorMessage,
                };
            }
            28 => {
                return crate::api::error::PsbtError::XPubKey;
            }
            29 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::Version {
                    error_message: var_errorMessage,
                };
            }
            30 => {
                return crate::api::error::PsbtError::PartialDataConsumption;
            }
            31 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtError::Io {
                    error_message: var_errorMessage,
                };
            }
            32 => {
                return crate::api::error::PsbtError::OtherPsbtErr;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::PsbtParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtParseError::PsbtEncoding {
                    error_message: var_errorMessage,
                };
            }
            1 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::PsbtParseError::Base64Encoding {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::RbfValue::RbfDefault;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::RbfValue::Value(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for (crate::api::bitcoin::FfiScriptBuf, u64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::bitcoin::FfiScriptBuf>::sse_decode(deserializer);
        let mut var_field1 = <u64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::error::RequestBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::error::RequestBuilderError::RequestAlreadyConsumed,
            _ => unreachable!("Invalid variant for RequestBuilderError: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustWitnessUtxo = <bool>::sse_decode(deserializer);
        let mut var_assumeHeight = <Option<u32>>::sse_decode(deserializer);
        let mut var_allowAllSighashes = <bool>::sse_decode(deserializer);
        let mut var_tryFinalize = <bool>::sse_decode(deserializer);
        let mut var_signWithTapInternalKey = <bool>::sse_decode(deserializer);
        let mut var_allowGrinding = <bool>::sse_decode(deserializer);
        return crate::api::types::SignOptions {
            trust_witness_utxo: var_trustWitnessUtxo,
            assume_height: var_assumeHeight,
            allow_all_sighashes: var_allowAllSighashes,
            try_finalize: var_tryFinalize,
            sign_with_tap_internal_key: var_signWithTapInternalKey,
            allow_grinding: var_allowGrinding,
        };
    }
}

impl SseDecode for crate::api::error::SignerError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::SignerError::MissingKey;
            }
            1 => {
                return crate::api::error::SignerError::InvalidKey;
            }
            2 => {
                return crate::api::error::SignerError::UserCanceled;
            }
            3 => {
                return crate::api::error::SignerError::InputIndexOutOfRange;
            }
            4 => {
                return crate::api::error::SignerError::MissingNonWitnessUtxo;
            }
            5 => {
                return crate::api::error::SignerError::InvalidNonWitnessUtxo;
            }
            6 => {
                return crate::api::error::SignerError::MissingWitnessUtxo;
            }
            7 => {
                return crate::api::error::SignerError::MissingWitnessScript;
            }
            8 => {
                return crate::api::error::SignerError::MissingHdKeypath;
            }
            9 => {
                return crate::api::error::SignerError::NonStandardSighash;
            }
            10 => {
                return crate::api::error::SignerError::InvalidSighash;
            }
            11 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::SighashP2wpkh {
                    error_message: var_errorMessage,
                };
            }
            12 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::SighashTaproot {
                    error_message: var_errorMessage,
                };
            }
            13 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::TxInputsIndexError {
                    error_message: var_errorMessage,
                };
            }
            14 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::MiniscriptPsbt {
                    error_message: var_errorMessage,
                };
            }
            15 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::External {
                    error_message: var_errorMessage,
                };
            }
            16 => {
                let mut var_errorMessage = <String>::sse_decode(deserializer);
                return crate::api::error::SignerError::Psbt {
                    error_message: var_errorMessage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::SqliteError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_rusqliteError = <String>::sse_decode(deserializer);
                return crate::api::error::SqliteError::Sqlite {
                    rusqlite_error: var_rusqliteError,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::SyncProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_spksConsumed = <u64>::sse_decode(deserializer);
        let mut var_spksRemaining = <u64>::sse_decode(deserializer);
        let mut var_txidsConsumed = <u64>::sse_decode(deserializer);
        let mut var_txidsRemaining = <u64>::sse_decode(deserializer);
        let mut var_outpointsConsumed = <u64>::sse_decode(deserializer);
        let mut var_outpointsRemaining = <u64>::sse_decode(deserializer);
        return crate::api::types::SyncProgress {
            spks_consumed: var_spksConsumed,
            spks_remaining: var_spksRemaining,
            txids_consumed: var_txidsConsumed,
            txids_remaining: var_txidsRemaining,
            outpoints_consumed: var_outpointsConsumed,
            outpoints_remaining: var_outpointsRemaining,
        };
    }
}

impl SseDecode for crate::api::error::TransactionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::TransactionError::Io;
            }
            1 => {
                return crate::api::error::TransactionError::OversizedVectorAllocation;
            }
            2 => {
                let mut var_expected = <String>::sse_decode(deserializer);
                let mut var_actual = <String>::sse_decode(deserializer);
                return crate::api::error::TransactionError::InvalidChecksum {
                    expected: var_expected,
                    actual: var_actual,
                };
            }
            3 => {
                return crate::api::error::TransactionError::NonMinimalVarInt;
            }
            4 => {
                return crate::api::error::TransactionError::ParseFailed;
            }
            5 => {
                let mut var_flag = <u8>::sse_decode(deserializer);
                return crate::api::error::TransactionError::UnsupportedSegwitFlag {
                    flag: var_flag,
                };
            }
            6 => {
                return crate::api::error::TransactionError::OtherTransactionErr;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::bitcoin::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <crate::api::bitcoin::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <crate::api::bitcoin::FfiScriptBuf>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return crate::api::bitcoin::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for crate::api::bitcoin::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <crate::api::bitcoin::FfiScriptBuf>::sse_decode(deserializer);
        return crate::api::bitcoin::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for crate::api::error::TxidParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_txid = <String>::sse_decode(deserializer);
                return crate::api::error::TxidParseError::InvalidTxid { txid: var_txid };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::WordCount::Words12,
            1 => crate::api::types::WordCount::Words18,
            2 => crate::api::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::AddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::AddressInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::AddressInfo>
    for crate::api::types::AddressInfo
{
    fn into_into_dart(self) -> crate::api::types::AddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::AddressParseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::AddressParseError::Base58 => [0.into_dart()].into_dart(),
            crate::api::error::AddressParseError::Bech32 => [1.into_dart()].into_dart(),
            crate::api::error::AddressParseError::WitnessVersion { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressParseError::WitnessProgram { error_message } => {
                [3.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressParseError::UnknownHrp => [4.into_dart()].into_dart(),
            crate::api::error::AddressParseError::LegacyAddressTooLong => {
                [5.into_dart()].into_dart()
            }
            crate::api::error::AddressParseError::InvalidBase58PayloadLength => {
                [6.into_dart()].into_dart()
            }
            crate::api::error::AddressParseError::InvalidLegacyPrefix => {
                [7.into_dart()].into_dart()
            }
            crate::api::error::AddressParseError::NetworkValidation => [8.into_dart()].into_dart(),
            crate::api::error::AddressParseError::OtherAddressParseErr => {
                [9.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::AddressParseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::AddressParseError>
    for crate::api::error::AddressParseError
{
    fn into_into_dart(self) -> crate::api::error::AddressParseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.immature.into_into_dart().into_dart(),
            self.trusted_pending.into_into_dart().into_dart(),
            self.untrusted_pending.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Balance> for crate::api::types::Balance {
    fn into_into_dart(self) -> crate::api::types::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::Bip32Error {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::Bip32Error::CannotDeriveFromHardenedKey => {
                [0.into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::Secp256k1 { error_message } => {
                [1.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::InvalidChildNumber { child_number } => {
                [2.into_dart(), child_number.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::InvalidChildNumberFormat => [3.into_dart()].into_dart(),
            crate::api::error::Bip32Error::InvalidDerivationPathFormat => {
                [4.into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::UnknownVersion { version } => {
                [5.into_dart(), version.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::WrongExtendedKeyLength { length } => {
                [6.into_dart(), length.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::Base58 { error_message } => {
                [7.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::Hex { error_message } => {
                [8.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::InvalidPublicKeyHexLength { length } => {
                [9.into_dart(), length.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip32Error::UnknownError { error_message } => {
                [10.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::Bip32Error {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::Bip32Error>
    for crate::api::error::Bip32Error
{
    fn into_into_dart(self) -> crate::api::error::Bip32Error {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::Bip39Error {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::Bip39Error::BadWordCount { word_count } => {
                [0.into_dart(), word_count.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip39Error::UnknownWord { index } => {
                [1.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip39Error::BadEntropyBitCount { bit_count } => {
                [2.into_dart(), bit_count.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip39Error::InvalidChecksum => [3.into_dart()].into_dart(),
            crate::api::error::Bip39Error::AmbiguousLanguages { languages } => {
                [4.into_dart(), languages.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::Bip39Error::Generic { error_message } => {
                [5.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::Bip39Error {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::Bip39Error>
    for crate::api::error::Bip39Error
{
    fn into_into_dart(self) -> crate::api::error::Bip39Error {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BlockId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BlockId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BlockId> for crate::api::types::BlockId {
    fn into_into_dart(self) -> crate::api::types::BlockId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::CalculateFeeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::CalculateFeeError::Generic { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CalculateFeeError::MissingTxOut { out_points } => {
                [1.into_dart(), out_points.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CalculateFeeError::NegativeFee { amount } => {
                [2.into_dart(), amount.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::CalculateFeeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::CalculateFeeError>
    for crate::api::error::CalculateFeeError
{
    fn into_into_dart(self) -> crate::api::error::CalculateFeeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::CannotConnectError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::CannotConnectError::Include { height } => {
                [0.into_dart(), height.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::CannotConnectError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::CannotConnectError>
    for crate::api::error::CannotConnectError
{
    fn into_into_dart(self) -> crate::api::error::CannotConnectError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainPosition {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ChainPosition::Confirmed {
                confirmation_block_time,
            } => [
                0.into_dart(),
                confirmation_block_time.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::ChainPosition::Unconfirmed { timestamp } => {
                [1.into_dart(), timestamp.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainPosition
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainPosition>
    for crate::api::types::ChainPosition
{
    fn into_into_dart(self) -> crate::api::types::ChainPosition {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChangeSpendPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ChangeAllowed => 0.into_dart(),
            Self::OnlyChange => 1.into_dart(),
            Self::ChangeForbidden => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChangeSpendPolicy
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChangeSpendPolicy>
    for crate::api::types::ChangeSpendPolicy
{
    fn into_into_dart(self) -> crate::api::types::ChangeSpendPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ConfirmationBlockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_id.into_into_dart().into_dart(),
            self.confirmation_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ConfirmationBlockTime
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ConfirmationBlockTime>
    for crate::api::types::ConfirmationBlockTime
{
    fn into_into_dart(self) -> crate::api::types::ConfirmationBlockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::CreateTxError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::CreateTxError::TransactionNotFound { txid } => {
                [0.into_dart(), txid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::TransactionConfirmed { txid } => {
                [1.into_dart(), txid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::IrreplaceableTransaction { txid } => {
                [2.into_dart(), txid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::FeeRateUnavailable => [3.into_dart()].into_dart(),
            crate::api::error::CreateTxError::Generic { error_message } => {
                [4.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::Descriptor { error_message } => {
                [5.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::Policy { error_message } => {
                [6.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::SpendingPolicyRequired { kind } => {
                [7.into_dart(), kind.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::Version0 => [8.into_dart()].into_dart(),
            crate::api::error::CreateTxError::Version1Csv => [9.into_dart()].into_dart(),
            crate::api::error::CreateTxError::LockTime {
                requested_time,
                required_time,
            } => [
                10.into_dart(),
                requested_time.into_into_dart().into_dart(),
                required_time.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::CreateTxError::RbfSequence => [11.into_dart()].into_dart(),
            crate::api::error::CreateTxError::RbfSequenceCsv { rbf, csv } => [
                12.into_dart(),
                rbf.into_into_dart().into_dart(),
                csv.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::CreateTxError::FeeTooLow { fee_required } => {
                [13.into_dart(), fee_required.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::FeeRateTooLow { fee_rate_required } => [
                14.into_dart(),
                fee_rate_required.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::CreateTxError::NoUtxosSelected => [15.into_dart()].into_dart(),
            crate::api::error::CreateTxError::OutputBelowDustLimit { index } => {
                [16.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::ChangePolicyDescriptor => {
                [17.into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::CoinSelection { error_message } => {
                [18.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::InsufficientFunds { needed, available } => [
                19.into_dart(),
                needed.into_into_dart().into_dart(),
                available.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::CreateTxError::NoRecipients => [20.into_dart()].into_dart(),
            crate::api::error::CreateTxError::Psbt { error_message } => {
                [21.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::MissingKeyOrigin { key } => {
                [22.into_dart(), key.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::UnknownUtxo { outpoint } => {
                [23.into_dart(), outpoint.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::MissingNonWitnessUtxo { outpoint } => {
                [24.into_dart(), outpoint.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateTxError::MiniscriptPsbt { error_message } => {
                [25.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::CreateTxError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::CreateTxError>
    for crate::api::error::CreateTxError
{
    fn into_into_dart(self) -> crate::api::error::CreateTxError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::CreateWithPersistError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::CreateWithPersistError::Persist { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::CreateWithPersistError::DataAlreadyExists => {
                [1.into_dart()].into_dart()
            }
            crate::api::error::CreateWithPersistError::Descriptor { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::CreateWithPersistError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::CreateWithPersistError>
    for crate::api::error::CreateWithPersistError
{
    fn into_into_dart(self) -> crate::api::error::CreateWithPersistError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::DescriptorError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::DescriptorError::InvalidHdKeyPath => [0.into_dart()].into_dart(),
            crate::api::error::DescriptorError::MissingPrivateData => [1.into_dart()].into_dart(),
            crate::api::error::DescriptorError::InvalidDescriptorChecksum => {
                [2.into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::HardenedDerivationXpub => {
                [3.into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::MultiPath => [4.into_dart()].into_dart(),
            crate::api::error::DescriptorError::Key { error_message } => {
                [5.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Generic { error_message } => {
                [6.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Policy { error_message } => {
                [7.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::InvalidDescriptorCharacter { charector } => {
                [8.into_dart(), charector.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Bip32 { error_message } => {
                [9.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Base58 { error_message } => {
                [10.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Pk { error_message } => {
                [11.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Miniscript { error_message } => {
                [12.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Hex { error_message } => {
                [13.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::ExternalAndInternalAreTheSame => {
                [14.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::DescriptorError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::DescriptorError>
    for crate::api::error::DescriptorError
{
    fn into_into_dart(self) -> crate::api::error::DescriptorError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::DescriptorKeyError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::DescriptorKeyError::Parse { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorKeyError::InvalidKeyType => [1.into_dart()].into_dart(),
            crate::api::error::DescriptorKeyError::Bip32 { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::DescriptorKeyError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::DescriptorKeyError>
    for crate::api::error::DescriptorKeyError
{
    fn into_into_dart(self) -> crate::api::error::DescriptorKeyError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::ElectrumError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::ElectrumError::IOError { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::Json { error_message } => {
                [1.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::Hex { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::Protocol { error_message } => {
                [3.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::Bitcoin { error_message } => {
                [4.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::AlreadySubscribed => [5.into_dart()].into_dart(),
            crate::api::error::ElectrumError::NotSubscribed => [6.into_dart()].into_dart(),
            crate::api::error::ElectrumError::InvalidResponse { error_message } => {
                [7.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::Message { error_message } => {
                [8.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::InvalidDNSNameError { domain } => {
                [9.into_dart(), domain.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::MissingDomain => [10.into_dart()].into_dart(),
            crate::api::error::ElectrumError::AllAttemptsErrored => [11.into_dart()].into_dart(),
            crate::api::error::ElectrumError::SharedIOError { error_message } => {
                [12.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::CouldntLockReader => [13.into_dart()].into_dart(),
            crate::api::error::ElectrumError::Mpsc => [14.into_dart()].into_dart(),
            crate::api::error::ElectrumError::CouldNotCreateConnection { error_message } => {
                [15.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ElectrumError::RequestAlreadyConsumed => {
                [16.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::ElectrumError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::ElectrumError>
    for crate::api::error::ElectrumError
{
    fn into_into_dart(self) -> crate::api::error::ElectrumError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::EsploraError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::EsploraError::Minreq { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::HttpResponse {
                status,
                error_message,
            } => [
                1.into_dart(),
                status.into_into_dart().into_dart(),
                error_message.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::EsploraError::Parsing { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::StatusCode { error_message } => {
                [3.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::BitcoinEncoding { error_message } => {
                [4.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::HexToArray { error_message } => {
                [5.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::HexToBytes { error_message } => {
                [6.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::TransactionNotFound => [7.into_dart()].into_dart(),
            crate::api::error::EsploraError::HeaderHeightNotFound { height } => {
                [8.into_dart(), height.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::HeaderHashNotFound => [9.into_dart()].into_dart(),
            crate::api::error::EsploraError::InvalidHttpHeaderName { name } => {
                [10.into_dart(), name.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::InvalidHttpHeaderValue { value } => {
                [11.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::EsploraError::RequestAlreadyConsumed => [12.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::EsploraError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::EsploraError>
    for crate::api::error::EsploraError
{
    fn into_into_dart(self) -> crate::api::error::EsploraError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::ExtractTxError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::ExtractTxError::AbsurdFeeRate { fee_rate } => {
                [0.into_dart(), fee_rate.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ExtractTxError::MissingInputValue => [1.into_dart()].into_dart(),
            crate::api::error::ExtractTxError::SendingTooMuch => [2.into_dart()].into_dart(),
            crate::api::error::ExtractTxError::OtherExtractTxErr => [3.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::ExtractTxError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::ExtractTxError>
    for crate::api::error::ExtractTxError
{
    fn into_into_dart(self) -> crate::api::error::ExtractTxError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::FeeRate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.sat_kwu.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bitcoin::FeeRate {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::FeeRate>
    for crate::api::bitcoin::FeeRate
{
    fn into_into_dart(self) -> crate::api::bitcoin::FeeRate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::FfiAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bitcoin::FfiAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::FfiAddress>
    for crate::api::bitcoin::FfiAddress
{
    fn into_into_dart(self) -> crate::api::bitcoin::FfiAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiCanonicalTx {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transaction.into_into_dart().into_dart(),
            self.chain_position.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::FfiCanonicalTx
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiCanonicalTx>
    for crate::api::types::FfiCanonicalTx
{
    fn into_into_dart(self) -> crate::api::types::FfiCanonicalTx {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::store::FfiConnection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::store::FfiConnection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::store::FfiConnection>
    for crate::api::store::FfiConnection
{
    fn into_into_dart(self) -> crate::api::store::FfiConnection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::FfiDerivationPath {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::FfiDerivationPath
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::FfiDerivationPath>
    for crate::api::key::FfiDerivationPath
{
    fn into_into_dart(self) -> crate::api::key::FfiDerivationPath {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::descriptor::FfiDescriptor {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.extended_descriptor.into_into_dart().into_dart(),
            self.key_map.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::descriptor::FfiDescriptor
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::descriptor::FfiDescriptor>
    for crate::api::descriptor::FfiDescriptor
{
    fn into_into_dart(self) -> crate::api::descriptor::FfiDescriptor {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::FfiDescriptorPublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::FfiDescriptorPublicKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::FfiDescriptorPublicKey>
    for crate::api::key::FfiDescriptorPublicKey
{
    fn into_into_dart(self) -> crate::api::key::FfiDescriptorPublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::FfiDescriptorSecretKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::FfiDescriptorSecretKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::FfiDescriptorSecretKey>
    for crate::api::key::FfiDescriptorSecretKey
{
    fn into_into_dart(self) -> crate::api::key::FfiDescriptorSecretKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::electrum::FfiElectrumClient {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::electrum::FfiElectrumClient
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::electrum::FfiElectrumClient>
    for crate::api::electrum::FfiElectrumClient
{
    fn into_into_dart(self) -> crate::api::electrum::FfiElectrumClient {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::esplora::FfiEsploraClient {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::esplora::FfiEsploraClient
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::esplora::FfiEsploraClient>
    for crate::api::esplora::FfiEsploraClient
{
    fn into_into_dart(self) -> crate::api::esplora::FfiEsploraClient {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiFullScanRequest {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::FfiFullScanRequest
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiFullScanRequest>
    for crate::api::types::FfiFullScanRequest
{
    fn into_into_dart(self) -> crate::api::types::FfiFullScanRequest {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiFullScanRequestBuilder {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::FfiFullScanRequestBuilder
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiFullScanRequestBuilder>
    for crate::api::types::FfiFullScanRequestBuilder
{
    fn into_into_dart(self) -> crate::api::types::FfiFullScanRequestBuilder {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::FfiMnemonic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::key::FfiMnemonic {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::FfiMnemonic>
    for crate::api::key::FfiMnemonic
{
    fn into_into_dart(self) -> crate::api::key::FfiMnemonic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::FfiPsbt {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bitcoin::FfiPsbt {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::FfiPsbt>
    for crate::api::bitcoin::FfiPsbt
{
    fn into_into_dart(self) -> crate::api::bitcoin::FfiPsbt {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::FfiScriptBuf {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.bytes.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bitcoin::FfiScriptBuf
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::FfiScriptBuf>
    for crate::api::bitcoin::FfiScriptBuf
{
    fn into_into_dart(self) -> crate::api::bitcoin::FfiScriptBuf {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiSyncRequest {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::FfiSyncRequest
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiSyncRequest>
    for crate::api::types::FfiSyncRequest
{
    fn into_into_dart(self) -> crate::api::types::FfiSyncRequest {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiSyncRequestBuilder {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::FfiSyncRequestBuilder
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiSyncRequestBuilder>
    for crate::api::types::FfiSyncRequestBuilder
{
    fn into_into_dart(self) -> crate::api::types::FfiSyncRequestBuilder {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::FfiTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bitcoin::FfiTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::FfiTransaction>
    for crate::api::bitcoin::FfiTransaction
{
    fn into_into_dart(self) -> crate::api::bitcoin::FfiTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FfiUpdate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::FfiUpdate {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FfiUpdate>
    for crate::api::types::FfiUpdate
{
    fn into_into_dart(self) -> crate::api::types::FfiUpdate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::FfiWallet {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::wallet::FfiWallet {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::FfiWallet>
    for crate::api::wallet::FfiWallet
{
    fn into_into_dart(self) -> crate::api::wallet::FfiWallet {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::FromScriptError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::FromScriptError::UnrecognizedScript => [0.into_dart()].into_dart(),
            crate::api::error::FromScriptError::WitnessProgram { error_message } => {
                [1.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::FromScriptError::WitnessVersion { error_message } => {
                [2.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::FromScriptError::OtherFromScriptErr => [3.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::FromScriptError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::FromScriptError>
    for crate::api::error::FromScriptError
{
    fn into_into_dart(self) -> crate::api::error::FromScriptError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::KeychainKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ExternalChain => 0.into_dart(),
            Self::InternalChain => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::KeychainKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::KeychainKind>
    for crate::api::types::KeychainKind
{
    fn into_into_dart(self) -> crate::api::types::KeychainKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::LoadWithPersistError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::LoadWithPersistError::Persist { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::LoadWithPersistError::InvalidChangeSet { error_message } => {
                [1.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::LoadWithPersistError::CouldNotLoad => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::LoadWithPersistError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::LoadWithPersistError>
    for crate::api::error::LoadWithPersistError
{
    fn into_into_dart(self) -> crate::api::error::LoadWithPersistError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LocalOutput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LocalOutput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LocalOutput>
    for crate::api::types::LocalOutput
{
    fn into_into_dart(self) -> crate::api::types::LocalOutput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::LockTime::Blocks(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::LockTime::Seconds(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LockTime {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LockTime>
    for crate::api::types::LockTime
{
    fn into_into_dart(self) -> crate::api::types::LockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Testnet => 0.into_dart(),
            Self::Regtest => 1.into_dart(),
            Self::Bitcoin => 2.into_dart(),
            Self::Signet => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bitcoin::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::OutPoint>
    for crate::api::bitcoin::OutPoint
{
    fn into_into_dart(self) -> crate::api::bitcoin::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::PsbtError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::PsbtError::InvalidMagic => [0.into_dart()].into_dart(),
            crate::api::error::PsbtError::MissingUtxo => [1.into_dart()].into_dart(),
            crate::api::error::PsbtError::InvalidSeparator => [2.into_dart()].into_dart(),
            crate::api::error::PsbtError::PsbtUtxoOutOfBounds => [3.into_dart()].into_dart(),
            crate::api::error::PsbtError::InvalidKey { key } => {
                [4.into_dart(), key.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidProprietaryKey => [5.into_dart()].into_dart(),
            crate::api::error::PsbtError::DuplicateKey { key } => {
                [6.into_dart(), key.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::UnsignedTxHasScriptSigs => [7.into_dart()].into_dart(),
            crate::api::error::PsbtError::UnsignedTxHasScriptWitnesses => {
                [8.into_dart()].into_dart()
            }
            crate::api::error::PsbtError::MustHaveUnsignedTx => [9.into_dart()].into_dart(),
            crate::api::error::PsbtError::NoMorePairs => [10.into_dart()].into_dart(),
            crate::api::error::PsbtError::UnexpectedUnsignedTx => [11.into_dart()].into_dart(),
            crate::api::error::PsbtError::NonStandardSighashType { sighash } => {
                [12.into_dart(), sighash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidHash { hash } => {
                [13.into_dart(), hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidPreimageHashPair => [14.into_dart()].into_dart(),
            crate::api::error::PsbtError::CombineInconsistentKeySources { xpub } => {
                [15.into_dart(), xpub.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::ConsensusEncoding { encoding_error } => {
                [16.into_dart(), encoding_error.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::NegativeFee => [17.into_dart()].into_dart(),
            crate::api::error::PsbtError::FeeOverflow => [18.into_dart()].into_dart(),
            crate::api::error::PsbtError::InvalidPublicKey { error_message } => {
                [19.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidSecp256k1PublicKey { secp256k1_error } => {
                [20.into_dart(), secp256k1_error.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidXOnlyPublicKey => [21.into_dart()].into_dart(),
            crate::api::error::PsbtError::InvalidEcdsaSignature { error_message } => {
                [22.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidTaprootSignature { error_message } => {
                [23.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::InvalidControlBlock => [24.into_dart()].into_dart(),
            crate::api::error::PsbtError::InvalidLeafVersion => [25.into_dart()].into_dart(),
            crate::api::error::PsbtError::Taproot => [26.into_dart()].into_dart(),
            crate::api::error::PsbtError::TapTree { error_message } => {
                [27.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::XPubKey => [28.into_dart()].into_dart(),
            crate::api::error::PsbtError::Version { error_message } => {
                [29.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::PartialDataConsumption => [30.into_dart()].into_dart(),
            crate::api::error::PsbtError::Io { error_message } => {
                [31.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtError::OtherPsbtErr => [32.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::PsbtError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::PsbtError>
    for crate::api::error::PsbtError
{
    fn into_into_dart(self) -> crate::api::error::PsbtError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::PsbtParseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::PsbtParseError::PsbtEncoding { error_message } => {
                [0.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::PsbtParseError::Base64Encoding { error_message } => {
                [1.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::PsbtParseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::PsbtParseError>
    for crate::api::error::PsbtParseError
{
    fn into_into_dart(self) -> crate::api::error::PsbtParseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::RbfValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::RbfValue::RbfDefault => [0.into_dart()].into_dart(),
            crate::api::types::RbfValue::Value(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::RbfValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::RbfValue>
    for crate::api::types::RbfValue
{
    fn into_into_dart(self) -> crate::api::types::RbfValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::RequestBuilderError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::RequestAlreadyConsumed => 0.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::RequestBuilderError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::RequestBuilderError>
    for crate::api::error::RequestBuilderError
{
    fn into_into_dart(self) -> crate::api::error::RequestBuilderError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SignOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.trust_witness_utxo.into_into_dart().into_dart(),
            self.assume_height.into_into_dart().into_dart(),
            self.allow_all_sighashes.into_into_dart().into_dart(),
            self.try_finalize.into_into_dart().into_dart(),
            self.sign_with_tap_internal_key.into_into_dart().into_dart(),
            self.allow_grinding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SignOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SignOptions>
    for crate::api::types::SignOptions
{
    fn into_into_dart(self) -> crate::api::types::SignOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::SignerError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::SignerError::MissingKey => [0.into_dart()].into_dart(),
            crate::api::error::SignerError::InvalidKey => [1.into_dart()].into_dart(),
            crate::api::error::SignerError::UserCanceled => [2.into_dart()].into_dart(),
            crate::api::error::SignerError::InputIndexOutOfRange => [3.into_dart()].into_dart(),
            crate::api::error::SignerError::MissingNonWitnessUtxo => [4.into_dart()].into_dart(),
            crate::api::error::SignerError::InvalidNonWitnessUtxo => [5.into_dart()].into_dart(),
            crate::api::error::SignerError::MissingWitnessUtxo => [6.into_dart()].into_dart(),
            crate::api::error::SignerError::MissingWitnessScript => [7.into_dart()].into_dart(),
            crate::api::error::SignerError::MissingHdKeypath => [8.into_dart()].into_dart(),
            crate::api::error::SignerError::NonStandardSighash => [9.into_dart()].into_dart(),
            crate::api::error::SignerError::InvalidSighash => [10.into_dart()].into_dart(),
            crate::api::error::SignerError::SighashP2wpkh { error_message } => {
                [11.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::SignerError::SighashTaproot { error_message } => {
                [12.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::SignerError::TxInputsIndexError { error_message } => {
                [13.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::SignerError::MiniscriptPsbt { error_message } => {
                [14.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::SignerError::External { error_message } => {
                [15.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::SignerError::Psbt { error_message } => {
                [16.into_dart(), error_message.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::SignerError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::SignerError>
    for crate::api::error::SignerError
{
    fn into_into_dart(self) -> crate::api::error::SignerError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::SqliteError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::SqliteError::Sqlite { rusqlite_error } => {
                [0.into_dart(), rusqlite_error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::SqliteError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::SqliteError>
    for crate::api::error::SqliteError
{
    fn into_into_dart(self) -> crate::api::error::SqliteError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SyncProgress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.spks_consumed.into_into_dart().into_dart(),
            self.spks_remaining.into_into_dart().into_dart(),
            self.txids_consumed.into_into_dart().into_dart(),
            self.txids_remaining.into_into_dart().into_dart(),
            self.outpoints_consumed.into_into_dart().into_dart(),
            self.outpoints_remaining.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SyncProgress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SyncProgress>
    for crate::api::types::SyncProgress
{
    fn into_into_dart(self) -> crate::api::types::SyncProgress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::TransactionError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::TransactionError::Io => [0.into_dart()].into_dart(),
            crate::api::error::TransactionError::OversizedVectorAllocation => {
                [1.into_dart()].into_dart()
            }
            crate::api::error::TransactionError::InvalidChecksum { expected, actual } => [
                2.into_dart(),
                expected.into_into_dart().into_dart(),
                actual.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::TransactionError::NonMinimalVarInt => [3.into_dart()].into_dart(),
            crate::api::error::TransactionError::ParseFailed => [4.into_dart()].into_dart(),
            crate::api::error::TransactionError::UnsupportedSegwitFlag { flag } => {
                [5.into_dart(), flag.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::TransactionError::OtherTransactionErr => [6.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::TransactionError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::TransactionError>
    for crate::api::error::TransactionError
{
    fn into_into_dart(self) -> crate::api::error::TransactionError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::TxIn {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.previous_output.into_into_dart().into_dart(),
            self.script_sig.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bitcoin::TxIn {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::TxIn> for crate::api::bitcoin::TxIn {
    fn into_into_dart(self) -> crate::api::bitcoin::TxIn {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bitcoin::TxOut {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bitcoin::TxOut {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bitcoin::TxOut> for crate::api::bitcoin::TxOut {
    fn into_into_dart(self) -> crate::api::bitcoin::TxOut {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::TxidParseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::TxidParseError::InvalidTxid { txid } => {
                [0.into_dart(), txid.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::TxidParseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::TxidParseError>
    for crate::api::error::TxidParseError
{
    fn into_into_dart(self) -> crate::api::error::TxidParseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::WordCount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Words12 => 0.into_dart(),
            Self::Words18 => 1.into_dart(),
            Self::Words24 => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::WordCount {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::WordCount>
    for crate::api::types::WordCount
{
    fn into_into_dart(self) -> crate::api::types::WordCount {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.encode(), serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_core::bitcoin::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_core::bitcoin::Transaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::Update> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::keys::KeyMap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        std::sync::Mutex<Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        std::sync::Mutex<
            Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.index, serializer);
        <crate::api::bitcoin::FfiAddress>::sse_encode(self.address, serializer);
        <crate::api::types::KeychainKind>::sse_encode(self.keychain, serializer);
    }
}

impl SseEncode for crate::api::error::AddressParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::AddressParseError::Base58 => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::AddressParseError::Bech32 => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::AddressParseError::WitnessVersion { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::AddressParseError::WitnessProgram { error_message } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::AddressParseError::UnknownHrp => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::error::AddressParseError::LegacyAddressTooLong => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::error::AddressParseError::InvalidBase58PayloadLength => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::error::AddressParseError::InvalidLegacyPrefix => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::error::AddressParseError::NetworkValidation => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::error::AddressParseError::OtherAddressParseErr => {
                <i32>::sse_encode(9, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.immature, serializer);
        <u64>::sse_encode(self.trusted_pending, serializer);
        <u64>::sse_encode(self.untrusted_pending, serializer);
        <u64>::sse_encode(self.confirmed, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.total, serializer);
    }
}

impl SseEncode for crate::api::error::Bip32Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::Bip32Error::CannotDeriveFromHardenedKey => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::Bip32Error::Secp256k1 { error_message } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::Bip32Error::InvalidChildNumber { child_number } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(child_number, serializer);
            }
            crate::api::error::Bip32Error::InvalidChildNumberFormat => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::Bip32Error::InvalidDerivationPathFormat => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::error::Bip32Error::UnknownVersion { version } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(version, serializer);
            }
            crate::api::error::Bip32Error::WrongExtendedKeyLength { length } => {
                <i32>::sse_encode(6, serializer);
                <u32>::sse_encode(length, serializer);
            }
            crate::api::error::Bip32Error::Base58 { error_message } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::Bip32Error::Hex { error_message } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::Bip32Error::InvalidPublicKeyHexLength { length } => {
                <i32>::sse_encode(9, serializer);
                <u32>::sse_encode(length, serializer);
            }
            crate::api::error::Bip32Error::UnknownError { error_message } => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::Bip39Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::Bip39Error::BadWordCount { word_count } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(word_count, serializer);
            }
            crate::api::error::Bip39Error::UnknownWord { index } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(index, serializer);
            }
            crate::api::error::Bip39Error::BadEntropyBitCount { bit_count } => {
                <i32>::sse_encode(2, serializer);
                <u64>::sse_encode(bit_count, serializer);
            }
            crate::api::error::Bip39Error::InvalidChecksum => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::Bip39Error::AmbiguousLanguages { languages } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(languages, serializer);
            }
            crate::api::error::Bip39Error::Generic { error_message } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::BlockId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::error::CalculateFeeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::CalculateFeeError::Generic { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CalculateFeeError::MissingTxOut { out_points } => {
                <i32>::sse_encode(1, serializer);
                <Vec<crate::api::bitcoin::OutPoint>>::sse_encode(out_points, serializer);
            }
            crate::api::error::CalculateFeeError::NegativeFee { amount } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(amount, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::CannotConnectError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::CannotConnectError::Include { height } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(height, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::ChainPosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ChainPosition::Confirmed {
                confirmation_block_time,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::ConfirmationBlockTime>::sse_encode(
                    confirmation_block_time,
                    serializer,
                );
            }
            crate::api::types::ChainPosition::Unconfirmed { timestamp } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(timestamp, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::ChangeSpendPolicy::ChangeAllowed => 0,
                crate::api::types::ChangeSpendPolicy::OnlyChange => 1,
                crate::api::types::ChangeSpendPolicy::ChangeForbidden => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::ConfirmationBlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::BlockId>::sse_encode(self.block_id, serializer);
        <u64>::sse_encode(self.confirmation_time, serializer);
    }
}

impl SseEncode for crate::api::error::CreateTxError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::CreateTxError::TransactionNotFound { txid } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(txid, serializer);
            }
            crate::api::error::CreateTxError::TransactionConfirmed { txid } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(txid, serializer);
            }
            crate::api::error::CreateTxError::IrreplaceableTransaction { txid } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(txid, serializer);
            }
            crate::api::error::CreateTxError::FeeRateUnavailable => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::CreateTxError::Generic { error_message } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateTxError::Descriptor { error_message } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateTxError::Policy { error_message } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateTxError::SpendingPolicyRequired { kind } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(kind, serializer);
            }
            crate::api::error::CreateTxError::Version0 => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::error::CreateTxError::Version1Csv => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::CreateTxError::LockTime {
                requested_time,
                required_time,
            } => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(requested_time, serializer);
                <String>::sse_encode(required_time, serializer);
            }
            crate::api::error::CreateTxError::RbfSequence => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::error::CreateTxError::RbfSequenceCsv { rbf, csv } => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(rbf, serializer);
                <String>::sse_encode(csv, serializer);
            }
            crate::api::error::CreateTxError::FeeTooLow { fee_required } => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(fee_required, serializer);
            }
            crate::api::error::CreateTxError::FeeRateTooLow { fee_rate_required } => {
                <i32>::sse_encode(14, serializer);
                <String>::sse_encode(fee_rate_required, serializer);
            }
            crate::api::error::CreateTxError::NoUtxosSelected => {
                <i32>::sse_encode(15, serializer);
            }
            crate::api::error::CreateTxError::OutputBelowDustLimit { index } => {
                <i32>::sse_encode(16, serializer);
                <u64>::sse_encode(index, serializer);
            }
            crate::api::error::CreateTxError::ChangePolicyDescriptor => {
                <i32>::sse_encode(17, serializer);
            }
            crate::api::error::CreateTxError::CoinSelection { error_message } => {
                <i32>::sse_encode(18, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateTxError::InsufficientFunds { needed, available } => {
                <i32>::sse_encode(19, serializer);
                <u64>::sse_encode(needed, serializer);
                <u64>::sse_encode(available, serializer);
            }
            crate::api::error::CreateTxError::NoRecipients => {
                <i32>::sse_encode(20, serializer);
            }
            crate::api::error::CreateTxError::Psbt { error_message } => {
                <i32>::sse_encode(21, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateTxError::MissingKeyOrigin { key } => {
                <i32>::sse_encode(22, serializer);
                <String>::sse_encode(key, serializer);
            }
            crate::api::error::CreateTxError::UnknownUtxo { outpoint } => {
                <i32>::sse_encode(23, serializer);
                <String>::sse_encode(outpoint, serializer);
            }
            crate::api::error::CreateTxError::MissingNonWitnessUtxo { outpoint } => {
                <i32>::sse_encode(24, serializer);
                <String>::sse_encode(outpoint, serializer);
            }
            crate::api::error::CreateTxError::MiniscriptPsbt { error_message } => {
                <i32>::sse_encode(25, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::CreateWithPersistError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::CreateWithPersistError::Persist { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::CreateWithPersistError::DataAlreadyExists => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::CreateWithPersistError::Descriptor { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::DescriptorError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::DescriptorError::InvalidHdKeyPath => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::DescriptorError::MissingPrivateData => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::DescriptorError::InvalidDescriptorChecksum => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::DescriptorError::HardenedDerivationXpub => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::DescriptorError::MultiPath => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::error::DescriptorError::Key { error_message } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Generic { error_message } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Policy { error_message } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::InvalidDescriptorCharacter { charector } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(charector, serializer);
            }
            crate::api::error::DescriptorError::Bip32 { error_message } => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Base58 { error_message } => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Pk { error_message } => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Miniscript { error_message } => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::Hex { error_message } => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorError::ExternalAndInternalAreTheSame => {
                <i32>::sse_encode(14, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::DescriptorKeyError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::DescriptorKeyError::Parse { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::DescriptorKeyError::InvalidKeyType => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::DescriptorKeyError::Bip32 { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::ElectrumError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::ElectrumError::IOError { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::Json { error_message } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::Hex { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::Protocol { error_message } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::Bitcoin { error_message } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::AlreadySubscribed => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::error::ElectrumError::NotSubscribed => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::error::ElectrumError::InvalidResponse { error_message } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::Message { error_message } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::InvalidDNSNameError { domain } => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(domain, serializer);
            }
            crate::api::error::ElectrumError::MissingDomain => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::error::ElectrumError::AllAttemptsErrored => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::error::ElectrumError::SharedIOError { error_message } => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::CouldntLockReader => {
                <i32>::sse_encode(13, serializer);
            }
            crate::api::error::ElectrumError::Mpsc => {
                <i32>::sse_encode(14, serializer);
            }
            crate::api::error::ElectrumError::CouldNotCreateConnection { error_message } => {
                <i32>::sse_encode(15, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::ElectrumError::RequestAlreadyConsumed => {
                <i32>::sse_encode(16, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::EsploraError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::EsploraError::Minreq { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::HttpResponse {
                status,
                error_message,
            } => {
                <i32>::sse_encode(1, serializer);
                <u16>::sse_encode(status, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::Parsing { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::StatusCode { error_message } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::BitcoinEncoding { error_message } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::HexToArray { error_message } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::HexToBytes { error_message } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::EsploraError::TransactionNotFound => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::error::EsploraError::HeaderHeightNotFound { height } => {
                <i32>::sse_encode(8, serializer);
                <u32>::sse_encode(height, serializer);
            }
            crate::api::error::EsploraError::HeaderHashNotFound => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::EsploraError::InvalidHttpHeaderName { name } => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(name, serializer);
            }
            crate::api::error::EsploraError::InvalidHttpHeaderValue { value } => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::api::error::EsploraError::RequestAlreadyConsumed => {
                <i32>::sse_encode(12, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::ExtractTxError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::ExtractTxError::AbsurdFeeRate { fee_rate } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(fee_rate, serializer);
            }
            crate::api::error::ExtractTxError::MissingInputValue => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::ExtractTxError::SendingTooMuch => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::ExtractTxError::OtherExtractTxErr => {
                <i32>::sse_encode(3, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::bitcoin::FeeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.sat_kwu, serializer);
    }
}

impl SseEncode for crate::api::bitcoin::FfiAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_core::bitcoin::Address>>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::FfiCanonicalTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::bitcoin::FfiTransaction>::sse_encode(self.transaction, serializer);
        <crate::api::types::ChainPosition>::sse_encode(self.chain_position, serializer);
    }
}

impl SseEncode for crate::api::store::FfiConnection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>>::sse_encode(
            self.0, serializer,
        );
    }
}

impl SseEncode for crate::api::key::FfiDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath>>::sse_encode(
            self.opaque,
            serializer,
        );
    }
}

impl SseEncode for crate::api::descriptor::FfiDescriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor>>::sse_encode(
            self.extended_descriptor,
            serializer,
        );
        <RustOpaqueNom<bdk_wallet::keys::KeyMap>>::sse_encode(self.key_map, serializer);
    }
}

impl SseEncode for crate::api::key::FfiDescriptorPublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::key::FfiDescriptorSecretKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::electrum::FfiElectrumClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_electrum :: BdkElectrumClient < bdk_electrum :: electrum_client :: Client >>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::esplora::FfiEsploraClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient>>::sse_encode(
            self.opaque,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::FfiFullScanRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        >>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::FfiFullScanRequestBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        >>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::key::FfiMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::bitcoin::FfiPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>>::sse_encode(
            self.opaque,
            serializer,
        );
    }
}

impl SseEncode for crate::api::bitcoin::FfiScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.bytes, serializer);
    }
}

impl SseEncode for crate::api::types::FfiSyncRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::FfiSyncRequestBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        >>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::bitcoin::FfiTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_core::bitcoin::Transaction>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::types::FfiUpdate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk_wallet::Update>>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::wallet::FfiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
        >>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::error::FromScriptError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::FromScriptError::UnrecognizedScript => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::FromScriptError::WitnessProgram { error_message } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::FromScriptError::WitnessVersion { error_message } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::FromScriptError::OtherFromScriptErr => {
                <i32>::sse_encode(3, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for isize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_i64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::KeychainKind::ExternalChain => 0,
                crate::api::types::KeychainKind::InternalChain => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<crate::api::types::FfiCanonicalTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::FfiCanonicalTx>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::LocalOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::LocalOutput>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bitcoin::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bitcoin::OutPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(crate::api::bitcoin::FfiScriptBuf, u64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(crate::api::bitcoin::FfiScriptBuf, u64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bitcoin::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bitcoin::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bitcoin::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bitcoin::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::error::LoadWithPersistError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::LoadWithPersistError::Persist { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::LoadWithPersistError::InvalidChangeSet { error_message } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::LoadWithPersistError::CouldNotLoad => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::LocalOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::bitcoin::OutPoint>::sse_encode(self.outpoint, serializer);
        <crate::api::bitcoin::TxOut>::sse_encode(self.txout, serializer);
        <crate::api::types::KeychainKind>::sse_encode(self.keychain, serializer);
        <bool>::sse_encode(self.is_spent, serializer);
    }
}

impl SseEncode for crate::api::types::LockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::LockTime::Blocks(field0) => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::api::types::LockTime::Seconds(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Testnet => 0,
                crate::api::types::Network::Regtest => 1,
                crate::api::types::Network::Bitcoin => 2,
                crate::api::types::Network::Signet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::bitcoin::FeeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::bitcoin::FeeRate>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::FfiCanonicalTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::FfiCanonicalTx>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::bitcoin::FfiScriptBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::bitcoin::FfiScriptBuf>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::RbfValue>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::bitcoin::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::error::PsbtError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::PsbtError::InvalidMagic => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::PsbtError::MissingUtxo => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::PsbtError::InvalidSeparator => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::PsbtError::PsbtUtxoOutOfBounds => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::PsbtError::InvalidKey { key } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(key, serializer);
            }
            crate::api::error::PsbtError::InvalidProprietaryKey => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::error::PsbtError::DuplicateKey { key } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(key, serializer);
            }
            crate::api::error::PsbtError::UnsignedTxHasScriptSigs => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::error::PsbtError::UnsignedTxHasScriptWitnesses => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::error::PsbtError::MustHaveUnsignedTx => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::PsbtError::NoMorePairs => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::error::PsbtError::UnexpectedUnsignedTx => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::error::PsbtError::NonStandardSighashType { sighash } => {
                <i32>::sse_encode(12, serializer);
                <u32>::sse_encode(sighash, serializer);
            }
            crate::api::error::PsbtError::InvalidHash { hash } => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(hash, serializer);
            }
            crate::api::error::PsbtError::InvalidPreimageHashPair => {
                <i32>::sse_encode(14, serializer);
            }
            crate::api::error::PsbtError::CombineInconsistentKeySources { xpub } => {
                <i32>::sse_encode(15, serializer);
                <String>::sse_encode(xpub, serializer);
            }
            crate::api::error::PsbtError::ConsensusEncoding { encoding_error } => {
                <i32>::sse_encode(16, serializer);
                <String>::sse_encode(encoding_error, serializer);
            }
            crate::api::error::PsbtError::NegativeFee => {
                <i32>::sse_encode(17, serializer);
            }
            crate::api::error::PsbtError::FeeOverflow => {
                <i32>::sse_encode(18, serializer);
            }
            crate::api::error::PsbtError::InvalidPublicKey { error_message } => {
                <i32>::sse_encode(19, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::InvalidSecp256k1PublicKey { secp256k1_error } => {
                <i32>::sse_encode(20, serializer);
                <String>::sse_encode(secp256k1_error, serializer);
            }
            crate::api::error::PsbtError::InvalidXOnlyPublicKey => {
                <i32>::sse_encode(21, serializer);
            }
            crate::api::error::PsbtError::InvalidEcdsaSignature { error_message } => {
                <i32>::sse_encode(22, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::InvalidTaprootSignature { error_message } => {
                <i32>::sse_encode(23, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::InvalidControlBlock => {
                <i32>::sse_encode(24, serializer);
            }
            crate::api::error::PsbtError::InvalidLeafVersion => {
                <i32>::sse_encode(25, serializer);
            }
            crate::api::error::PsbtError::Taproot => {
                <i32>::sse_encode(26, serializer);
            }
            crate::api::error::PsbtError::TapTree { error_message } => {
                <i32>::sse_encode(27, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::XPubKey => {
                <i32>::sse_encode(28, serializer);
            }
            crate::api::error::PsbtError::Version { error_message } => {
                <i32>::sse_encode(29, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::PartialDataConsumption => {
                <i32>::sse_encode(30, serializer);
            }
            crate::api::error::PsbtError::Io { error_message } => {
                <i32>::sse_encode(31, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtError::OtherPsbtErr => {
                <i32>::sse_encode(32, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::PsbtParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::PsbtParseError::PsbtEncoding { error_message } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::PsbtParseError::Base64Encoding { error_message } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::RbfValue::RbfDefault => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::RbfValue::Value(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for (crate::api::bitcoin::FfiScriptBuf, u64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::bitcoin::FfiScriptBuf>::sse_encode(self.0, serializer);
        <u64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::error::RequestBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::error::RequestBuilderError::RequestAlreadyConsumed => 0,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.trust_witness_utxo, serializer);
        <Option<u32>>::sse_encode(self.assume_height, serializer);
        <bool>::sse_encode(self.allow_all_sighashes, serializer);
        <bool>::sse_encode(self.try_finalize, serializer);
        <bool>::sse_encode(self.sign_with_tap_internal_key, serializer);
        <bool>::sse_encode(self.allow_grinding, serializer);
    }
}

impl SseEncode for crate::api::error::SignerError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::SignerError::MissingKey => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::SignerError::InvalidKey => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::SignerError::UserCanceled => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::SignerError::InputIndexOutOfRange => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::SignerError::MissingNonWitnessUtxo => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::error::SignerError::InvalidNonWitnessUtxo => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::error::SignerError::MissingWitnessUtxo => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::error::SignerError::MissingWitnessScript => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::error::SignerError::MissingHdKeypath => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::error::SignerError::NonStandardSighash => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::SignerError::InvalidSighash => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::error::SignerError::SighashP2wpkh { error_message } => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::SignerError::SighashTaproot { error_message } => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::SignerError::TxInputsIndexError { error_message } => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::SignerError::MiniscriptPsbt { error_message } => {
                <i32>::sse_encode(14, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::SignerError::External { error_message } => {
                <i32>::sse_encode(15, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            crate::api::error::SignerError::Psbt { error_message } => {
                <i32>::sse_encode(16, serializer);
                <String>::sse_encode(error_message, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::SqliteError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::SqliteError::Sqlite { rusqlite_error } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(rusqlite_error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::SyncProgress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.spks_consumed, serializer);
        <u64>::sse_encode(self.spks_remaining, serializer);
        <u64>::sse_encode(self.txids_consumed, serializer);
        <u64>::sse_encode(self.txids_remaining, serializer);
        <u64>::sse_encode(self.outpoints_consumed, serializer);
        <u64>::sse_encode(self.outpoints_remaining, serializer);
    }
}

impl SseEncode for crate::api::error::TransactionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::TransactionError::Io => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::TransactionError::OversizedVectorAllocation => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::TransactionError::InvalidChecksum { expected, actual } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(expected, serializer);
                <String>::sse_encode(actual, serializer);
            }
            crate::api::error::TransactionError::NonMinimalVarInt => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::TransactionError::ParseFailed => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::error::TransactionError::UnsupportedSegwitFlag { flag } => {
                <i32>::sse_encode(5, serializer);
                <u8>::sse_encode(flag, serializer);
            }
            crate::api::error::TransactionError::OtherTransactionErr => {
                <i32>::sse_encode(6, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::bitcoin::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::bitcoin::OutPoint>::sse_encode(self.previous_output, serializer);
        <crate::api::bitcoin::FfiScriptBuf>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for crate::api::bitcoin::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <crate::api::bitcoin::FfiScriptBuf>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for crate::api::error::TxidParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::TxidParseError::InvalidTxid { txid } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(txid, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::WordCount::Words12 => 0,
                crate::api::types::WordCount::Words18 => 1,
                crate::api::types::WordCount::Words24 => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.4.0.

    // Section: imports

    use super::*;
    use crate::api::electrum::*;
    use crate::api::esplora::*;
    use crate::api::store::*;
    use crate::api::types::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<flutter_rust_bridge::DartOpaque> for *const std::ffi::c_void {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::DartOpaque {
            unsafe { flutter_rust_bridge::for_generated::cst_decode_dart_opaque(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_core::bitcoin::Address>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_core::bitcoin::Address> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_core::bitcoin::Transaction>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_core::bitcoin::Transaction> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<bdk_electrum::BdkElectrumClient<bdk_electrum::electrum_client::Client>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_esplora::esplora_client::BlockingClient> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::Update>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::Update> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::bitcoin::bip32::DerivationPath> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::descriptor::ExtendedDescriptor> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::DescriptorPublicKey> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::DescriptorSecretKey> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::keys::KeyMap>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::KeyMap> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk_wallet::keys::bip39::Mnemonic> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
                >,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
            >,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
                >,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
            >,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                std::sync::Mutex<
                    Option<
                        bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>,
                    >,
                >,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>>,
            >,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
                >,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            std::sync::Mutex<
                Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
            >,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            std::sync::Mutex<bdk_wallet::PersistedWallet<bdk_wallet::rusqlite::Connection>>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<std::sync::Mutex<bdk_wallet::rusqlite::Connection>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::types::AddressInfo> for wire_cst_address_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::AddressInfo {
            crate::api::types::AddressInfo {
                index: self.index.cst_decode(),
                address: self.address.cst_decode(),
                keychain: self.keychain.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::AddressParseError> for wire_cst_address_parse_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::AddressParseError {
            match self.tag {
                0 => crate::api::error::AddressParseError::Base58,
                1 => crate::api::error::AddressParseError::Bech32,
                2 => {
                    let ans = unsafe { self.kind.WitnessVersion };
                    crate::api::error::AddressParseError::WitnessVersion {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.WitnessProgram };
                    crate::api::error::AddressParseError::WitnessProgram {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                4 => crate::api::error::AddressParseError::UnknownHrp,
                5 => crate::api::error::AddressParseError::LegacyAddressTooLong,
                6 => crate::api::error::AddressParseError::InvalidBase58PayloadLength,
                7 => crate::api::error::AddressParseError::InvalidLegacyPrefix,
                8 => crate::api::error::AddressParseError::NetworkValidation,
                9 => crate::api::error::AddressParseError::OtherAddressParseErr,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Balance> for wire_cst_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Balance {
            crate::api::types::Balance {
                immature: self.immature.cst_decode(),
                trusted_pending: self.trusted_pending.cst_decode(),
                untrusted_pending: self.untrusted_pending.cst_decode(),
                confirmed: self.confirmed.cst_decode(),
                spendable: self.spendable.cst_decode(),
                total: self.total.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::Bip32Error> for wire_cst_bip_32_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::Bip32Error {
            match self.tag {
                0 => crate::api::error::Bip32Error::CannotDeriveFromHardenedKey,
                1 => {
                    let ans = unsafe { self.kind.Secp256k1 };
                    crate::api::error::Bip32Error::Secp256k1 {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.InvalidChildNumber };
                    crate::api::error::Bip32Error::InvalidChildNumber {
                        child_number: ans.child_number.cst_decode(),
                    }
                }
                3 => crate::api::error::Bip32Error::InvalidChildNumberFormat,
                4 => crate::api::error::Bip32Error::InvalidDerivationPathFormat,
                5 => {
                    let ans = unsafe { self.kind.UnknownVersion };
                    crate::api::error::Bip32Error::UnknownVersion {
                        version: ans.version.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.WrongExtendedKeyLength };
                    crate::api::error::Bip32Error::WrongExtendedKeyLength {
                        length: ans.length.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.Base58 };
                    crate::api::error::Bip32Error::Base58 {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                8 => {
                    let ans = unsafe { self.kind.Hex };
                    crate::api::error::Bip32Error::Hex {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                9 => {
                    let ans = unsafe { self.kind.InvalidPublicKeyHexLength };
                    crate::api::error::Bip32Error::InvalidPublicKeyHexLength {
                        length: ans.length.cst_decode(),
                    }
                }
                10 => {
                    let ans = unsafe { self.kind.UnknownError };
                    crate::api::error::Bip32Error::UnknownError {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::Bip39Error> for wire_cst_bip_39_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::Bip39Error {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.BadWordCount };
                    crate::api::error::Bip39Error::BadWordCount {
                        word_count: ans.word_count.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.UnknownWord };
                    crate::api::error::Bip39Error::UnknownWord {
                        index: ans.index.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.BadEntropyBitCount };
                    crate::api::error::Bip39Error::BadEntropyBitCount {
                        bit_count: ans.bit_count.cst_decode(),
                    }
                }
                3 => crate::api::error::Bip39Error::InvalidChecksum,
                4 => {
                    let ans = unsafe { self.kind.AmbiguousLanguages };
                    crate::api::error::Bip39Error::AmbiguousLanguages {
                        languages: ans.languages.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.Generic };
                    crate::api::error::Bip39Error::Generic {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::BlockId> for wire_cst_block_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BlockId {
            crate::api::types::BlockId {
                height: self.height.cst_decode(),
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::ConfirmationBlockTime> for *mut wire_cst_confirmation_block_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ConfirmationBlockTime {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::ConfirmationBlockTime>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bitcoin::FeeRate> for *mut wire_cst_fee_rate {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FeeRate {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bitcoin::FeeRate>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiAddress> for *mut wire_cst_ffi_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiAddress {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bitcoin::FfiAddress>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiCanonicalTx> for *mut wire_cst_ffi_canonical_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiCanonicalTx {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiCanonicalTx>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::store::FfiConnection> for *mut wire_cst_ffi_connection {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::store::FfiConnection {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::store::FfiConnection>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::FfiDerivationPath> for *mut wire_cst_ffi_derivation_path {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDerivationPath {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::FfiDerivationPath>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::descriptor::FfiDescriptor> for *mut wire_cst_ffi_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::FfiDescriptor {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::descriptor::FfiDescriptor>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::FfiDescriptorPublicKey>
        for *mut wire_cst_ffi_descriptor_public_key
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDescriptorPublicKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::FfiDescriptorPublicKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::FfiDescriptorSecretKey>
        for *mut wire_cst_ffi_descriptor_secret_key
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDescriptorSecretKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::FfiDescriptorSecretKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::electrum::FfiElectrumClient> for *mut wire_cst_ffi_electrum_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::electrum::FfiElectrumClient {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::electrum::FfiElectrumClient>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::esplora::FfiEsploraClient> for *mut wire_cst_ffi_esplora_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::esplora::FfiEsploraClient {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::esplora::FfiEsploraClient>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiFullScanRequest> for *mut wire_cst_ffi_full_scan_request {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiFullScanRequest {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiFullScanRequest>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>
        for *mut wire_cst_ffi_full_scan_request_builder
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiFullScanRequestBuilder {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiFullScanRequestBuilder>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::FfiMnemonic> for *mut wire_cst_ffi_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiMnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::FfiMnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiPsbt> for *mut wire_cst_ffi_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiPsbt {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bitcoin::FfiPsbt>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiScriptBuf> for *mut wire_cst_ffi_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiScriptBuf {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bitcoin::FfiScriptBuf>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiSyncRequest> for *mut wire_cst_ffi_sync_request {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiSyncRequest {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiSyncRequest>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiSyncRequestBuilder>
        for *mut wire_cst_ffi_sync_request_builder
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiSyncRequestBuilder {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiSyncRequestBuilder>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiTransaction> for *mut wire_cst_ffi_transaction {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiTransaction {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bitcoin::FfiTransaction>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::FfiUpdate> for *mut wire_cst_ffi_update {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiUpdate {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FfiUpdate>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::wallet::FfiWallet> for *mut wire_cst_ffi_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::FfiWallet {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::wallet::FfiWallet>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LockTime> for *mut wire_cst_lock_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LockTime {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LockTime>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::RbfValue> for *mut wire_cst_rbf_value {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::RbfValue {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::RbfValue>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SignOptions> for *mut wire_cst_sign_options {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SignOptions {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SignOptions>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::error::CalculateFeeError> for wire_cst_calculate_fee_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::CalculateFeeError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Generic };
                    crate::api::error::CalculateFeeError::Generic {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.MissingTxOut };
                    crate::api::error::CalculateFeeError::MissingTxOut {
                        out_points: ans.out_points.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.NegativeFee };
                    crate::api::error::CalculateFeeError::NegativeFee {
                        amount: ans.amount.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::CannotConnectError> for wire_cst_cannot_connect_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::CannotConnectError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Include };
                    crate::api::error::CannotConnectError::Include {
                        height: ans.height.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::ChainPosition> for wire_cst_chain_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChainPosition {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Confirmed };
                    crate::api::types::ChainPosition::Confirmed {
                        confirmation_block_time: ans.confirmation_block_time.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Unconfirmed };
                    crate::api::types::ChainPosition::Unconfirmed {
                        timestamp: ans.timestamp.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::ConfirmationBlockTime> for wire_cst_confirmation_block_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ConfirmationBlockTime {
            crate::api::types::ConfirmationBlockTime {
                block_id: self.block_id.cst_decode(),
                confirmation_time: self.confirmation_time.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::CreateTxError> for wire_cst_create_tx_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::CreateTxError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.TransactionNotFound };
                    crate::api::error::CreateTxError::TransactionNotFound {
                        txid: ans.txid.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.TransactionConfirmed };
                    crate::api::error::CreateTxError::TransactionConfirmed {
                        txid: ans.txid.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.IrreplaceableTransaction };
                    crate::api::error::CreateTxError::IrreplaceableTransaction {
                        txid: ans.txid.cst_decode(),
                    }
                }
                3 => crate::api::error::CreateTxError::FeeRateUnavailable,
                4 => {
                    let ans = unsafe { self.kind.Generic };
                    crate::api::error::CreateTxError::Generic {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.Descriptor };
                    crate::api::error::CreateTxError::Descriptor {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.Policy };
                    crate::api::error::CreateTxError::Policy {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.SpendingPolicyRequired };
                    crate::api::error::CreateTxError::SpendingPolicyRequired {
                        kind: ans.kind.cst_decode(),
                    }
                }
                8 => crate::api::error::CreateTxError::Version0,
                9 => crate::api::error::CreateTxError::Version1Csv,
                10 => {
                    let ans = unsafe { self.kind.LockTime };
                    crate::api::error::CreateTxError::LockTime {
                        requested_time: ans.requested_time.cst_decode(),
                        required_time: ans.required_time.cst_decode(),
                    }
                }
                11 => crate::api::error::CreateTxError::RbfSequence,
                12 => {
                    let ans = unsafe { self.kind.RbfSequenceCsv };
                    crate::api::error::CreateTxError::RbfSequenceCsv {
                        rbf: ans.rbf.cst_decode(),
                        csv: ans.csv.cst_decode(),
                    }
                }
                13 => {
                    let ans = unsafe { self.kind.FeeTooLow };
                    crate::api::error::CreateTxError::FeeTooLow {
                        fee_required: ans.fee_required.cst_decode(),
                    }
                }
                14 => {
                    let ans = unsafe { self.kind.FeeRateTooLow };
                    crate::api::error::CreateTxError::FeeRateTooLow {
                        fee_rate_required: ans.fee_rate_required.cst_decode(),
                    }
                }
                15 => crate::api::error::CreateTxError::NoUtxosSelected,
                16 => {
                    let ans = unsafe { self.kind.OutputBelowDustLimit };
                    crate::api::error::CreateTxError::OutputBelowDustLimit {
                        index: ans.index.cst_decode(),
                    }
                }
                17 => crate::api::error::CreateTxError::ChangePolicyDescriptor,
                18 => {
                    let ans = unsafe { self.kind.CoinSelection };
                    crate::api::error::CreateTxError::CoinSelection {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                19 => {
                    let ans = unsafe { self.kind.InsufficientFunds };
                    crate::api::error::CreateTxError::InsufficientFunds {
                        needed: ans.needed.cst_decode(),
                        available: ans.available.cst_decode(),
                    }
                }
                20 => crate::api::error::CreateTxError::NoRecipients,
                21 => {
                    let ans = unsafe { self.kind.Psbt };
                    crate::api::error::CreateTxError::Psbt {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                22 => {
                    let ans = unsafe { self.kind.MissingKeyOrigin };
                    crate::api::error::CreateTxError::MissingKeyOrigin {
                        key: ans.key.cst_decode(),
                    }
                }
                23 => {
                    let ans = unsafe { self.kind.UnknownUtxo };
                    crate::api::error::CreateTxError::UnknownUtxo {
                        outpoint: ans.outpoint.cst_decode(),
                    }
                }
                24 => {
                    let ans = unsafe { self.kind.MissingNonWitnessUtxo };
                    crate::api::error::CreateTxError::MissingNonWitnessUtxo {
                        outpoint: ans.outpoint.cst_decode(),
                    }
                }
                25 => {
                    let ans = unsafe { self.kind.MiniscriptPsbt };
                    crate::api::error::CreateTxError::MiniscriptPsbt {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::CreateWithPersistError> for wire_cst_create_with_persist_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::CreateWithPersistError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Persist };
                    crate::api::error::CreateWithPersistError::Persist {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => crate::api::error::CreateWithPersistError::DataAlreadyExists,
                2 => {
                    let ans = unsafe { self.kind.Descriptor };
                    crate::api::error::CreateWithPersistError::Descriptor {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::DescriptorError> for wire_cst_descriptor_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::DescriptorError {
            match self.tag {
                0 => crate::api::error::DescriptorError::InvalidHdKeyPath,
                1 => crate::api::error::DescriptorError::MissingPrivateData,
                2 => crate::api::error::DescriptorError::InvalidDescriptorChecksum,
                3 => crate::api::error::DescriptorError::HardenedDerivationXpub,
                4 => crate::api::error::DescriptorError::MultiPath,
                5 => {
                    let ans = unsafe { self.kind.Key };
                    crate::api::error::DescriptorError::Key {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.Generic };
                    crate::api::error::DescriptorError::Generic {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.Policy };
                    crate::api::error::DescriptorError::Policy {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                8 => {
                    let ans = unsafe { self.kind.InvalidDescriptorCharacter };
                    crate::api::error::DescriptorError::InvalidDescriptorCharacter {
                        charector: ans.charector.cst_decode(),
                    }
                }
                9 => {
                    let ans = unsafe { self.kind.Bip32 };
                    crate::api::error::DescriptorError::Bip32 {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                10 => {
                    let ans = unsafe { self.kind.Base58 };
                    crate::api::error::DescriptorError::Base58 {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                11 => {
                    let ans = unsafe { self.kind.Pk };
                    crate::api::error::DescriptorError::Pk {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                12 => {
                    let ans = unsafe { self.kind.Miniscript };
                    crate::api::error::DescriptorError::Miniscript {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                13 => {
                    let ans = unsafe { self.kind.Hex };
                    crate::api::error::DescriptorError::Hex {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                14 => crate::api::error::DescriptorError::ExternalAndInternalAreTheSame,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::DescriptorKeyError> for wire_cst_descriptor_key_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::DescriptorKeyError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Parse };
                    crate::api::error::DescriptorKeyError::Parse {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => crate::api::error::DescriptorKeyError::InvalidKeyType,
                2 => {
                    let ans = unsafe { self.kind.Bip32 };
                    crate::api::error::DescriptorKeyError::Bip32 {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::ElectrumError> for wire_cst_electrum_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::ElectrumError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.IOError };
                    crate::api::error::ElectrumError::IOError {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Json };
                    crate::api::error::ElectrumError::Json {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Hex };
                    crate::api::error::ElectrumError::Hex {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Protocol };
                    crate::api::error::ElectrumError::Protocol {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.Bitcoin };
                    crate::api::error::ElectrumError::Bitcoin {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                5 => crate::api::error::ElectrumError::AlreadySubscribed,
                6 => crate::api::error::ElectrumError::NotSubscribed,
                7 => {
                    let ans = unsafe { self.kind.InvalidResponse };
                    crate::api::error::ElectrumError::InvalidResponse {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                8 => {
                    let ans = unsafe { self.kind.Message };
                    crate::api::error::ElectrumError::Message {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                9 => {
                    let ans = unsafe { self.kind.InvalidDNSNameError };
                    crate::api::error::ElectrumError::InvalidDNSNameError {
                        domain: ans.domain.cst_decode(),
                    }
                }
                10 => crate::api::error::ElectrumError::MissingDomain,
                11 => crate::api::error::ElectrumError::AllAttemptsErrored,
                12 => {
                    let ans = unsafe { self.kind.SharedIOError };
                    crate::api::error::ElectrumError::SharedIOError {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                13 => crate::api::error::ElectrumError::CouldntLockReader,
                14 => crate::api::error::ElectrumError::Mpsc,
                15 => {
                    let ans = unsafe { self.kind.CouldNotCreateConnection };
                    crate::api::error::ElectrumError::CouldNotCreateConnection {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                16 => crate::api::error::ElectrumError::RequestAlreadyConsumed,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::EsploraError> for wire_cst_esplora_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::EsploraError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Minreq };
                    crate::api::error::EsploraError::Minreq {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.HttpResponse };
                    crate::api::error::EsploraError::HttpResponse {
                        status: ans.status.cst_decode(),
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Parsing };
                    crate::api::error::EsploraError::Parsing {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.StatusCode };
                    crate::api::error::EsploraError::StatusCode {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.BitcoinEncoding };
                    crate::api::error::EsploraError::BitcoinEncoding {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.HexToArray };
                    crate::api::error::EsploraError::HexToArray {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.HexToBytes };
                    crate::api::error::EsploraError::HexToBytes {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                7 => crate::api::error::EsploraError::TransactionNotFound,
                8 => {
                    let ans = unsafe { self.kind.HeaderHeightNotFound };
                    crate::api::error::EsploraError::HeaderHeightNotFound {
                        height: ans.height.cst_decode(),
                    }
                }
                9 => crate::api::error::EsploraError::HeaderHashNotFound,
                10 => {
                    let ans = unsafe { self.kind.InvalidHttpHeaderName };
                    crate::api::error::EsploraError::InvalidHttpHeaderName {
                        name: ans.name.cst_decode(),
                    }
                }
                11 => {
                    let ans = unsafe { self.kind.InvalidHttpHeaderValue };
                    crate::api::error::EsploraError::InvalidHttpHeaderValue {
                        value: ans.value.cst_decode(),
                    }
                }
                12 => crate::api::error::EsploraError::RequestAlreadyConsumed,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::ExtractTxError> for wire_cst_extract_tx_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::ExtractTxError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.AbsurdFeeRate };
                    crate::api::error::ExtractTxError::AbsurdFeeRate {
                        fee_rate: ans.fee_rate.cst_decode(),
                    }
                }
                1 => crate::api::error::ExtractTxError::MissingInputValue,
                2 => crate::api::error::ExtractTxError::SendingTooMuch,
                3 => crate::api::error::ExtractTxError::OtherExtractTxErr,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::FeeRate> for wire_cst_fee_rate {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FeeRate {
            crate::api::bitcoin::FeeRate {
                sat_kwu: self.sat_kwu.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiAddress> for wire_cst_ffi_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiAddress {
            crate::api::bitcoin::FfiAddress(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::FfiCanonicalTx> for wire_cst_ffi_canonical_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiCanonicalTx {
            crate::api::types::FfiCanonicalTx {
                transaction: self.transaction.cst_decode(),
                chain_position: self.chain_position.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::store::FfiConnection> for wire_cst_ffi_connection {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::store::FfiConnection {
            crate::api::store::FfiConnection(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::key::FfiDerivationPath> for wire_cst_ffi_derivation_path {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDerivationPath {
            crate::api::key::FfiDerivationPath {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::descriptor::FfiDescriptor> for wire_cst_ffi_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::FfiDescriptor {
            crate::api::descriptor::FfiDescriptor {
                extended_descriptor: self.extended_descriptor.cst_decode(),
                key_map: self.key_map.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::key::FfiDescriptorPublicKey> for wire_cst_ffi_descriptor_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDescriptorPublicKey {
            crate::api::key::FfiDescriptorPublicKey {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::key::FfiDescriptorSecretKey> for wire_cst_ffi_descriptor_secret_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiDescriptorSecretKey {
            crate::api::key::FfiDescriptorSecretKey {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::electrum::FfiElectrumClient> for wire_cst_ffi_electrum_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::electrum::FfiElectrumClient {
            crate::api::electrum::FfiElectrumClient {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::esplora::FfiEsploraClient> for wire_cst_ffi_esplora_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::esplora::FfiEsploraClient {
            crate::api::esplora::FfiEsploraClient {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::FfiFullScanRequest> for wire_cst_ffi_full_scan_request {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiFullScanRequest {
            crate::api::types::FfiFullScanRequest(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::FfiFullScanRequestBuilder>
        for wire_cst_ffi_full_scan_request_builder
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiFullScanRequestBuilder {
            crate::api::types::FfiFullScanRequestBuilder(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::key::FfiMnemonic> for wire_cst_ffi_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::FfiMnemonic {
            crate::api::key::FfiMnemonic {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiPsbt> for wire_cst_ffi_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiPsbt {
            crate::api::bitcoin::FfiPsbt {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiScriptBuf> for wire_cst_ffi_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiScriptBuf {
            crate::api::bitcoin::FfiScriptBuf {
                bytes: self.bytes.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::FfiSyncRequest> for wire_cst_ffi_sync_request {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiSyncRequest {
            crate::api::types::FfiSyncRequest(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::FfiSyncRequestBuilder> for wire_cst_ffi_sync_request_builder {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiSyncRequestBuilder {
            crate::api::types::FfiSyncRequestBuilder(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::bitcoin::FfiTransaction> for wire_cst_ffi_transaction {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::FfiTransaction {
            crate::api::bitcoin::FfiTransaction {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::FfiUpdate> for wire_cst_ffi_update {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FfiUpdate {
            crate::api::types::FfiUpdate(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::wallet::FfiWallet> for wire_cst_ffi_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::FfiWallet {
            crate::api::wallet::FfiWallet {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::FromScriptError> for wire_cst_from_script_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::FromScriptError {
            match self.tag {
                0 => crate::api::error::FromScriptError::UnrecognizedScript,
                1 => {
                    let ans = unsafe { self.kind.WitnessProgram };
                    crate::api::error::FromScriptError::WitnessProgram {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.WitnessVersion };
                    crate::api::error::FromScriptError::WitnessVersion {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                3 => crate::api::error::FromScriptError::OtherFromScriptErr,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::FfiCanonicalTx>> for *mut wire_cst_list_ffi_canonical_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::FfiCanonicalTx> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::LocalOutput>> for *mut wire_cst_list_local_output {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::LocalOutput> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::bitcoin::OutPoint>> for *mut wire_cst_list_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::bitcoin::OutPoint> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(crate::api::bitcoin::FfiScriptBuf, u64)>>
        for *mut wire_cst_list_record_ffi_script_buf_u_64
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(crate::api::bitcoin::FfiScriptBuf, u64)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::bitcoin::TxIn>> for *mut wire_cst_list_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::bitcoin::TxIn> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::bitcoin::TxOut>> for *mut wire_cst_list_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::bitcoin::TxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::api::error::LoadWithPersistError> for wire_cst_load_with_persist_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::LoadWithPersistError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Persist };
                    crate::api::error::LoadWithPersistError::Persist {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.InvalidChangeSet };
                    crate::api::error::LoadWithPersistError::InvalidChangeSet {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                2 => crate::api::error::LoadWithPersistError::CouldNotLoad,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::LocalOutput> for wire_cst_local_output {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LocalOutput {
            crate::api::types::LocalOutput {
                outpoint: self.outpoint.cst_decode(),
                txout: self.txout.cst_decode(),
                keychain: self.keychain.cst_decode(),
                is_spent: self.is_spent.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::LockTime> for wire_cst_lock_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LockTime {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Blocks };
                    crate::api::types::LockTime::Blocks(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.Seconds };
                    crate::api::types::LockTime::Seconds(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::OutPoint {
            crate::api::bitcoin::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::PsbtError> for wire_cst_psbt_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::PsbtError {
            match self.tag {
                0 => crate::api::error::PsbtError::InvalidMagic,
                1 => crate::api::error::PsbtError::MissingUtxo,
                2 => crate::api::error::PsbtError::InvalidSeparator,
                3 => crate::api::error::PsbtError::PsbtUtxoOutOfBounds,
                4 => {
                    let ans = unsafe { self.kind.InvalidKey };
                    crate::api::error::PsbtError::InvalidKey {
                        key: ans.key.cst_decode(),
                    }
                }
                5 => crate::api::error::PsbtError::InvalidProprietaryKey,
                6 => {
                    let ans = unsafe { self.kind.DuplicateKey };
                    crate::api::error::PsbtError::DuplicateKey {
                        key: ans.key.cst_decode(),
                    }
                }
                7 => crate::api::error::PsbtError::UnsignedTxHasScriptSigs,
                8 => crate::api::error::PsbtError::UnsignedTxHasScriptWitnesses,
                9 => crate::api::error::PsbtError::MustHaveUnsignedTx,
                10 => crate::api::error::PsbtError::NoMorePairs,
                11 => crate::api::error::PsbtError::UnexpectedUnsignedTx,
                12 => {
                    let ans = unsafe { self.kind.NonStandardSighashType };
                    crate::api::error::PsbtError::NonStandardSighashType {
                        sighash: ans.sighash.cst_decode(),
                    }
                }
                13 => {
                    let ans = unsafe { self.kind.InvalidHash };
                    crate::api::error::PsbtError::InvalidHash {
                        hash: ans.hash.cst_decode(),
                    }
                }
                14 => crate::api::error::PsbtError::InvalidPreimageHashPair,
                15 => {
                    let ans = unsafe { self.kind.CombineInconsistentKeySources };
                    crate::api::error::PsbtError::CombineInconsistentKeySources {
                        xpub: ans.xpub.cst_decode(),
                    }
                }
                16 => {
                    let ans = unsafe { self.kind.ConsensusEncoding };
                    crate::api::error::PsbtError::ConsensusEncoding {
                        encoding_error: ans.encoding_error.cst_decode(),
                    }
                }
                17 => crate::api::error::PsbtError::NegativeFee,
                18 => crate::api::error::PsbtError::FeeOverflow,
                19 => {
                    let ans = unsafe { self.kind.InvalidPublicKey };
                    crate::api::error::PsbtError::InvalidPublicKey {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                20 => {
                    let ans = unsafe { self.kind.InvalidSecp256k1PublicKey };
                    crate::api::error::PsbtError::InvalidSecp256k1PublicKey {
                        secp256k1_error: ans.secp256k1_error.cst_decode(),
                    }
                }
                21 => crate::api::error::PsbtError::InvalidXOnlyPublicKey,
                22 => {
                    let ans = unsafe { self.kind.InvalidEcdsaSignature };
                    crate::api::error::PsbtError::InvalidEcdsaSignature {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                23 => {
                    let ans = unsafe { self.kind.InvalidTaprootSignature };
                    crate::api::error::PsbtError::InvalidTaprootSignature {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                24 => crate::api::error::PsbtError::InvalidControlBlock,
                25 => crate::api::error::PsbtError::InvalidLeafVersion,
                26 => crate::api::error::PsbtError::Taproot,
                27 => {
                    let ans = unsafe { self.kind.TapTree };
                    crate::api::error::PsbtError::TapTree {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                28 => crate::api::error::PsbtError::XPubKey,
                29 => {
                    let ans = unsafe { self.kind.Version };
                    crate::api::error::PsbtError::Version {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                30 => crate::api::error::PsbtError::PartialDataConsumption,
                31 => {
                    let ans = unsafe { self.kind.Io };
                    crate::api::error::PsbtError::Io {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                32 => crate::api::error::PsbtError::OtherPsbtErr,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::PsbtParseError> for wire_cst_psbt_parse_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::PsbtParseError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PsbtEncoding };
                    crate::api::error::PsbtParseError::PsbtEncoding {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Base64Encoding };
                    crate::api::error::PsbtParseError::Base64Encoding {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::RbfValue> for wire_cst_rbf_value {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::RbfValue {
            match self.tag {
                0 => crate::api::types::RbfValue::RbfDefault,
                1 => {
                    let ans = unsafe { self.kind.Value };
                    crate::api::types::RbfValue::Value(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<(crate::api::bitcoin::FfiScriptBuf, u64)> for wire_cst_record_ffi_script_buf_u_64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (crate::api::bitcoin::FfiScriptBuf, u64) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::SignOptions> for wire_cst_sign_options {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SignOptions {
            crate::api::types::SignOptions {
                trust_witness_utxo: self.trust_witness_utxo.cst_decode(),
                assume_height: self.assume_height.cst_decode(),
                allow_all_sighashes: self.allow_all_sighashes.cst_decode(),
                try_finalize: self.try_finalize.cst_decode(),
                sign_with_tap_internal_key: self.sign_with_tap_internal_key.cst_decode(),
                allow_grinding: self.allow_grinding.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::SignerError> for wire_cst_signer_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::SignerError {
            match self.tag {
                0 => crate::api::error::SignerError::MissingKey,
                1 => crate::api::error::SignerError::InvalidKey,
                2 => crate::api::error::SignerError::UserCanceled,
                3 => crate::api::error::SignerError::InputIndexOutOfRange,
                4 => crate::api::error::SignerError::MissingNonWitnessUtxo,
                5 => crate::api::error::SignerError::InvalidNonWitnessUtxo,
                6 => crate::api::error::SignerError::MissingWitnessUtxo,
                7 => crate::api::error::SignerError::MissingWitnessScript,
                8 => crate::api::error::SignerError::MissingHdKeypath,
                9 => crate::api::error::SignerError::NonStandardSighash,
                10 => crate::api::error::SignerError::InvalidSighash,
                11 => {
                    let ans = unsafe { self.kind.SighashP2wpkh };
                    crate::api::error::SignerError::SighashP2wpkh {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                12 => {
                    let ans = unsafe { self.kind.SighashTaproot };
                    crate::api::error::SignerError::SighashTaproot {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                13 => {
                    let ans = unsafe { self.kind.TxInputsIndexError };
                    crate::api::error::SignerError::TxInputsIndexError {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                14 => {
                    let ans = unsafe { self.kind.MiniscriptPsbt };
                    crate::api::error::SignerError::MiniscriptPsbt {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                15 => {
                    let ans = unsafe { self.kind.External };
                    crate::api::error::SignerError::External {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                16 => {
                    let ans = unsafe { self.kind.Psbt };
                    crate::api::error::SignerError::Psbt {
                        error_message: ans.error_message.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::SqliteError> for wire_cst_sqlite_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::SqliteError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Sqlite };
                    crate::api::error::SqliteError::Sqlite {
                        rusqlite_error: ans.rusqlite_error.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::SyncProgress> for wire_cst_sync_progress {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SyncProgress {
            crate::api::types::SyncProgress {
                spks_consumed: self.spks_consumed.cst_decode(),
                spks_remaining: self.spks_remaining.cst_decode(),
                txids_consumed: self.txids_consumed.cst_decode(),
                txids_remaining: self.txids_remaining.cst_decode(),
                outpoints_consumed: self.outpoints_consumed.cst_decode(),
                outpoints_remaining: self.outpoints_remaining.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::TransactionError> for wire_cst_transaction_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::TransactionError {
            match self.tag {
                0 => crate::api::error::TransactionError::Io,
                1 => crate::api::error::TransactionError::OversizedVectorAllocation,
                2 => {
                    let ans = unsafe { self.kind.InvalidChecksum };
                    crate::api::error::TransactionError::InvalidChecksum {
                        expected: ans.expected.cst_decode(),
                        actual: ans.actual.cst_decode(),
                    }
                }
                3 => crate::api::error::TransactionError::NonMinimalVarInt,
                4 => crate::api::error::TransactionError::ParseFailed,
                5 => {
                    let ans = unsafe { self.kind.UnsupportedSegwitFlag };
                    crate::api::error::TransactionError::UnsupportedSegwitFlag {
                        flag: ans.flag.cst_decode(),
                    }
                }
                6 => crate::api::error::TransactionError::OtherTransactionErr,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::TxIn> for wire_cst_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::TxIn {
            crate::api::bitcoin::TxIn {
                previous_output: self.previous_output.cst_decode(),
                script_sig: self.script_sig.cst_decode(),
                sequence: self.sequence.cst_decode(),
                witness: self.witness.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bitcoin::TxOut> for wire_cst_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bitcoin::TxOut {
            crate::api::bitcoin::TxOut {
                value: self.value.cst_decode(),
                script_pubkey: self.script_pubkey.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::TxidParseError> for wire_cst_txid_parse_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::TxidParseError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.InvalidTxid };
                    crate::api::error::TxidParseError::InvalidTxid {
                        txid: ans.txid.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_address_info {
        fn new_with_null_ptr() -> Self {
            Self {
                index: Default::default(),
                address: Default::default(),
                keychain: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_parse_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: AddressParseErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_address_parse_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                immature: Default::default(),
                trusted_pending: Default::default(),
                untrusted_pending: Default::default(),
                confirmed: Default::default(),
                spendable: Default::default(),
                total: Default::default(),
            }
        }
    }
    impl Default for wire_cst_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bip_32_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: Bip32ErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_bip_32_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bip_39_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: Bip39ErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_bip_39_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_block_id {
        fn new_with_null_ptr() -> Self {
            Self {
                height: Default::default(),
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_block_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_calculate_fee_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CalculateFeeErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_calculate_fee_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_cannot_connect_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CannotConnectErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_cannot_connect_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_position {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ChainPositionKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_chain_position {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_confirmation_block_time {
        fn new_with_null_ptr() -> Self {
            Self {
                block_id: Default::default(),
                confirmation_time: Default::default(),
            }
        }
    }
    impl Default for wire_cst_confirmation_block_time {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_create_tx_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CreateTxErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_create_tx_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_create_with_persist_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CreateWithPersistErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_create_with_persist_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_descriptor_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: DescriptorErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_descriptor_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_descriptor_key_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: DescriptorKeyErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_descriptor_key_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_electrum_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ElectrumErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_electrum_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_esplora_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EsploraErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_esplora_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_extract_tx_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ExtractTxErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_extract_tx_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_fee_rate {
        fn new_with_null_ptr() -> Self {
            Self {
                sat_kwu: Default::default(),
            }
        }
    }
    impl Default for wire_cst_fee_rate {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_address {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_address {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_canonical_tx {
        fn new_with_null_ptr() -> Self {
            Self {
                transaction: Default::default(),
                chain_position: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_canonical_tx {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_connection {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_connection {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_derivation_path {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_derivation_path {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_descriptor {
        fn new_with_null_ptr() -> Self {
            Self {
                extended_descriptor: Default::default(),
                key_map: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_descriptor {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_descriptor_public_key {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_descriptor_public_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_descriptor_secret_key {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_descriptor_secret_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_electrum_client {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_electrum_client {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_esplora_client {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_esplora_client {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_full_scan_request {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_full_scan_request {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_full_scan_request_builder {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_full_scan_request_builder {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_psbt {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_psbt {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_script_buf {
        fn new_with_null_ptr() -> Self {
            Self {
                bytes: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_ffi_script_buf {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_sync_request {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_sync_request {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_sync_request_builder {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_sync_request_builder {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_transaction {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_transaction {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_update {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_update {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_wallet {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_wallet {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_from_script_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: FromScriptErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_from_script_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_load_with_persist_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: LoadWithPersistErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_load_with_persist_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_local_output {
        fn new_with_null_ptr() -> Self {
            Self {
                outpoint: Default::default(),
                txout: Default::default(),
                keychain: Default::default(),
                is_spent: Default::default(),
            }
        }
    }
    impl Default for wire_cst_local_output {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lock_time {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: LockTimeKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_lock_time {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PsbtErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_psbt_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt_parse_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PsbtParseErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_psbt_parse_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_rbf_value {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: RbfValueKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_rbf_value {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_ffi_script_buf_u_64 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_ffi_script_buf_u_64 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sign_options {
        fn new_with_null_ptr() -> Self {
            Self {
                trust_witness_utxo: Default::default(),
                assume_height: core::ptr::null_mut(),
                allow_all_sighashes: Default::default(),
                try_finalize: Default::default(),
                sign_with_tap_internal_key: Default::default(),
                allow_grinding: Default::default(),
            }
        }
    }
    impl Default for wire_cst_sign_options {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_signer_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: SignerErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_signer_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sqlite_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: SqliteErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_sqlite_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sync_progress {
        fn new_with_null_ptr() -> Self {
            Self {
                spks_consumed: Default::default(),
                spks_remaining: Default::default(),
                txids_consumed: Default::default(),
                txids_remaining: Default::default(),
                outpoints_consumed: Default::default(),
                outpoints_remaining: Default::default(),
            }
        }
    }
    impl Default for wire_cst_sync_progress {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_transaction_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: TransactionErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_transaction_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_in {
        fn new_with_null_ptr() -> Self {
            Self {
                previous_output: Default::default(),
                script_sig: Default::default(),
                sequence: Default::default(),
                witness: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_tx_in {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                script_pubkey: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_txid_parse_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: TxidParseErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_txid_parse_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_as_string(
        that: *mut wire_cst_ffi_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_address_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_from_script(
        port_: i64,
        script: *mut wire_cst_ffi_script_buf,
        network: i32,
    ) {
        wire__crate__api__bitcoin__ffi_address_from_script_impl(port_, script, network)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_from_string(
        port_: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) {
        wire__crate__api__bitcoin__ffi_address_from_string_impl(port_, address, network)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_is_valid_for_network(
        that: *mut wire_cst_ffi_address,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_address_is_valid_for_network_impl(that, network)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_script(
        opaque: *mut wire_cst_ffi_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_address_script_impl(opaque)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_address_to_qr_uri(
        that: *mut wire_cst_ffi_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_address_to_qr_uri_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_as_string(
        that: *mut wire_cst_ffi_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_psbt_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_combine(
        port_: i64,
        opaque: *mut wire_cst_ffi_psbt,
        other: *mut wire_cst_ffi_psbt,
    ) {
        wire__crate__api__bitcoin__ffi_psbt_combine_impl(port_, opaque, other)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_extract_tx(
        opaque: *mut wire_cst_ffi_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_psbt_extract_tx_impl(opaque)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_fee_amount(
        that: *mut wire_cst_ffi_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_psbt_fee_amount_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_from_str(
        port_: i64,
        psbt_base64: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__bitcoin__ffi_psbt_from_str_impl(port_, psbt_base64)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_json_serialize(
        that: *mut wire_cst_ffi_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_psbt_json_serialize_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_psbt_serialize(
        that: *mut wire_cst_ffi_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_psbt_serialize_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_as_string(
        that: *mut wire_cst_ffi_script_buf,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_script_buf_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_empty(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_script_buf_empty_impl()
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_script_buf_with_capacity(
        port_: i64,
        capacity: usize,
    ) {
        wire__crate__api__bitcoin__ffi_script_buf_with_capacity_impl(port_, capacity)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_compute_txid(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_compute_txid_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_from_bytes(
        port_: i64,
        transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__bitcoin__ffi_transaction_from_bytes_impl(port_, transaction_bytes)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_input(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_input_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_coinbase(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_is_coinbase_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_lock_time(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_lock_time_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_new(
        port_: i64,
        version: i32,
        lock_time: *mut wire_cst_lock_time,
        input: *mut wire_cst_list_tx_in,
        output: *mut wire_cst_list_tx_out,
    ) {
        wire__crate__api__bitcoin__ffi_transaction_new_impl(
            port_, version, lock_time, input, output,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_output(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_output_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_serialize(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_serialize_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_version(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_version_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_vsize(
        that: *mut wire_cst_ffi_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__bitcoin__ffi_transaction_vsize_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__bitcoin__ffi_transaction_weight(
        port_: i64,
        that: *mut wire_cst_ffi_transaction,
    ) {
        wire__crate__api__bitcoin__ffi_transaction_weight_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_as_string(
        that: *mut wire_cst_ffi_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__ffi_descriptor_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight(
        that: *mut wire_cst_ffi_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new(
        port_: i64,
        descriptor: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_impl(port_, descriptor, network)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip44(
        port_: i64,
        secret_key: *mut wire_cst_ffi_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip44_impl(
            port_,
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip44_public(
        port_: i64,
        public_key: *mut wire_cst_ffi_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip44_public_impl(
            port_,
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip49(
        port_: i64,
        secret_key: *mut wire_cst_ffi_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip49_impl(
            port_,
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip49_public(
        port_: i64,
        public_key: *mut wire_cst_ffi_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip49_public_impl(
            port_,
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip84(
        port_: i64,
        secret_key: *mut wire_cst_ffi_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip84_impl(
            port_,
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip84_public(
        port_: i64,
        public_key: *mut wire_cst_ffi_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip84_public_impl(
            port_,
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip86(
        port_: i64,
        secret_key: *mut wire_cst_ffi_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip86_impl(
            port_,
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_new_bip86_public(
        port_: i64,
        public_key: *mut wire_cst_ffi_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) {
        wire__crate__api__descriptor__ffi_descriptor_new_bip86_public_impl(
            port_,
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret(
        that: *mut wire_cst_ffi_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__ffi_electrum_client_broadcast(
        port_: i64,
        opaque: *mut wire_cst_ffi_electrum_client,
        transaction: *mut wire_cst_ffi_transaction,
    ) {
        wire__crate__api__electrum__ffi_electrum_client_broadcast_impl(port_, opaque, transaction)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__ffi_electrum_client_full_scan(
        port_: i64,
        opaque: *mut wire_cst_ffi_electrum_client,
        request: *mut wire_cst_ffi_full_scan_request,
        stop_gap: u64,
        batch_size: u64,
        fetch_prev_txouts: bool,
    ) {
        wire__crate__api__electrum__ffi_electrum_client_full_scan_impl(
            port_,
            opaque,
            request,
            stop_gap,
            batch_size,
            fetch_prev_txouts,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__ffi_electrum_client_new(
        port_: i64,
        url: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__electrum__ffi_electrum_client_new_impl(port_, url)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__electrum__ffi_electrum_client_sync(
        port_: i64,
        opaque: *mut wire_cst_ffi_electrum_client,
        request: *mut wire_cst_ffi_sync_request,
        batch_size: u64,
        fetch_prev_txouts: bool,
    ) {
        wire__crate__api__electrum__ffi_electrum_client_sync_impl(
            port_,
            opaque,
            request,
            batch_size,
            fetch_prev_txouts,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__ffi_esplora_client_broadcast(
        port_: i64,
        opaque: *mut wire_cst_ffi_esplora_client,
        transaction: *mut wire_cst_ffi_transaction,
    ) {
        wire__crate__api__esplora__ffi_esplora_client_broadcast_impl(port_, opaque, transaction)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__ffi_esplora_client_full_scan(
        port_: i64,
        opaque: *mut wire_cst_ffi_esplora_client,
        request: *mut wire_cst_ffi_full_scan_request,
        stop_gap: u64,
        parallel_requests: u64,
    ) {
        wire__crate__api__esplora__ffi_esplora_client_full_scan_impl(
            port_,
            opaque,
            request,
            stop_gap,
            parallel_requests,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__ffi_esplora_client_new(
        port_: i64,
        url: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__esplora__ffi_esplora_client_new_impl(port_, url)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__esplora__ffi_esplora_client_sync(
        port_: i64,
        opaque: *mut wire_cst_ffi_esplora_client,
        request: *mut wire_cst_ffi_sync_request,
        parallel_requests: u64,
    ) {
        wire__crate__api__esplora__ffi_esplora_client_sync_impl(
            port_,
            opaque,
            request,
            parallel_requests,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_derivation_path_as_string(
        that: *mut wire_cst_ffi_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_derivation_path_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_derivation_path_from_string(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__ffi_derivation_path_from_string_impl(port_, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_as_string(
        that: *mut wire_cst_ffi_descriptor_public_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_descriptor_public_key_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_derive(
        port_: i64,
        opaque: *mut wire_cst_ffi_descriptor_public_key,
        path: *mut wire_cst_ffi_derivation_path,
    ) {
        wire__crate__api__key__ffi_descriptor_public_key_derive_impl(port_, opaque, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_extend(
        port_: i64,
        opaque: *mut wire_cst_ffi_descriptor_public_key,
        path: *mut wire_cst_ffi_derivation_path,
    ) {
        wire__crate__api__key__ffi_descriptor_public_key_extend_impl(port_, opaque, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_public_key_from_string(
        port_: i64,
        public_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__ffi_descriptor_public_key_from_string_impl(port_, public_key)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_as_public(
        opaque: *mut wire_cst_ffi_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_descriptor_secret_key_as_public_impl(opaque)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_as_string(
        that: *mut wire_cst_ffi_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_descriptor_secret_key_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_create(
        port_: i64,
        network: i32,
        mnemonic: *mut wire_cst_ffi_mnemonic,
        password: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__ffi_descriptor_secret_key_create_impl(
            port_, network, mnemonic, password,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_derive(
        port_: i64,
        opaque: *mut wire_cst_ffi_descriptor_secret_key,
        path: *mut wire_cst_ffi_derivation_path,
    ) {
        wire__crate__api__key__ffi_descriptor_secret_key_derive_impl(port_, opaque, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_extend(
        port_: i64,
        opaque: *mut wire_cst_ffi_descriptor_secret_key,
        path: *mut wire_cst_ffi_derivation_path,
    ) {
        wire__crate__api__key__ffi_descriptor_secret_key_extend_impl(port_, opaque, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_from_string(
        port_: i64,
        secret_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__ffi_descriptor_secret_key_from_string_impl(port_, secret_key)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes(
        that: *mut wire_cst_ffi_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_as_string(
        that: *mut wire_cst_ffi_mnemonic,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__ffi_mnemonic_as_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_from_entropy(
        port_: i64,
        entropy: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__key__ffi_mnemonic_from_entropy_impl(port_, entropy)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_from_string(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__ffi_mnemonic_from_string_impl(port_, mnemonic)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__ffi_mnemonic_new(
        port_: i64,
        word_count: i32,
    ) {
        wire__crate__api__key__ffi_mnemonic_new_impl(port_, word_count)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__store__ffi_connection_new(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__store__ffi_connection_new_impl(port_, path)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__store__ffi_connection_new_in_memory(
        port_: i64,
    ) {
        wire__crate__api__store__ffi_connection_new_in_memory_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__tx_builder__finish_bump_fee_tx_builder(
        port_: i64,
        txid: *mut wire_cst_list_prim_u_8_strict,
        fee_rate: *mut wire_cst_fee_rate,
        wallet: *mut wire_cst_ffi_wallet,
        enable_rbf: bool,
        n_sequence: *mut u32,
    ) {
        wire__crate__api__tx_builder__finish_bump_fee_tx_builder_impl(
            port_, txid, fee_rate, wallet, enable_rbf, n_sequence,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__tx_builder__tx_builder_finish(
        port_: i64,
        wallet: *mut wire_cst_ffi_wallet,
        recipients: *mut wire_cst_list_record_ffi_script_buf_u_64,
        utxos: *mut wire_cst_list_out_point,
        un_spendable: *mut wire_cst_list_out_point,
        change_policy: i32,
        manually_selected_only: bool,
        fee_rate: *mut wire_cst_fee_rate,
        fee_absolute: *mut u64,
        drain_wallet: bool,
        drain_to: *mut wire_cst_ffi_script_buf,
        rbf: *mut wire_cst_rbf_value,
        data: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__tx_builder__tx_builder_finish_impl(
            port_,
            wallet,
            recipients,
            utxos,
            un_spendable,
            change_policy,
            manually_selected_only,
            fee_rate,
            fee_absolute,
            drain_wallet,
            drain_to,
            rbf,
            data,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__change_spend_policy_default(
        port_: i64,
    ) {
        wire__crate__api__types__change_spend_policy_default_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_full_scan_request_builder_build(
        port_: i64,
        that: *mut wire_cst_ffi_full_scan_request_builder,
    ) {
        wire__crate__api__types__ffi_full_scan_request_builder_build_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains(
        port_: i64,
        that: *mut wire_cst_ffi_full_scan_request_builder,
        inspector: *const std::ffi::c_void,
    ) {
        wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains_impl(
            port_, that, inspector,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_sync_request_builder_build(
        port_: i64,
        that: *mut wire_cst_ffi_sync_request_builder,
    ) {
        wire__crate__api__types__ffi_sync_request_builder_build_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__ffi_sync_request_builder_inspect_spks(
        port_: i64,
        that: *mut wire_cst_ffi_sync_request_builder,
        inspector: *const std::ffi::c_void,
    ) {
        wire__crate__api__types__ffi_sync_request_builder_inspect_spks_impl(port_, that, inspector)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__network_default(port_: i64) {
        wire__crate__api__types__network_default_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__sign_options_default(port_: i64) {
        wire__crate__api__types__sign_options_default_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_apply_update(
        port_: i64,
        that: *mut wire_cst_ffi_wallet,
        update: *mut wire_cst_ffi_update,
    ) {
        wire__crate__api__wallet__ffi_wallet_apply_update_impl(port_, that, update)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_calculate_fee(
        port_: i64,
        opaque: *mut wire_cst_ffi_wallet,
        tx: *mut wire_cst_ffi_transaction,
    ) {
        wire__crate__api__wallet__ffi_wallet_calculate_fee_impl(port_, opaque, tx)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_calculate_fee_rate(
        port_: i64,
        opaque: *mut wire_cst_ffi_wallet,
        tx: *mut wire_cst_ffi_transaction,
    ) {
        wire__crate__api__wallet__ffi_wallet_calculate_fee_rate_impl(port_, opaque, tx)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_get_balance(
        that: *mut wire_cst_ffi_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_get_balance_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_get_tx(
        port_: i64,
        that: *mut wire_cst_ffi_wallet,
        txid: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__wallet__ffi_wallet_get_tx_impl(port_, that, txid)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_is_mine(
        that: *mut wire_cst_ffi_wallet,
        script: *mut wire_cst_ffi_script_buf,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_is_mine_impl(that, script)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_list_output(
        port_: i64,
        that: *mut wire_cst_ffi_wallet,
    ) {
        wire__crate__api__wallet__ffi_wallet_list_output_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_list_unspent(
        that: *mut wire_cst_ffi_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_list_unspent_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_load(
        port_: i64,
        descriptor: *mut wire_cst_ffi_descriptor,
        change_descriptor: *mut wire_cst_ffi_descriptor,
        connection: *mut wire_cst_ffi_connection,
    ) {
        wire__crate__api__wallet__ffi_wallet_load_impl(
            port_,
            descriptor,
            change_descriptor,
            connection,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_network(
        that: *mut wire_cst_ffi_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_network_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_new(
        port_: i64,
        descriptor: *mut wire_cst_ffi_descriptor,
        change_descriptor: *mut wire_cst_ffi_descriptor,
        network: i32,
        connection: *mut wire_cst_ffi_connection,
    ) {
        wire__crate__api__wallet__ffi_wallet_new_impl(
            port_,
            descriptor,
            change_descriptor,
            network,
            connection,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_persist(
        port_: i64,
        opaque: *mut wire_cst_ffi_wallet,
        connection: *mut wire_cst_ffi_connection,
    ) {
        wire__crate__api__wallet__ffi_wallet_persist_impl(port_, opaque, connection)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_reveal_next_address(
        opaque: *mut wire_cst_ffi_wallet,
        keychain_kind: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_reveal_next_address_impl(opaque, keychain_kind)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_sign(
        port_: i64,
        opaque: *mut wire_cst_ffi_wallet,
        psbt: *mut wire_cst_ffi_psbt,
        sign_options: *mut wire_cst_sign_options,
    ) {
        wire__crate__api__wallet__ffi_wallet_sign_impl(port_, opaque, psbt, sign_options)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_start_full_scan(
        port_: i64,
        that: *mut wire_cst_ffi_wallet,
    ) {
        wire__crate__api__wallet__ffi_wallet_start_full_scan_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_start_sync_with_revealed_spks(
        port_: i64,
        that: *mut wire_cst_ffi_wallet,
    ) {
        wire__crate__api__wallet__ffi_wallet_start_sync_with_revealed_spks_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__ffi_wallet_transactions(
        that: *mut wire_cst_ffi_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__ffi_wallet_transactions_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_corebitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_core::bitcoin::Address>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_corebitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_core::bitcoin::Address>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_corebitcoinTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_core::bitcoin::Transaction>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_corebitcoinTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_core::bitcoin::Transaction>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_electrum :: BdkElectrumClient < bdk_electrum :: electrum_client :: Client >>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_electrum :: BdkElectrumClient < bdk_electrum :: electrum_client :: Client >>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_esplora::esplora_client::BlockingClient>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_esplora::esplora_client::BlockingClient>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletUpdate(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::Update>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletUpdate(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::Update>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::bitcoin::bip32::DerivationPath>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::bitcoin::bip32::DerivationPath>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::descriptor::ExtendedDescriptor>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::descriptor::ExtendedDescriptor>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::DescriptorPublicKey>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::DescriptorPublicKey>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::DescriptorSecretKey>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::DescriptorSecretKey>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysKeyMap(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::KeyMap>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysKeyMap(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::KeyMap>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::bip39::Mnemonic>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk_wallet::keys::bip39::Mnemonic>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
                >,
            >::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequestBuilder<bdk_wallet::KeychainKind>>,
                >,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
                >,
            >::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::FullScanRequest<bdk_wallet::KeychainKind>>,
                >,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<
                        bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>,
                    >,
                >,
            >::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<
                        bdk_core::spk_client::SyncRequestBuilder<(bdk_wallet::KeychainKind, u32)>,
                    >,
                >,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
                >,
            >::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                std::sync::Mutex<
                    Option<bdk_core::spk_client::SyncRequest<(bdk_wallet::KeychainKind, u32)>>,
                >,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>::increment_strong_count(
                ptr as _,
            );
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std::sync::Mutex<bdk_core::bitcoin::psbt::Psbt>>::decrement_strong_count(
                ptr as _,
            );
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk_wallet :: PersistedWallet < bdk_wallet :: rusqlite :: Connection > >>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk_wallet :: PersistedWallet < bdk_wallet :: rusqlite :: Connection > >>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>::increment_strong_count(
                ptr as _,
            );
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std::sync::Mutex<bdk_wallet::rusqlite::Connection>>::decrement_strong_count(
                ptr as _,
            );
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_confirmation_block_time(
    ) -> *mut wire_cst_confirmation_block_time {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_confirmation_block_time::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_fee_rate() -> *mut wire_cst_fee_rate {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_fee_rate::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_address(
    ) -> *mut wire_cst_ffi_address {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_address::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_canonical_tx(
    ) -> *mut wire_cst_ffi_canonical_tx {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_canonical_tx::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_connection(
    ) -> *mut wire_cst_ffi_connection {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_connection::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_derivation_path(
    ) -> *mut wire_cst_ffi_derivation_path {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_derivation_path::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor(
    ) -> *mut wire_cst_ffi_descriptor {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_descriptor::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor_public_key(
    ) -> *mut wire_cst_ffi_descriptor_public_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_descriptor_public_key::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_descriptor_secret_key(
    ) -> *mut wire_cst_ffi_descriptor_secret_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_descriptor_secret_key::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_electrum_client(
    ) -> *mut wire_cst_ffi_electrum_client {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_electrum_client::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_esplora_client(
    ) -> *mut wire_cst_ffi_esplora_client {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_esplora_client::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_full_scan_request(
    ) -> *mut wire_cst_ffi_full_scan_request {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_full_scan_request::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_full_scan_request_builder(
    ) -> *mut wire_cst_ffi_full_scan_request_builder {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_full_scan_request_builder::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_mnemonic(
    ) -> *mut wire_cst_ffi_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_mnemonic::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_psbt() -> *mut wire_cst_ffi_psbt {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_ffi_psbt::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_script_buf(
    ) -> *mut wire_cst_ffi_script_buf {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_script_buf::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_sync_request(
    ) -> *mut wire_cst_ffi_sync_request {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_sync_request::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_sync_request_builder(
    ) -> *mut wire_cst_ffi_sync_request_builder {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_sync_request_builder::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_transaction(
    ) -> *mut wire_cst_ffi_transaction {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_transaction::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_update() -> *mut wire_cst_ffi_update
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_update::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_ffi_wallet() -> *mut wire_cst_ffi_wallet
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_wallet::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_lock_time() -> *mut wire_cst_lock_time
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_lock_time::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_rbf_value() -> *mut wire_cst_rbf_value
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_rbf_value::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_sign_options(
    ) -> *mut wire_cst_sign_options {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sign_options::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_ffi_canonical_tx(
        len: i32,
    ) -> *mut wire_cst_list_ffi_canonical_tx {
        let wrap = wire_cst_list_ffi_canonical_tx {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_ffi_canonical_tx>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_local_output(
        len: i32,
    ) -> *mut wire_cst_list_local_output {
        let wrap = wire_cst_list_local_output {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_local_output>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_out_point(
        len: i32,
    ) -> *mut wire_cst_list_out_point {
        let wrap = wire_cst_list_out_point {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_out_point>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_record_ffi_script_buf_u_64(
        len: i32,
    ) -> *mut wire_cst_list_record_ffi_script_buf_u_64 {
        let wrap = wire_cst_list_record_ffi_script_buf_u_64 {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_ffi_script_buf_u_64>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
        let wrap = wire_cst_list_tx_in {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_in>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_out(
        len: i32,
    ) -> *mut wire_cst_list_tx_out {
        let wrap = wire_cst_list_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_info {
        index: u32,
        address: wire_cst_ffi_address,
        keychain: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_parse_error {
        tag: i32,
        kind: AddressParseErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union AddressParseErrorKind {
        WitnessVersion: wire_cst_AddressParseError_WitnessVersion,
        WitnessProgram: wire_cst_AddressParseError_WitnessProgram,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressParseError_WitnessVersion {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressParseError_WitnessProgram {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance {
        immature: u64,
        trusted_pending: u64,
        untrusted_pending: u64,
        confirmed: u64,
        spendable: u64,
        total: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bip_32_error {
        tag: i32,
        kind: Bip32ErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union Bip32ErrorKind {
        Secp256k1: wire_cst_Bip32Error_Secp256k1,
        InvalidChildNumber: wire_cst_Bip32Error_InvalidChildNumber,
        UnknownVersion: wire_cst_Bip32Error_UnknownVersion,
        WrongExtendedKeyLength: wire_cst_Bip32Error_WrongExtendedKeyLength,
        Base58: wire_cst_Bip32Error_Base58,
        Hex: wire_cst_Bip32Error_Hex,
        InvalidPublicKeyHexLength: wire_cst_Bip32Error_InvalidPublicKeyHexLength,
        UnknownError: wire_cst_Bip32Error_UnknownError,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_Secp256k1 {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_InvalidChildNumber {
        child_number: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_UnknownVersion {
        version: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_WrongExtendedKeyLength {
        length: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_Base58 {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_Hex {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_InvalidPublicKeyHexLength {
        length: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip32Error_UnknownError {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bip_39_error {
        tag: i32,
        kind: Bip39ErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union Bip39ErrorKind {
        BadWordCount: wire_cst_Bip39Error_BadWordCount,
        UnknownWord: wire_cst_Bip39Error_UnknownWord,
        BadEntropyBitCount: wire_cst_Bip39Error_BadEntropyBitCount,
        AmbiguousLanguages: wire_cst_Bip39Error_AmbiguousLanguages,
        Generic: wire_cst_Bip39Error_Generic,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip39Error_BadWordCount {
        word_count: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip39Error_UnknownWord {
        index: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip39Error_BadEntropyBitCount {
        bit_count: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip39Error_AmbiguousLanguages {
        languages: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bip39Error_Generic {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_block_id {
        height: u32,
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_calculate_fee_error {
        tag: i32,
        kind: CalculateFeeErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CalculateFeeErrorKind {
        Generic: wire_cst_CalculateFeeError_Generic,
        MissingTxOut: wire_cst_CalculateFeeError_MissingTxOut,
        NegativeFee: wire_cst_CalculateFeeError_NegativeFee,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CalculateFeeError_Generic {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CalculateFeeError_MissingTxOut {
        out_points: *mut wire_cst_list_out_point,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CalculateFeeError_NegativeFee {
        amount: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_cannot_connect_error {
        tag: i32,
        kind: CannotConnectErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CannotConnectErrorKind {
        Include: wire_cst_CannotConnectError_Include,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CannotConnectError_Include {
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_position {
        tag: i32,
        kind: ChainPositionKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ChainPositionKind {
        Confirmed: wire_cst_ChainPosition_Confirmed,
        Unconfirmed: wire_cst_ChainPosition_Unconfirmed,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainPosition_Confirmed {
        confirmation_block_time: *mut wire_cst_confirmation_block_time,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainPosition_Unconfirmed {
        timestamp: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_confirmation_block_time {
        block_id: wire_cst_block_id,
        confirmation_time: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_create_tx_error {
        tag: i32,
        kind: CreateTxErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CreateTxErrorKind {
        TransactionNotFound: wire_cst_CreateTxError_TransactionNotFound,
        TransactionConfirmed: wire_cst_CreateTxError_TransactionConfirmed,
        IrreplaceableTransaction: wire_cst_CreateTxError_IrreplaceableTransaction,
        Generic: wire_cst_CreateTxError_Generic,
        Descriptor: wire_cst_CreateTxError_Descriptor,
        Policy: wire_cst_CreateTxError_Policy,
        SpendingPolicyRequired: wire_cst_CreateTxError_SpendingPolicyRequired,
        LockTime: wire_cst_CreateTxError_LockTime,
        RbfSequenceCsv: wire_cst_CreateTxError_RbfSequenceCsv,
        FeeTooLow: wire_cst_CreateTxError_FeeTooLow,
        FeeRateTooLow: wire_cst_CreateTxError_FeeRateTooLow,
        OutputBelowDustLimit: wire_cst_CreateTxError_OutputBelowDustLimit,
        CoinSelection: wire_cst_CreateTxError_CoinSelection,
        InsufficientFunds: wire_cst_CreateTxError_InsufficientFunds,
        Psbt: wire_cst_CreateTxError_Psbt,
        MissingKeyOrigin: wire_cst_CreateTxError_MissingKeyOrigin,
        UnknownUtxo: wire_cst_CreateTxError_UnknownUtxo,
        MissingNonWitnessUtxo: wire_cst_CreateTxError_MissingNonWitnessUtxo,
        MiniscriptPsbt: wire_cst_CreateTxError_MiniscriptPsbt,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_TransactionNotFound {
        txid: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_TransactionConfirmed {
        txid: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_IrreplaceableTransaction {
        txid: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_Generic {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_Descriptor {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_Policy {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_SpendingPolicyRequired {
        kind: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_LockTime {
        requested_time: *mut wire_cst_list_prim_u_8_strict,
        required_time: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_RbfSequenceCsv {
        rbf: *mut wire_cst_list_prim_u_8_strict,
        csv: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_FeeTooLow {
        fee_required: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_FeeRateTooLow {
        fee_rate_required: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_OutputBelowDustLimit {
        index: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_CoinSelection {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_InsufficientFunds {
        needed: u64,
        available: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_Psbt {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_MissingKeyOrigin {
        key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_UnknownUtxo {
        outpoint: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_MissingNonWitnessUtxo {
        outpoint: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateTxError_MiniscriptPsbt {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_create_with_persist_error {
        tag: i32,
        kind: CreateWithPersistErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CreateWithPersistErrorKind {
        Persist: wire_cst_CreateWithPersistError_Persist,
        Descriptor: wire_cst_CreateWithPersistError_Descriptor,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateWithPersistError_Persist {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CreateWithPersistError_Descriptor {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_descriptor_error {
        tag: i32,
        kind: DescriptorErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union DescriptorErrorKind {
        Key: wire_cst_DescriptorError_Key,
        Generic: wire_cst_DescriptorError_Generic,
        Policy: wire_cst_DescriptorError_Policy,
        InvalidDescriptorCharacter: wire_cst_DescriptorError_InvalidDescriptorCharacter,
        Bip32: wire_cst_DescriptorError_Bip32,
        Base58: wire_cst_DescriptorError_Base58,
        Pk: wire_cst_DescriptorError_Pk,
        Miniscript: wire_cst_DescriptorError_Miniscript,
        Hex: wire_cst_DescriptorError_Hex,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Key {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Generic {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Policy {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_InvalidDescriptorCharacter {
        charector: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Bip32 {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Base58 {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Pk {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Miniscript {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Hex {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_descriptor_key_error {
        tag: i32,
        kind: DescriptorKeyErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union DescriptorKeyErrorKind {
        Parse: wire_cst_DescriptorKeyError_Parse,
        Bip32: wire_cst_DescriptorKeyError_Bip32,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorKeyError_Parse {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorKeyError_Bip32 {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_electrum_error {
        tag: i32,
        kind: ElectrumErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ElectrumErrorKind {
        IOError: wire_cst_ElectrumError_IOError,
        Json: wire_cst_ElectrumError_Json,
        Hex: wire_cst_ElectrumError_Hex,
        Protocol: wire_cst_ElectrumError_Protocol,
        Bitcoin: wire_cst_ElectrumError_Bitcoin,
        InvalidResponse: wire_cst_ElectrumError_InvalidResponse,
        Message: wire_cst_ElectrumError_Message,
        InvalidDNSNameError: wire_cst_ElectrumError_InvalidDNSNameError,
        SharedIOError: wire_cst_ElectrumError_SharedIOError,
        CouldNotCreateConnection: wire_cst_ElectrumError_CouldNotCreateConnection,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_IOError {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_Json {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_Hex {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_Protocol {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_Bitcoin {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_InvalidResponse {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_Message {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_InvalidDNSNameError {
        domain: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_SharedIOError {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ElectrumError_CouldNotCreateConnection {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_esplora_error {
        tag: i32,
        kind: EsploraErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EsploraErrorKind {
        Minreq: wire_cst_EsploraError_Minreq,
        HttpResponse: wire_cst_EsploraError_HttpResponse,
        Parsing: wire_cst_EsploraError_Parsing,
        StatusCode: wire_cst_EsploraError_StatusCode,
        BitcoinEncoding: wire_cst_EsploraError_BitcoinEncoding,
        HexToArray: wire_cst_EsploraError_HexToArray,
        HexToBytes: wire_cst_EsploraError_HexToBytes,
        HeaderHeightNotFound: wire_cst_EsploraError_HeaderHeightNotFound,
        InvalidHttpHeaderName: wire_cst_EsploraError_InvalidHttpHeaderName,
        InvalidHttpHeaderValue: wire_cst_EsploraError_InvalidHttpHeaderValue,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_Minreq {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_HttpResponse {
        status: u16,
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_Parsing {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_StatusCode {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_BitcoinEncoding {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_HexToArray {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_HexToBytes {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_HeaderHeightNotFound {
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_InvalidHttpHeaderName {
        name: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EsploraError_InvalidHttpHeaderValue {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_extract_tx_error {
        tag: i32,
        kind: ExtractTxErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ExtractTxErrorKind {
        AbsurdFeeRate: wire_cst_ExtractTxError_AbsurdFeeRate,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ExtractTxError_AbsurdFeeRate {
        fee_rate: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_fee_rate {
        sat_kwu: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_address {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_canonical_tx {
        transaction: wire_cst_ffi_transaction,
        chain_position: wire_cst_chain_position,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_connection {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_derivation_path {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_descriptor {
        extended_descriptor: usize,
        key_map: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_descriptor_public_key {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_descriptor_secret_key {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_electrum_client {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_esplora_client {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_full_scan_request {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_full_scan_request_builder {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_mnemonic {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_psbt {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_script_buf {
        bytes: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_sync_request {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_sync_request_builder {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_transaction {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_update {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_wallet {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_from_script_error {
        tag: i32,
        kind: FromScriptErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union FromScriptErrorKind {
        WitnessProgram: wire_cst_FromScriptError_WitnessProgram,
        WitnessVersion: wire_cst_FromScriptError_WitnessVersion,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_FromScriptError_WitnessProgram {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_FromScriptError_WitnessVersion {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_ffi_canonical_tx {
        ptr: *mut wire_cst_ffi_canonical_tx,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_local_output {
        ptr: *mut wire_cst_local_output,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_out_point {
        ptr: *mut wire_cst_out_point,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_ffi_script_buf_u_64 {
        ptr: *mut wire_cst_record_ffi_script_buf_u_64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_in {
        ptr: *mut wire_cst_tx_in,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_out {
        ptr: *mut wire_cst_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_load_with_persist_error {
        tag: i32,
        kind: LoadWithPersistErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union LoadWithPersistErrorKind {
        Persist: wire_cst_LoadWithPersistError_Persist,
        InvalidChangeSet: wire_cst_LoadWithPersistError_InvalidChangeSet,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LoadWithPersistError_Persist {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LoadWithPersistError_InvalidChangeSet {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_local_output {
        outpoint: wire_cst_out_point,
        txout: wire_cst_tx_out,
        keychain: i32,
        is_spent: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lock_time {
        tag: i32,
        kind: LockTimeKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union LockTimeKind {
        Blocks: wire_cst_LockTime_Blocks,
        Seconds: wire_cst_LockTime_Seconds,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LockTime_Blocks {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LockTime_Seconds {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: *mut wire_cst_list_prim_u_8_strict,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt_error {
        tag: i32,
        kind: PsbtErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PsbtErrorKind {
        InvalidKey: wire_cst_PsbtError_InvalidKey,
        DuplicateKey: wire_cst_PsbtError_DuplicateKey,
        NonStandardSighashType: wire_cst_PsbtError_NonStandardSighashType,
        InvalidHash: wire_cst_PsbtError_InvalidHash,
        CombineInconsistentKeySources: wire_cst_PsbtError_CombineInconsistentKeySources,
        ConsensusEncoding: wire_cst_PsbtError_ConsensusEncoding,
        InvalidPublicKey: wire_cst_PsbtError_InvalidPublicKey,
        InvalidSecp256k1PublicKey: wire_cst_PsbtError_InvalidSecp256k1PublicKey,
        InvalidEcdsaSignature: wire_cst_PsbtError_InvalidEcdsaSignature,
        InvalidTaprootSignature: wire_cst_PsbtError_InvalidTaprootSignature,
        TapTree: wire_cst_PsbtError_TapTree,
        Version: wire_cst_PsbtError_Version,
        Io: wire_cst_PsbtError_Io,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidKey {
        key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_DuplicateKey {
        key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_NonStandardSighashType {
        sighash: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidHash {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_CombineInconsistentKeySources {
        xpub: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_ConsensusEncoding {
        encoding_error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidPublicKey {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidSecp256k1PublicKey {
        secp256k1_error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidEcdsaSignature {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_InvalidTaprootSignature {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_TapTree {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_Version {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtError_Io {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt_parse_error {
        tag: i32,
        kind: PsbtParseErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PsbtParseErrorKind {
        PsbtEncoding: wire_cst_PsbtParseError_PsbtEncoding,
        Base64Encoding: wire_cst_PsbtParseError_Base64Encoding,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtParseError_PsbtEncoding {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PsbtParseError_Base64Encoding {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_rbf_value {
        tag: i32,
        kind: RbfValueKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union RbfValueKind {
        Value: wire_cst_RbfValue_Value,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_RbfValue_Value {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_ffi_script_buf_u_64 {
        field0: wire_cst_ffi_script_buf,
        field1: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sign_options {
        trust_witness_utxo: bool,
        assume_height: *mut u32,
        allow_all_sighashes: bool,
        try_finalize: bool,
        sign_with_tap_internal_key: bool,
        allow_grinding: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_signer_error {
        tag: i32,
        kind: SignerErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union SignerErrorKind {
        SighashP2wpkh: wire_cst_SignerError_SighashP2wpkh,
        SighashTaproot: wire_cst_SignerError_SighashTaproot,
        TxInputsIndexError: wire_cst_SignerError_TxInputsIndexError,
        MiniscriptPsbt: wire_cst_SignerError_MiniscriptPsbt,
        External: wire_cst_SignerError_External,
        Psbt: wire_cst_SignerError_Psbt,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_SighashP2wpkh {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_SighashTaproot {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_TxInputsIndexError {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_MiniscriptPsbt {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_External {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SignerError_Psbt {
        error_message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sqlite_error {
        tag: i32,
        kind: SqliteErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union SqliteErrorKind {
        Sqlite: wire_cst_SqliteError_Sqlite,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SqliteError_Sqlite {
        rusqlite_error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sync_progress {
        spks_consumed: u64,
        spks_remaining: u64,
        txids_consumed: u64,
        txids_remaining: u64,
        outpoints_consumed: u64,
        outpoints_remaining: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_transaction_error {
        tag: i32,
        kind: TransactionErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union TransactionErrorKind {
        InvalidChecksum: wire_cst_TransactionError_InvalidChecksum,
        UnsupportedSegwitFlag: wire_cst_TransactionError_UnsupportedSegwitFlag,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TransactionError_InvalidChecksum {
        expected: *mut wire_cst_list_prim_u_8_strict,
        actual: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TransactionError_UnsupportedSegwitFlag {
        flag: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_in {
        previous_output: wire_cst_out_point,
        script_sig: wire_cst_ffi_script_buf,
        sequence: u32,
        witness: *mut wire_cst_list_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out {
        value: u64,
        script_pubkey: wire_cst_ffi_script_buf,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_txid_parse_error {
        tag: i32,
        kind: TxidParseErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union TxidParseErrorKind {
        InvalidTxid: wire_cst_TxidParseError_InvalidTxid,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TxidParseError_InvalidTxid {
        txid: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
