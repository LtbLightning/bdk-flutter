// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1986252746;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__types__bdk_address_as_string_impl(
    that: impl CstDecode<crate::api::types::BdkAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkAddress::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_from_script_impl(
    script: impl CstDecode<crate::api::types::BdkScriptBuf>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_from_script",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_script = script.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::types::BdkAddress::from_script(api_script, api_network)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_from_string_impl(
    address: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_address = address.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::types::BdkAddress::from_string(api_address, api_network)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_is_valid_for_network_impl(
    that: impl CstDecode<crate::api::types::BdkAddress>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_is_valid_for_network",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::types::BdkAddress::is_valid_for_network(&api_that, api_network),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_network_impl(
    that: impl CstDecode<crate::api::types::BdkAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_network",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkAddress::network(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_payload_impl(
    that: impl CstDecode<crate::api::types::BdkAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_payload",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkAddress::payload(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_script_impl(
    ptr: impl CstDecode<crate::api::types::BdkAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_script",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkAddress::script(api_ptr))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_address_to_qr_uri_impl(
    that: impl CstDecode<crate::api::types::BdkAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_address_to_qr_uri",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkAddress::to_qr_uri(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__blockchain__bdk_blockchain_broadcast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::blockchain::BdkBlockchain>,
    transaction: impl CstDecode<crate::api::types::BdkTransaction>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_blockchain_broadcast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_transaction = transaction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::blockchain::BdkBlockchain::broadcast(
                        api_ptr,
                        &api_transaction,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__bdk_blockchain_create_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    blockchain_config: impl CstDecode<crate::api::blockchain::BlockchainConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_blockchain_create",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_blockchain_config = blockchain_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok =
                        crate::api::blockchain::BdkBlockchain::create(api_blockchain_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__bdk_blockchain_estimate_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::blockchain::BdkBlockchain>,
    target: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_blockchain_estimate_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_target = target.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok =
                        crate::api::blockchain::BdkBlockchain::estimate_fee(&api_that, api_target)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__bdk_blockchain_get_block_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::blockchain::BdkBlockchain>,
    height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_blockchain_get_block_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_height = height.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::blockchain::BdkBlockchain::get_block_hash(
                        &api_that, api_height,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__bdk_blockchain_get_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::blockchain::BdkBlockchain>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_blockchain_get_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::blockchain::BdkBlockchain::get_height(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__bdk_derivation_path_as_string_impl(
    that: impl CstDecode<crate::api::key::BdkDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_derivation_path_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::key::BdkDerivationPath::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_derivation_path_from_string_impl(
    path: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_derivation_path_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDerivationPath::from_string(api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_as_string_impl(
    that: impl CstDecode<crate::api::descriptor::BdkDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::descriptor::BdkDescriptor::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_create_impl(
    descriptor: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_create",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_descriptor = descriptor.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::descriptor::BdkDescriptor::create(api_descriptor, api_network)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_max_satisfaction_weight_impl(
    that: impl CstDecode<crate::api::descriptor::BdkDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_max_satisfaction_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::descriptor::BdkDescriptor::max_satisfaction_weight(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip44_impl(
    secret_key: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip44",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip44(
                    api_secret_key,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip44_public_impl(
    public_key: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip44_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip44_public(
                    api_public_key,
                    api_fingerprint,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip49_impl(
    secret_key: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip49",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip49(
                    api_secret_key,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip49_public_impl(
    public_key: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip49_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip49_public(
                    api_public_key,
                    api_fingerprint,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip84_impl(
    secret_key: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip84",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip84(
                    api_secret_key,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip84_public_impl(
    public_key: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip84_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip84_public(
                    api_public_key,
                    api_fingerprint,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip86_impl(
    secret_key: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip86",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip86(
                    api_secret_key,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_new_bip86_public_impl(
    public_key: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    fingerprint: impl CstDecode<String>,
    keychain_kind: impl CstDecode<crate::api::types::KeychainKind>,
    network: impl CstDecode<crate::api::types::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_new_bip86_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            let api_fingerprint = fingerprint.cst_decode();
            let api_keychain_kind = keychain_kind.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::descriptor::BdkDescriptor::new_bip86_public(
                    api_public_key,
                    api_fingerprint,
                    api_keychain_kind,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_public_key_as_string_impl(
    that: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_public_key_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::key::BdkDescriptorPublicKey::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_public_key_derive_impl(
    ptr: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    path: impl CstDecode<crate::api::key::BdkDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_public_key_derive",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorPublicKey::derive(api_ptr, api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_public_key_extend_impl(
    ptr: impl CstDecode<crate::api::key::BdkDescriptorPublicKey>,
    path: impl CstDecode<crate::api::key::BdkDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_public_key_extend",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorPublicKey::extend(api_ptr, api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_public_key_from_string_impl(
    public_key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_public_key_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_public_key = public_key.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::key::BdkDescriptorPublicKey::from_string(api_public_key)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_as_public_impl(
    ptr: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_as_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorSecretKey::as_public(api_ptr)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_as_string_impl(
    that: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::key::BdkDescriptorSecretKey::as_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_create_impl(
    network: impl CstDecode<crate::api::types::Network>,
    mnemonic: impl CstDecode<crate::api::key::BdkMnemonic>,
    password: impl CstDecode<Option<String>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_create",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_network = network.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            let api_password = password.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorSecretKey::create(
                    api_network,
                    api_mnemonic,
                    api_password,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_derive_impl(
    ptr: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    path: impl CstDecode<crate::api::key::BdkDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_derive",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorSecretKey::derive(api_ptr, api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_extend_impl(
    ptr: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
    path: impl CstDecode<crate::api::key::BdkDerivationPath>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_extend",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorSecretKey::extend(api_ptr, api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok =
                        crate::api::key::BdkDescriptorSecretKey::from_string(api_secret_key)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__key__bdk_descriptor_secret_key_secret_bytes_impl(
    that: impl CstDecode<crate::api::key::BdkDescriptorSecretKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_secret_key_secret_bytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkDescriptorSecretKey::secret_bytes(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__descriptor__bdk_descriptor_to_string_private_impl(
    that: impl CstDecode<crate::api::descriptor::BdkDescriptor>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_descriptor_to_string_private",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::descriptor::BdkDescriptor::to_string_private(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_mnemonic_as_string_impl(
    that: impl CstDecode<crate::api::key::BdkMnemonic>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_mnemonic_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::key::BdkMnemonic::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_mnemonic_create_impl(
    word_count: impl CstDecode<crate::api::types::WordCount>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_mnemonic_create",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_word_count = word_count.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkMnemonic::create(api_word_count)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_mnemonic_from_entropy_impl(
    entropy: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_mnemonic_from_entropy",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_entropy = entropy.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkMnemonic::from_entropy(api_entropy)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__key__bdk_mnemonic_from_string_impl(
    mnemonic: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_mnemonic_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::key::BdkMnemonic::from_string(api_mnemonic)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_as_string_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkPolicy::as_string(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_contribution_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_contribution",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkPolicy::contribution(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_id_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::types::BdkPolicy::id(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_item_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_item",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::types::BdkPolicy::item(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_requires_path_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_requires_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkPolicy::requires_path(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_policy_satisfaction_impl(
    that: impl CstDecode<crate::api::types::BdkPolicy>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_policy_satisfaction",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkPolicy::satisfaction(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_as_string_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::as_string(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_combine_impl(
    ptr: impl CstDecode<crate::api::psbt::BdkPsbt>,
    other: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_combine",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::combine(api_ptr, api_other)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_extract_tx_impl(
    ptr: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_extract_tx",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::extract_tx(api_ptr)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_fee_amount_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_fee_amount",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::fee_amount(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_fee_rate_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_fee_rate",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::fee_rate(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_from_str_impl(
    psbt_base64: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_from_str",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_psbt_base64 = psbt_base64.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::from_str(api_psbt_base64)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_json_serialize_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_json_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::json_serialize(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_serialize_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::serialize(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__psbt__bdk_psbt_txid_impl(
    that: impl CstDecode<crate::api::psbt::BdkPsbt>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_psbt_txid",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::psbt::BdkPsbt::txid(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_script_buf_as_string_impl(
    that: impl CstDecode<crate::api::types::BdkScriptBuf>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_script_buf_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::BdkScriptBuf::as_string(&api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_script_buf_empty_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_script_buf_empty",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::types::BdkScriptBuf::empty())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_script_buf_from_hex_impl(
    s: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_script_buf_from_hex",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_s = s.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkScriptBuf::from_hex(api_s)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_script_buf_with_capacity_impl(
    capacity: impl CstDecode<usize>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_script_buf_with_capacity",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_capacity = capacity.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::types::BdkScriptBuf::with_capacity(api_capacity),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_create_impl(
    version: impl CstDecode<i32>,
    lock_time: impl CstDecode<crate::api::types::LockTime>,
    input: impl CstDecode<Vec<crate::api::types::BdkTxIn>>,
    output: impl CstDecode<Vec<crate::api::types::BdkTxOut>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_create",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_version = version.cst_decode();
            let api_lock_time = lock_time.cst_decode();
            let api_input = input.cst_decode();
            let api_output = output.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::create(
                    api_version,
                    api_lock_time,
                    api_input,
                    api_output,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_from_bytes_impl(
    transaction_bytes: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_from_bytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_transaction_bytes = transaction_bytes.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::types::BdkTransaction::from_bytes(api_transaction_bytes)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_input_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_input",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::input(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_is_coin_base_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_is_coin_base",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::is_coin_base(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_is_explicitly_rbf_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_is_explicitly_rbf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::is_explicitly_rbf(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_is_lock_time_enabled_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_is_lock_time_enabled",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::is_lock_time_enabled(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_lock_time_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_lock_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::lock_time(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_output_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_output",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::output(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_serialize_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_serialize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::serialize(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_size_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_size",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::size(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_txid_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_txid",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::txid(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_version_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_version",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::version(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_vsize_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_vsize",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::vsize(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__types__bdk_transaction_weight_impl(
    that: impl CstDecode<crate::api::types::BdkTransaction>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_transaction_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::types::BdkTransaction::weight(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_create_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: impl CstDecode<crate::api::descriptor::BdkDescriptor>,
    change_descriptor: impl CstDecode<Option<crate::api::descriptor::BdkDescriptor>>,
    network: impl CstDecode<crate::api::types::Network>,
    database_config: impl CstDecode<crate::api::types::DatabaseConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_create",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.cst_decode();
            let api_change_descriptor = change_descriptor.cst_decode();
            let api_network = network.cst_decode();
            let api_database_config = database_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::wallet::BdkWallet::create(
                        api_descriptor,
                        api_change_descriptor,
                        api_network,
                        api_database_config,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_get_address_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    address_index: impl CstDecode<crate::api::types::AddressIndex>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_get_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_address_index = address_index.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::wallet::BdkWallet::get_address(api_ptr, api_address_index)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_get_balance_impl(
    that: impl CstDecode<crate::api::wallet::BdkWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_get_balance",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::get_balance(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_get_descriptor_for_keychain_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    keychain: impl CstDecode<crate::api::types::KeychainKind>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_get_descriptor_for_keychain",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_keychain = keychain.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::get_descriptor_for_keychain(
                    api_ptr,
                    api_keychain,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_get_internal_address_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    address_index: impl CstDecode<crate::api::types::AddressIndex>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_get_internal_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_address_index = address_index.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::get_internal_address(
                    api_ptr,
                    api_address_index,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_get_psbt_input_impl(
    that: impl CstDecode<crate::api::wallet::BdkWallet>,
    utxo: impl CstDecode<crate::api::types::LocalUtxo>,
    only_witness_utxo: impl CstDecode<bool>,
    sighash_type: impl CstDecode<Option<crate::api::types::PsbtSigHashType>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_get_psbt_input",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_utxo = utxo.cst_decode();
            let api_only_witness_utxo = only_witness_utxo.cst_decode();
            let api_sighash_type = sighash_type.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::get_psbt_input(
                    &api_that,
                    api_utxo,
                    api_only_witness_utxo,
                    api_sighash_type,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_is_mine_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    script: impl CstDecode<crate::api::types::BdkScriptBuf>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_is_mine",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_script = script.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::is_mine(api_ptr, api_script)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_list_transactions_impl(
    that: impl CstDecode<crate::api::wallet::BdkWallet>,
    include_raw: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_list_transactions",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_include_raw = include_raw.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::wallet::BdkWallet::list_transactions(&api_that, api_include_raw)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_list_unspent_impl(
    that: impl CstDecode<crate::api::wallet::BdkWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_list_unspent",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::list_unspent(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_network_impl(
    that: impl CstDecode<crate::api::wallet::BdkWallet>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_network",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::network(&api_that)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_policies_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    keychain: impl CstDecode<crate::api::types::KeychainKind>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_policies",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_keychain = keychain.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok = crate::api::wallet::BdkWallet::policies(api_ptr, api_keychain)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_sign_impl(
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    psbt: impl CstDecode<crate::api::psbt::BdkPsbt>,
    sign_options: impl CstDecode<Option<crate::api::types::SignOptions>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_sign",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_psbt = psbt.cst_decode();
            let api_sign_options = sign_options.cst_decode();
            transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                let output_ok =
                    crate::api::wallet::BdkWallet::sign(api_ptr, api_psbt, api_sign_options)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__wallet__bdk_wallet_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::wallet::BdkWallet>,
    blockchain: impl CstDecode<crate::api::blockchain::BdkBlockchain>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bdk_wallet_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            let api_blockchain = blockchain.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::wallet::BdkWallet::sync(api_ptr, &api_blockchain)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__finish_bump_fee_tx_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    txid: impl CstDecode<String>,
    fee_rate: impl CstDecode<f32>,
    allow_shrinking: impl CstDecode<Option<crate::api::types::BdkAddress>>,
    wallet: impl CstDecode<crate::api::wallet::BdkWallet>,
    enable_rbf: impl CstDecode<bool>,
    n_sequence: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "finish_bump_fee_tx_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_txid = txid.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_allow_shrinking = allow_shrinking.cst_decode();
            let api_wallet = wallet.cst_decode();
            let api_enable_rbf = enable_rbf.cst_decode();
            let api_n_sequence = n_sequence.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::wallet::finish_bump_fee_tx_builder(
                        api_txid,
                        api_fee_rate,
                        api_allow_shrinking,
                        api_wallet,
                        api_enable_rbf,
                        api_n_sequence,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__network_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "network_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::Network::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__sign_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::SignOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet: impl CstDecode<crate::api::wallet::BdkWallet>,
    recipients: impl CstDecode<Vec<crate::api::types::ScriptAmount>>,
    utxos: impl CstDecode<Vec<crate::api::types::OutPoint>>,
    foreign_utxo: impl CstDecode<Option<(crate::api::types::OutPoint, crate::api::types::Input, usize)>>,
    un_spendable: impl CstDecode<Vec<crate::api::types::OutPoint>>,
    change_policy: impl CstDecode<crate::api::types::ChangeSpendPolicy>,
    manually_selected_only: impl CstDecode<bool>,
    fee_rate: impl CstDecode<Option<f32>>,
    fee_absolute: impl CstDecode<Option<u64>>,
    drain_wallet: impl CstDecode<bool>,
    drain_to: impl CstDecode<Option<crate::api::types::BdkScriptBuf>>,
    rbf: impl CstDecode<Option<crate::api::types::RbfValue>>,
    internal_policy_path: impl CstDecode<Option<std::collections::HashMap<String, Vec<u32>>>>,
    external_policy_path: impl CstDecode<Option<std::collections::HashMap<String, Vec<u32>>>>,
    data: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.cst_decode();
            let api_recipients = recipients.cst_decode();
            let api_utxos = utxos.cst_decode();
            let api_foreign_utxo = foreign_utxo.cst_decode();
            let api_un_spendable = un_spendable.cst_decode();
            let api_change_policy = change_policy.cst_decode();
            let api_manually_selected_only = manually_selected_only.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_fee_absolute = fee_absolute.cst_decode();
            let api_drain_wallet = drain_wallet.cst_decode();
            let api_drain_to = drain_to.cst_decode();
            let api_rbf = rbf.cst_decode();
            let api_internal_policy_path = internal_policy_path.cst_decode();
            let api_external_policy_path = external_policy_path.cst_decode();
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BdkError>((move || {
                    let output_ok = crate::api::wallet::tx_builder_finish(
                        api_wallet,
                        api_recipients,
                        api_utxos,
                        api_foreign_utxo,
                        api_un_spendable,
                        api_change_policy,
                        api_manually_selected_only,
                        api_fee_rate,
                        api_fee_absolute,
                        api_drain_wallet,
                        api_drain_to,
                        api_rbf,
                        api_internal_policy_path,
                        api_external_policy_path,
                        api_data,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::types::ChangeSpendPolicy> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ChangeSpendPolicy {
        match self {
            0 => crate::api::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::api::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::api::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", self),
        }
    }
}
impl CstDecode<f32> for f32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f32 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::KeychainKind> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::KeychainKind {
        match self {
            0 => crate::api::types::KeychainKind::ExternalChain,
            1 => crate::api::types::KeychainKind::InternalChain,
            _ => unreachable!("Invalid variant for KeychainKind: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Testnet,
            1 => crate::api::types::Network::Regtest,
            2 => crate::api::types::Network::Bitcoin,
            3 => crate::api::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl CstDecode<crate::api::types::Variant> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Variant {
        match self {
            0 => crate::api::types::Variant::Bech32,
            1 => crate::api::types::Variant::Bech32m,
            _ => unreachable!("Invalid variant for Variant: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::WitnessVersion> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::WitnessVersion {
        match self {
            0 => crate::api::types::WitnessVersion::V0,
            1 => crate::api::types::WitnessVersion::V1,
            2 => crate::api::types::WitnessVersion::V2,
            3 => crate::api::types::WitnessVersion::V3,
            4 => crate::api::types::WitnessVersion::V4,
            5 => crate::api::types::WitnessVersion::V5,
            6 => crate::api::types::WitnessVersion::V6,
            7 => crate::api::types::WitnessVersion::V7,
            8 => crate::api::types::WitnessVersion::V8,
            9 => crate::api::types::WitnessVersion::V9,
            10 => crate::api::types::WitnessVersion::V10,
            11 => crate::api::types::WitnessVersion::V11,
            12 => crate::api::types::WitnessVersion::V12,
            13 => crate::api::types::WitnessVersion::V13,
            14 => crate::api::types::WitnessVersion::V14,
            15 => crate::api::types::WitnessVersion::V15,
            16 => crate::api::types::WitnessVersion::V16,
            _ => unreachable!("Invalid variant for WitnessVersion: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::WordCount> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::WordCount {
        match self {
            0 => crate::api::types::WordCount::Words12,
            1 => crate::api::types::WordCount::Words18,
            2 => crate::api::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", self),
        }
    }
}
impl SseDecode for std::collections::HashMap<String, Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, Vec<u32>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<Vec<u32>, Vec<crate::api::types::Condition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(Vec<u32>, Vec<crate::api::types::Condition>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<u32, Vec<crate::api::types::Condition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(u32, Vec<crate::api::types::Condition>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for RustOpaqueNom<bdk::bitcoin::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::blockchain::AnyBlockchain> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::descriptor::ExtendedDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::descriptor::Policy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::keys::DescriptorPublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::keys::DescriptorSecretKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::keys::KeyMap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<bdk::keys::bip39::Mnemonic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<std::sync::Mutex<bdk::bitcoin::psbt::PartiallySignedTransaction>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::error::AddressError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::AddressError::Base58(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::AddressError::Bech32(var_field0);
            }
            2 => {
                return crate::api::error::AddressError::EmptyBech32Payload;
            }
            3 => {
                let mut var_expected = <crate::api::types::Variant>::sse_decode(deserializer);
                let mut var_found = <crate::api::types::Variant>::sse_decode(deserializer);
                return crate::api::error::AddressError::InvalidBech32Variant {
                    expected: var_expected,
                    found: var_found,
                };
            }
            4 => {
                let mut var_field0 = <u8>::sse_decode(deserializer);
                return crate::api::error::AddressError::InvalidWitnessVersion(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::AddressError::UnparsableWitnessVersion(var_field0);
            }
            6 => {
                return crate::api::error::AddressError::MalformedWitnessVersion;
            }
            7 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                return crate::api::error::AddressError::InvalidWitnessProgramLength(var_field0);
            }
            8 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                return crate::api::error::AddressError::InvalidSegwitV0ProgramLength(var_field0);
            }
            9 => {
                return crate::api::error::AddressError::UncompressedPubkey;
            }
            10 => {
                return crate::api::error::AddressError::ExcessiveScriptSize;
            }
            11 => {
                return crate::api::error::AddressError::UnrecognizedScript;
            }
            12 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::AddressError::UnknownAddressType(var_field0);
            }
            13 => {
                let mut var_networkRequired =
                    <crate::api::types::Network>::sse_decode(deserializer);
                let mut var_networkFound = <crate::api::types::Network>::sse_decode(deserializer);
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::error::AddressError::NetworkValidation {
                    network_required: var_networkRequired,
                    network_found: var_networkFound,
                    address: var_address,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::AddressIndex::Increase;
            }
            1 => {
                return crate::api::types::AddressIndex::LastUnused;
            }
            2 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::api::types::AddressIndex::Peek { index: var_index };
            }
            3 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::api::types::AddressIndex::Reset { index: var_index };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::blockchain::Auth {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::blockchain::Auth::None;
            }
            1 => {
                let mut var_username = <String>::sse_decode(deserializer);
                let mut var_password = <String>::sse_decode(deserializer);
                return crate::api::blockchain::Auth::UserPass {
                    username: var_username,
                    password: var_password,
                };
            }
            2 => {
                let mut var_file = <String>::sse_decode(deserializer);
                return crate::api::blockchain::Auth::Cookie { file: var_file };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_immature = <u64>::sse_decode(deserializer);
        let mut var_trustedPending = <u64>::sse_decode(deserializer);
        let mut var_untrustedPending = <u64>::sse_decode(deserializer);
        let mut var_confirmed = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_total = <u64>::sse_decode(deserializer);
        return crate::api::types::Balance {
            immature: var_immature,
            trusted_pending: var_trustedPending,
            untrusted_pending: var_untrustedPending,
            confirmed: var_confirmed,
            spendable: var_spendable,
            total: var_total,
        };
    }
}

impl SseDecode for crate::api::types::BdkAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::bitcoin::Address>>::sse_decode(deserializer);
        return crate::api::types::BdkAddress { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::blockchain::BdkBlockchain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::blockchain::AnyBlockchain>>::sse_decode(deserializer);
        return crate::api::blockchain::BdkBlockchain { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::key::BdkDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath>>::sse_decode(deserializer);
        return crate::api::key::BdkDerivationPath { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::descriptor::BdkDescriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_extendedDescriptor =
            <RustOpaqueNom<bdk::descriptor::ExtendedDescriptor>>::sse_decode(deserializer);
        let mut var_keyMap = <RustOpaqueNom<bdk::keys::KeyMap>>::sse_decode(deserializer);
        return crate::api::descriptor::BdkDescriptor {
            extended_descriptor: var_extendedDescriptor,
            key_map: var_keyMap,
        };
    }
}

impl SseDecode for crate::api::key::BdkDescriptorPublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::keys::DescriptorPublicKey>>::sse_decode(deserializer);
        return crate::api::key::BdkDescriptorPublicKey { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::key::BdkDescriptorSecretKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::keys::DescriptorSecretKey>>::sse_decode(deserializer);
        return crate::api::key::BdkDescriptorSecretKey { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::error::BdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::error::HexError>::sse_decode(deserializer);
                return crate::api::error::BdkError::Hex(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::error::ConsensusError>::sse_decode(deserializer);
                return crate::api::error::BdkError::Consensus(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::VerifyTransaction(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::api::error::AddressError>::sse_decode(deserializer);
                return crate::api::error::BdkError::Address(var_field0);
            }
            4 => {
                let mut var_field0 = <crate::api::error::DescriptorError>::sse_decode(deserializer);
                return crate::api::error::BdkError::Descriptor(var_field0);
            }
            5 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidU32Bytes(var_field0);
            }
            6 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Generic(var_field0);
            }
            7 => {
                return crate::api::error::BdkError::ScriptDoesntHaveAddressForm;
            }
            8 => {
                return crate::api::error::BdkError::NoRecipients;
            }
            9 => {
                return crate::api::error::BdkError::NoUtxosSelected;
            }
            10 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                return crate::api::error::BdkError::OutputBelowDustLimit(var_field0);
            }
            11 => {
                let mut var_needed = <u64>::sse_decode(deserializer);
                let mut var_available = <u64>::sse_decode(deserializer);
                return crate::api::error::BdkError::InsufficientFunds {
                    needed: var_needed,
                    available: var_available,
                };
            }
            12 => {
                return crate::api::error::BdkError::BnBTotalTriesExceeded;
            }
            13 => {
                return crate::api::error::BdkError::BnBNoExactMatch;
            }
            14 => {
                return crate::api::error::BdkError::UnknownUtxo;
            }
            15 => {
                return crate::api::error::BdkError::TransactionNotFound;
            }
            16 => {
                return crate::api::error::BdkError::TransactionConfirmed;
            }
            17 => {
                return crate::api::error::BdkError::IrreplaceableTransaction;
            }
            18 => {
                let mut var_needed = <f32>::sse_decode(deserializer);
                return crate::api::error::BdkError::FeeRateTooLow { needed: var_needed };
            }
            19 => {
                let mut var_needed = <u64>::sse_decode(deserializer);
                return crate::api::error::BdkError::FeeTooLow { needed: var_needed };
            }
            20 => {
                return crate::api::error::BdkError::FeeRateUnavailable;
            }
            21 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::MissingKeyOrigin(var_field0);
            }
            22 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Key(var_field0);
            }
            23 => {
                return crate::api::error::BdkError::ChecksumMismatch;
            }
            24 => {
                let mut var_field0 = <crate::api::types::KeychainKind>::sse_decode(deserializer);
                return crate::api::error::BdkError::SpendingPolicyRequired(var_field0);
            }
            25 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidPolicyPathError(var_field0);
            }
            26 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Signer(var_field0);
            }
            27 => {
                let mut var_requested = <crate::api::types::Network>::sse_decode(deserializer);
                let mut var_found = <crate::api::types::Network>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidNetwork {
                    requested: var_requested,
                    found: var_found,
                };
            }
            28 => {
                let mut var_field0 = <crate::api::types::OutPoint>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidOutpoint(var_field0);
            }
            29 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Encode(var_field0);
            }
            30 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Miniscript(var_field0);
            }
            31 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::MiniscriptPsbt(var_field0);
            }
            32 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Bip32(var_field0);
            }
            33 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Bip39(var_field0);
            }
            34 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Secp256k1(var_field0);
            }
            35 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Json(var_field0);
            }
            36 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Psbt(var_field0);
            }
            37 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::PsbtParse(var_field0);
            }
            38 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                let mut var_field1 = <usize>::sse_decode(deserializer);
                return crate::api::error::BdkError::MissingCachedScripts(var_field0, var_field1);
            }
            39 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Electrum(var_field0);
            }
            40 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Esplora(var_field0);
            }
            41 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Sled(var_field0);
            }
            42 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Rpc(var_field0);
            }
            43 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::Rusqlite(var_field0);
            }
            44 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidInput(var_field0);
            }
            45 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidLockTime(var_field0);
            }
            46 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::BdkError::InvalidTransaction(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::key::BdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::keys::bip39::Mnemonic>>::sse_decode(deserializer);
        return crate::api::key::BdkMnemonic { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::types::BdkPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<bdk::descriptor::Policy>>::sse_decode(deserializer);
        return crate::api::types::BdkPolicy { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::psbt::BdkPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<
            std::sync::Mutex<bdk::bitcoin::psbt::PartiallySignedTransaction>,
        >>::sse_decode(deserializer);
        return crate::api::psbt::BdkPsbt { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::types::BdkScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::types::BdkScriptBuf { bytes: var_bytes };
    }
}

impl SseDecode for crate::api::types::BdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::BdkTransaction { s: var_s };
    }
}

impl SseDecode for crate::api::types::BdkTransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transaction =
            <Option<crate::api::types::BdkTransaction>>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_received = <u64>::sse_decode(deserializer);
        let mut var_sent = <u64>::sse_decode(deserializer);
        let mut var_fee = <Option<u64>>::sse_decode(deserializer);
        let mut var_confirmationTime =
            <Option<crate::api::types::BlockTime>>::sse_decode(deserializer);
        return crate::api::types::BdkTransactionDetails {
            transaction: var_transaction,
            txid: var_txid,
            received: var_received,
            sent: var_sent,
            fee: var_fee,
            confirmation_time: var_confirmationTime,
        };
    }
}

impl SseDecode for crate::api::types::BdkTxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <crate::api::types::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <Option<crate::api::types::BdkScriptBuf>>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return crate::api::types::BdkTxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for crate::api::types::BdkTxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <crate::api::types::BdkScriptBuf>::sse_decode(deserializer);
        return crate::api::types::BdkTxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for crate::api::wallet::BdkWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>>>::sse_decode(
                deserializer,
            );
        return crate::api::wallet::BdkWallet { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::api::types::BlockTime {
            height: var_height,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::api::blockchain::BlockchainConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_config =
                    <crate::api::blockchain::ElectrumConfig>::sse_decode(deserializer);
                return crate::api::blockchain::BlockchainConfig::Electrum { config: var_config };
            }
            1 => {
                let mut var_config =
                    <crate::api::blockchain::EsploraConfig>::sse_decode(deserializer);
                return crate::api::blockchain::BlockchainConfig::Esplora { config: var_config };
            }
            2 => {
                let mut var_config = <crate::api::blockchain::RpcConfig>::sse_decode(deserializer);
                return crate::api::blockchain::BlockchainConfig::Rpc { config: var_config };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::api::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::api::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::Condition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_csv = <Option<u32>>::sse_decode(deserializer);
        let mut var_timelock = <Option<crate::api::types::LockTime>>::sse_decode(deserializer);
        return crate::api::types::Condition {
            csv: var_csv,
            timelock: var_timelock,
        };
    }
}

impl SseDecode for crate::api::error::ConsensusError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::ConsensusError::Io(var_field0);
            }
            1 => {
                let mut var_requested = <usize>::sse_decode(deserializer);
                let mut var_max = <usize>::sse_decode(deserializer);
                return crate::api::error::ConsensusError::OversizedVectorAllocation {
                    requested: var_requested,
                    max: var_max,
                };
            }
            2 => {
                let mut var_expected = <[u8; 4]>::sse_decode(deserializer);
                let mut var_actual = <[u8; 4]>::sse_decode(deserializer);
                return crate::api::error::ConsensusError::InvalidChecksum {
                    expected: var_expected,
                    actual: var_actual,
                };
            }
            3 => {
                return crate::api::error::ConsensusError::NonMinimalVarInt;
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::ConsensusError::ParseFailed(var_field0);
            }
            5 => {
                let mut var_field0 = <u8>::sse_decode(deserializer);
                return crate::api::error::ConsensusError::UnsupportedSegwitFlag(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::DatabaseConfig::Memory;
            }
            1 => {
                let mut var_config =
                    <crate::api::types::SqliteDbConfiguration>::sse_decode(deserializer);
                return crate::api::types::DatabaseConfig::Sqlite { config: var_config };
            }
            2 => {
                let mut var_config =
                    <crate::api::types::SledDbConfiguration>::sse_decode(deserializer);
                return crate::api::types::DatabaseConfig::Sled { config: var_config };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::error::DescriptorError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::error::DescriptorError::InvalidHdKeyPath;
            }
            1 => {
                return crate::api::error::DescriptorError::InvalidDescriptorChecksum;
            }
            2 => {
                return crate::api::error::DescriptorError::HardenedDerivationXpub;
            }
            3 => {
                return crate::api::error::DescriptorError::MultiPath;
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Key(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Policy(var_field0);
            }
            6 => {
                let mut var_field0 = <u8>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::InvalidDescriptorCharacter(var_field0);
            }
            7 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Bip32(var_field0);
            }
            8 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Base58(var_field0);
            }
            9 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Pk(var_field0);
            }
            10 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Miniscript(var_field0);
            }
            11 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::error::DescriptorError::Hex(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::blockchain::ElectrumConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_socks5 = <Option<String>>::sse_decode(deserializer);
        let mut var_retry = <u8>::sse_decode(deserializer);
        let mut var_timeout = <Option<u8>>::sse_decode(deserializer);
        let mut var_stopGap = <u64>::sse_decode(deserializer);
        let mut var_validateDomain = <bool>::sse_decode(deserializer);
        return crate::api::blockchain::ElectrumConfig {
            url: var_url,
            socks5: var_socks5,
            retry: var_retry,
            timeout: var_timeout,
            stop_gap: var_stopGap,
            validate_domain: var_validateDomain,
        };
    }
}

impl SseDecode for crate::api::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseUrl = <String>::sse_decode(deserializer);
        let mut var_proxy = <Option<String>>::sse_decode(deserializer);
        let mut var_concurrency = <Option<u8>>::sse_decode(deserializer);
        let mut var_stopGap = <u64>::sse_decode(deserializer);
        let mut var_timeout = <Option<u64>>::sse_decode(deserializer);
        return crate::api::blockchain::EsploraConfig {
            base_url: var_baseUrl,
            proxy: var_proxy,
            concurrency: var_concurrency,
            stop_gap: var_stopGap,
            timeout: var_timeout,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::FeeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_satPerVb = <f32>::sse_decode(deserializer);
        return crate::api::types::FeeRate {
            sat_per_vb: var_satPerVb,
        };
    }
}

impl SseDecode for crate::api::error::HexError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u8>::sse_decode(deserializer);
                return crate::api::error::HexError::InvalidChar(var_field0);
            }
            1 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                return crate::api::error::HexError::OddLengthString(var_field0);
            }
            2 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                let mut var_field1 = <usize>::sse_decode(deserializer);
                return crate::api::error::HexError::InvalidLength(var_field0, var_field1);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::Input {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::Input { s: var_s };
    }
}

impl SseDecode for crate::api::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::KeychainKind::ExternalChain,
            1 => crate::api::types::KeychainKind::InternalChain,
            _ => unreachable!("Invalid variant for KeychainKind: {}", inner),
        };
    }
}

impl SseDecode for Vec<crate::api::types::BdkPolicy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::BdkPolicy>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::BdkTransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::BdkTransactionDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::BdkTxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::BdkTxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::BdkTxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::BdkTxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::Condition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::Condition>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::LocalUtxo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::OutPoint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PkOrF> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PkOrF>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(Vec<u32>, Vec<crate::api::types::Condition>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(Vec<u32>, Vec<crate::api::types::Condition>)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Vec<u32>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Vec<u32>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(u32, Vec<crate::api::types::Condition>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(u32, Vec<crate::api::types::Condition>)>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::ScriptAmount>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::types::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outpoint = <crate::api::types::OutPoint>::sse_decode(deserializer);
        let mut var_txout = <crate::api::types::BdkTxOut>::sse_decode(deserializer);
        let mut var_keychain = <crate::api::types::KeychainKind>::sse_decode(deserializer);
        let mut var_isSpent = <bool>::sse_decode(deserializer);
        return crate::api::types::LocalUtxo {
            outpoint: var_outpoint,
            txout: var_txout,
            keychain: var_keychain,
            is_spent: var_isSpent,
        };
    }
}

impl SseDecode for crate::api::types::LockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::LockTime::Blocks(var_field0);
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::LockTime::Seconds(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Testnet,
            1 => crate::api::types::Network::Regtest,
            2 => crate::api::types::Network::Bitcoin,
            3 => crate::api::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<std::collections::HashMap<String, Vec<u32>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<std::collections::HashMap<String, Vec<u32>>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::BdkAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::BdkAddress>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::descriptor::BdkDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::descriptor::BdkDescriptor>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::BdkPolicy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::BdkPolicy>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::BdkScriptBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::BdkScriptBuf>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::BdkTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::BdkTransaction>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::BlockTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::FeeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::FeeRate>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::LockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::LockTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PsbtSigHashType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PsbtSigHashType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::RbfValue>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(crate::api::types::OutPoint, crate::api::types::Input, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(
                crate::api::types::OutPoint,
                crate::api::types::Input,
                usize,
            )>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::blockchain::RpcSyncParams> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::blockchain::RpcSyncParams>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::SignOptions>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::Payload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_pubkeyHash = <String>::sse_decode(deserializer);
                return crate::api::types::Payload::PubkeyHash {
                    pubkey_hash: var_pubkeyHash,
                };
            }
            1 => {
                let mut var_scriptHash = <String>::sse_decode(deserializer);
                return crate::api::types::Payload::ScriptHash {
                    script_hash: var_scriptHash,
                };
            }
            2 => {
                let mut var_version = <crate::api::types::WitnessVersion>::sse_decode(deserializer);
                let mut var_program = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::types::Payload::WitnessProgram {
                    version: var_version,
                    program: var_program,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PkOrF {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::api::types::PkOrF::Pubkey { value: var_value };
            }
            1 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::api::types::PkOrF::XOnlyPubkey { value: var_value };
            }
            2 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::api::types::PkOrF::Fingerprint { value: var_value };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PsbtSigHashType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <u32>::sse_decode(deserializer);
        return crate::api::types::PsbtSigHashType { inner: var_inner };
    }
}

impl SseDecode for crate::api::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::RbfValue::RbfDefault;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::types::RbfValue::Value(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for (crate::api::types::BdkAddress, u32) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::types::BdkAddress>::sse_decode(deserializer);
        let mut var_field1 = <u32>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::api::psbt::BdkPsbt,
        crate::api::types::BdkTransactionDetails,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::psbt::BdkPsbt>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::types::BdkTransactionDetails>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (Vec<u32>, Vec<crate::api::types::Condition>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u32>>::sse_decode(deserializer);
        let mut var_field1 = <Vec<crate::api::types::Condition>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (crate::api::types::OutPoint, crate::api::types::Input, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::types::OutPoint>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::types::Input>::sse_decode(deserializer);
        let mut var_field2 = <usize>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, Vec<u32>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Vec<u32>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (u32, Vec<crate::api::types::Condition>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u32>::sse_decode(deserializer);
        let mut var_field1 = <Vec<crate::api::types::Condition>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::blockchain::RpcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_auth = <crate::api::blockchain::Auth>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Network>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_syncParams =
            <Option<crate::api::blockchain::RpcSyncParams>>::sse_decode(deserializer);
        return crate::api::blockchain::RpcConfig {
            url: var_url,
            auth: var_auth,
            network: var_network,
            wallet_name: var_walletName,
            sync_params: var_syncParams,
        };
    }
}

impl SseDecode for crate::api::blockchain::RpcSyncParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_startScriptCount = <u64>::sse_decode(deserializer);
        let mut var_startTime = <u64>::sse_decode(deserializer);
        let mut var_forceStartTime = <bool>::sse_decode(deserializer);
        let mut var_pollRateSec = <u64>::sse_decode(deserializer);
        return crate::api::blockchain::RpcSyncParams {
            start_script_count: var_startScriptCount,
            start_time: var_startTime,
            force_start_time: var_forceStartTime,
            poll_rate_sec: var_pollRateSec,
        };
    }
}

impl SseDecode for crate::api::types::Satisfaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_n = <u64>::sse_decode(deserializer);
                let mut var_m = <u64>::sse_decode(deserializer);
                let mut var_items = <Vec<u64>>::sse_decode(deserializer);
                let mut var_sorted = <Option<bool>>::sse_decode(deserializer);
                let mut var_conditions = <std::collections::HashMap<
                    u32,
                    Vec<crate::api::types::Condition>,
                >>::sse_decode(deserializer);
                return crate::api::types::Satisfaction::Partial {
                    n: var_n,
                    m: var_m,
                    items: var_items,
                    sorted: var_sorted,
                    conditions: var_conditions,
                };
            }
            1 => {
                let mut var_n = <u64>::sse_decode(deserializer);
                let mut var_m = <u64>::sse_decode(deserializer);
                let mut var_items = <Vec<u64>>::sse_decode(deserializer);
                let mut var_sorted = <Option<bool>>::sse_decode(deserializer);
                let mut var_conditions = <std::collections::HashMap<
                    Vec<u32>,
                    Vec<crate::api::types::Condition>,
                >>::sse_decode(deserializer);
                return crate::api::types::Satisfaction::PartialComplete {
                    n: var_n,
                    m: var_m,
                    items: var_items,
                    sorted: var_sorted,
                    conditions: var_conditions,
                };
            }
            2 => {
                let mut var_condition = <crate::api::types::Condition>::sse_decode(deserializer);
                return crate::api::types::Satisfaction::Complete {
                    condition: var_condition,
                };
            }
            3 => {
                let mut var_msg = <String>::sse_decode(deserializer);
                return crate::api::types::Satisfaction::None { msg: var_msg };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::SatisfiableItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_key = <crate::api::types::PkOrF>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::EcdsaSignature { key: var_key };
            }
            1 => {
                let mut var_key = <crate::api::types::PkOrF>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::SchnorrSignature { key: var_key };
            }
            2 => {
                let mut var_hash = <String>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Sha256Preimage { hash: var_hash };
            }
            3 => {
                let mut var_hash = <String>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Hash256Preimage { hash: var_hash };
            }
            4 => {
                let mut var_hash = <String>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Ripemd160Preimage { hash: var_hash };
            }
            5 => {
                let mut var_hash = <String>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Hash160Preimage { hash: var_hash };
            }
            6 => {
                let mut var_value = <crate::api::types::LockTime>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::AbsoluteTimelock { value: var_value };
            }
            7 => {
                let mut var_value = <u32>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::RelativeTimelock { value: var_value };
            }
            8 => {
                let mut var_keys = <Vec<crate::api::types::PkOrF>>::sse_decode(deserializer);
                let mut var_threshold = <u64>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Multisig {
                    keys: var_keys,
                    threshold: var_threshold,
                };
            }
            9 => {
                let mut var_items = <Vec<crate::api::types::BdkPolicy>>::sse_decode(deserializer);
                let mut var_threshold = <u64>::sse_decode(deserializer);
                return crate::api::types::SatisfiableItem::Thresh {
                    items: var_items,
                    threshold: var_threshold,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_script = <crate::api::types::BdkScriptBuf>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        return crate::api::types::ScriptAmount {
            script: var_script,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::api::types::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustWitnessUtxo = <bool>::sse_decode(deserializer);
        let mut var_assumeHeight = <Option<u32>>::sse_decode(deserializer);
        let mut var_allowAllSighashes = <bool>::sse_decode(deserializer);
        let mut var_removePartialSigs = <bool>::sse_decode(deserializer);
        let mut var_tryFinalize = <bool>::sse_decode(deserializer);
        let mut var_signWithTapInternalKey = <bool>::sse_decode(deserializer);
        let mut var_allowGrinding = <bool>::sse_decode(deserializer);
        return crate::api::types::SignOptions {
            trust_witness_utxo: var_trustWitnessUtxo,
            assume_height: var_assumeHeight,
            allow_all_sighashes: var_allowAllSighashes,
            remove_partial_sigs: var_removePartialSigs,
            try_finalize: var_tryFinalize,
            sign_with_tap_internal_key: var_signWithTapInternalKey,
            allow_grinding: var_allowGrinding,
        };
    }
}

impl SseDecode for crate::api::types::SledDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        let mut var_treeName = <String>::sse_decode(deserializer);
        return crate::api::types::SledDbConfiguration {
            path: var_path,
            tree_name: var_treeName,
        };
    }
}

impl SseDecode for crate::api::types::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        return crate::api::types::SqliteDbConfiguration { path: var_path };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::types::Variant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Variant::Bech32,
            1 => crate::api::types::Variant::Bech32m,
            _ => unreachable!("Invalid variant for Variant: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::WitnessVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::WitnessVersion::V0,
            1 => crate::api::types::WitnessVersion::V1,
            2 => crate::api::types::WitnessVersion::V2,
            3 => crate::api::types::WitnessVersion::V3,
            4 => crate::api::types::WitnessVersion::V4,
            5 => crate::api::types::WitnessVersion::V5,
            6 => crate::api::types::WitnessVersion::V6,
            7 => crate::api::types::WitnessVersion::V7,
            8 => crate::api::types::WitnessVersion::V8,
            9 => crate::api::types::WitnessVersion::V9,
            10 => crate::api::types::WitnessVersion::V10,
            11 => crate::api::types::WitnessVersion::V11,
            12 => crate::api::types::WitnessVersion::V12,
            13 => crate::api::types::WitnessVersion::V13,
            14 => crate::api::types::WitnessVersion::V14,
            15 => crate::api::types::WitnessVersion::V15,
            16 => crate::api::types::WitnessVersion::V16,
            _ => unreachable!("Invalid variant for WitnessVersion: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::WordCount::Words12,
            1 => crate::api::types::WordCount::Words18,
            2 => crate::api::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::AddressError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::AddressError::Base58(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::Bech32(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::EmptyBech32Payload => [2.into_dart()].into_dart(),
            crate::api::error::AddressError::InvalidBech32Variant { expected, found } => [
                3.into_dart(),
                expected.into_into_dart().into_dart(),
                found.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::AddressError::InvalidWitnessVersion(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::UnparsableWitnessVersion(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::MalformedWitnessVersion => [6.into_dart()].into_dart(),
            crate::api::error::AddressError::InvalidWitnessProgramLength(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::InvalidSegwitV0ProgramLength(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::UncompressedPubkey => [9.into_dart()].into_dart(),
            crate::api::error::AddressError::ExcessiveScriptSize => [10.into_dart()].into_dart(),
            crate::api::error::AddressError::UnrecognizedScript => [11.into_dart()].into_dart(),
            crate::api::error::AddressError::UnknownAddressType(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::AddressError::NetworkValidation {
                network_required,
                network_found,
                address,
            } => [
                13.into_dart(),
                network_required.into_into_dart().into_dart(),
                network_found.into_into_dart().into_dart(),
                address.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::AddressError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::AddressError>
    for crate::api::error::AddressError
{
    fn into_into_dart(self) -> crate::api::error::AddressError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::AddressIndex {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::AddressIndex::Increase => [0.into_dart()].into_dart(),
            crate::api::types::AddressIndex::LastUnused => [1.into_dart()].into_dart(),
            crate::api::types::AddressIndex::Peek { index } => {
                [2.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::AddressIndex::Reset { index } => {
                [3.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::AddressIndex
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::AddressIndex>
    for crate::api::types::AddressIndex
{
    fn into_into_dart(self) -> crate::api::types::AddressIndex {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::Auth {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::blockchain::Auth::None => [0.into_dart()].into_dart(),
            crate::api::blockchain::Auth::UserPass { username, password } => [
                1.into_dart(),
                username.into_into_dart().into_dart(),
                password.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::blockchain::Auth::Cookie { file } => {
                [2.into_dart(), file.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::blockchain::Auth {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::Auth>
    for crate::api::blockchain::Auth
{
    fn into_into_dart(self) -> crate::api::blockchain::Auth {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.immature.into_into_dart().into_dart(),
            self.trusted_pending.into_into_dart().into_dart(),
            self.untrusted_pending.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Balance> for crate::api::types::Balance {
    fn into_into_dart(self) -> crate::api::types::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BdkAddress {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkAddress>
    for crate::api::types::BdkAddress
{
    fn into_into_dart(self) -> crate::api::types::BdkAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::BdkBlockchain {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::BdkBlockchain
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::BdkBlockchain>
    for crate::api::blockchain::BdkBlockchain
{
    fn into_into_dart(self) -> crate::api::blockchain::BdkBlockchain {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::BdkDerivationPath {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::BdkDerivationPath
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::BdkDerivationPath>
    for crate::api::key::BdkDerivationPath
{
    fn into_into_dart(self) -> crate::api::key::BdkDerivationPath {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::descriptor::BdkDescriptor {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.extended_descriptor.into_into_dart().into_dart(),
            self.key_map.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::descriptor::BdkDescriptor
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::descriptor::BdkDescriptor>
    for crate::api::descriptor::BdkDescriptor
{
    fn into_into_dart(self) -> crate::api::descriptor::BdkDescriptor {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::BdkDescriptorPublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::BdkDescriptorPublicKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::BdkDescriptorPublicKey>
    for crate::api::key::BdkDescriptorPublicKey
{
    fn into_into_dart(self) -> crate::api::key::BdkDescriptorPublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::BdkDescriptorSecretKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::key::BdkDescriptorSecretKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::BdkDescriptorSecretKey>
    for crate::api::key::BdkDescriptorSecretKey
{
    fn into_into_dart(self) -> crate::api::key::BdkDescriptorSecretKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BdkError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::BdkError::Hex(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Consensus(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::VerifyTransaction(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Address(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Descriptor(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidU32Bytes(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Generic(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::ScriptDoesntHaveAddressForm => [7.into_dart()].into_dart(),
            crate::api::error::BdkError::NoRecipients => [8.into_dart()].into_dart(),
            crate::api::error::BdkError::NoUtxosSelected => [9.into_dart()].into_dart(),
            crate::api::error::BdkError::OutputBelowDustLimit(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InsufficientFunds { needed, available } => [
                11.into_dart(),
                needed.into_into_dart().into_dart(),
                available.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::BdkError::BnBTotalTriesExceeded => [12.into_dart()].into_dart(),
            crate::api::error::BdkError::BnBNoExactMatch => [13.into_dart()].into_dart(),
            crate::api::error::BdkError::UnknownUtxo => [14.into_dart()].into_dart(),
            crate::api::error::BdkError::TransactionNotFound => [15.into_dart()].into_dart(),
            crate::api::error::BdkError::TransactionConfirmed => [16.into_dart()].into_dart(),
            crate::api::error::BdkError::IrreplaceableTransaction => [17.into_dart()].into_dart(),
            crate::api::error::BdkError::FeeRateTooLow { needed } => {
                [18.into_dart(), needed.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::FeeTooLow { needed } => {
                [19.into_dart(), needed.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::FeeRateUnavailable => [20.into_dart()].into_dart(),
            crate::api::error::BdkError::MissingKeyOrigin(field0) => {
                [21.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Key(field0) => {
                [22.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::ChecksumMismatch => [23.into_dart()].into_dart(),
            crate::api::error::BdkError::SpendingPolicyRequired(field0) => {
                [24.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidPolicyPathError(field0) => {
                [25.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Signer(field0) => {
                [26.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidNetwork { requested, found } => [
                27.into_dart(),
                requested.into_into_dart().into_dart(),
                found.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::BdkError::InvalidOutpoint(field0) => {
                [28.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Encode(field0) => {
                [29.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Miniscript(field0) => {
                [30.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::MiniscriptPsbt(field0) => {
                [31.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Bip32(field0) => {
                [32.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Bip39(field0) => {
                [33.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Secp256k1(field0) => {
                [34.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Json(field0) => {
                [35.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Psbt(field0) => {
                [36.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::PsbtParse(field0) => {
                [37.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::MissingCachedScripts(field0, field1) => [
                38.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::BdkError::Electrum(field0) => {
                [39.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Esplora(field0) => {
                [40.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Sled(field0) => {
                [41.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Rpc(field0) => {
                [42.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::Rusqlite(field0) => {
                [43.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidInput(field0) => {
                [44.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidLockTime(field0) => {
                [45.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::BdkError::InvalidTransaction(field0) => {
                [46.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::BdkError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BdkError>
    for crate::api::error::BdkError
{
    fn into_into_dart(self) -> crate::api::error::BdkError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::key::BdkMnemonic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::key::BdkMnemonic {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::key::BdkMnemonic>
    for crate::api::key::BdkMnemonic
{
    fn into_into_dart(self) -> crate::api::key::BdkMnemonic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BdkPolicy {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkPolicy>
    for crate::api::types::BdkPolicy
{
    fn into_into_dart(self) -> crate::api::types::BdkPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::psbt::BdkPsbt {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::psbt::BdkPsbt {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::psbt::BdkPsbt> for crate::api::psbt::BdkPsbt {
    fn into_into_dart(self) -> crate::api::psbt::BdkPsbt {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkScriptBuf {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.bytes.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BdkScriptBuf
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkScriptBuf>
    for crate::api::types::BdkScriptBuf
{
    fn into_into_dart(self) -> crate::api::types::BdkScriptBuf {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BdkTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkTransaction>
    for crate::api::types::BdkTransaction
{
    fn into_into_dart(self) -> crate::api::types::BdkTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkTransactionDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transaction.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.received.into_into_dart().into_dart(),
            self.sent.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.confirmation_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BdkTransactionDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkTransactionDetails>
    for crate::api::types::BdkTransactionDetails
{
    fn into_into_dart(self) -> crate::api::types::BdkTransactionDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkTxIn {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.previous_output.into_into_dart().into_dart(),
            self.script_sig.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BdkTxIn {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkTxIn> for crate::api::types::BdkTxIn {
    fn into_into_dart(self) -> crate::api::types::BdkTxIn {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BdkTxOut {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BdkTxOut {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BdkTxOut>
    for crate::api::types::BdkTxOut
{
    fn into_into_dart(self) -> crate::api::types::BdkTxOut {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::BdkWallet {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::wallet::BdkWallet {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::BdkWallet>
    for crate::api::wallet::BdkWallet
{
    fn into_into_dart(self) -> crate::api::wallet::BdkWallet {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BlockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BlockTime {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BlockTime>
    for crate::api::types::BlockTime
{
    fn into_into_dart(self) -> crate::api::types::BlockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::BlockchainConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::blockchain::BlockchainConfig::Electrum { config } => {
                [0.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::api::blockchain::BlockchainConfig::Esplora { config } => {
                [1.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::api::blockchain::BlockchainConfig::Rpc { config } => {
                [2.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::BlockchainConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::BlockchainConfig>
    for crate::api::blockchain::BlockchainConfig
{
    fn into_into_dart(self) -> crate::api::blockchain::BlockchainConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChangeSpendPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ChangeAllowed => 0.into_dart(),
            Self::OnlyChange => 1.into_dart(),
            Self::ChangeForbidden => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChangeSpendPolicy
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChangeSpendPolicy>
    for crate::api::types::ChangeSpendPolicy
{
    fn into_into_dart(self) -> crate::api::types::ChangeSpendPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Condition {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.csv.into_into_dart().into_dart(),
            self.timelock.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Condition {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Condition>
    for crate::api::types::Condition
{
    fn into_into_dart(self) -> crate::api::types::Condition {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::ConsensusError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::ConsensusError::Io(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ConsensusError::OversizedVectorAllocation { requested, max } => [
                1.into_dart(),
                requested.into_into_dart().into_dart(),
                max.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::ConsensusError::InvalidChecksum { expected, actual } => [
                2.into_dart(),
                expected.into_into_dart().into_dart(),
                actual.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::error::ConsensusError::NonMinimalVarInt => [3.into_dart()].into_dart(),
            crate::api::error::ConsensusError::ParseFailed(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::ConsensusError::UnsupportedSegwitFlag(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::ConsensusError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::ConsensusError>
    for crate::api::error::ConsensusError
{
    fn into_into_dart(self) -> crate::api::error::ConsensusError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::DatabaseConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::DatabaseConfig::Memory => [0.into_dart()].into_dart(),
            crate::api::types::DatabaseConfig::Sqlite { config } => {
                [1.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::DatabaseConfig::Sled { config } => {
                [2.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::DatabaseConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::DatabaseConfig>
    for crate::api::types::DatabaseConfig
{
    fn into_into_dart(self) -> crate::api::types::DatabaseConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::DescriptorError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::DescriptorError::InvalidHdKeyPath => [0.into_dart()].into_dart(),
            crate::api::error::DescriptorError::InvalidDescriptorChecksum => {
                [1.into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::HardenedDerivationXpub => {
                [2.into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::MultiPath => [3.into_dart()].into_dart(),
            crate::api::error::DescriptorError::Key(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Policy(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::InvalidDescriptorCharacter(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Bip32(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Base58(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Pk(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Miniscript(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::DescriptorError::Hex(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::DescriptorError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::DescriptorError>
    for crate::api::error::DescriptorError
{
    fn into_into_dart(self) -> crate::api::error::DescriptorError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::ElectrumConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.socks5.into_into_dart().into_dart(),
            self.retry.into_into_dart().into_dart(),
            self.timeout.into_into_dart().into_dart(),
            self.stop_gap.into_into_dart().into_dart(),
            self.validate_domain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::ElectrumConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::ElectrumConfig>
    for crate::api::blockchain::ElectrumConfig
{
    fn into_into_dart(self) -> crate::api::blockchain::ElectrumConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::EsploraConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_url.into_into_dart().into_dart(),
            self.proxy.into_into_dart().into_dart(),
            self.concurrency.into_into_dart().into_dart(),
            self.stop_gap.into_into_dart().into_dart(),
            self.timeout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::EsploraConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::EsploraConfig>
    for crate::api::blockchain::EsploraConfig
{
    fn into_into_dart(self) -> crate::api::blockchain::EsploraConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::FeeRate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.sat_per_vb.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::FeeRate {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::FeeRate> for crate::api::types::FeeRate {
    fn into_into_dart(self) -> crate::api::types::FeeRate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::HexError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::error::HexError::InvalidChar(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::HexError::OddLengthString(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::error::HexError::InvalidLength(field0, field1) => [
                2.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::HexError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::HexError>
    for crate::api::error::HexError
{
    fn into_into_dart(self) -> crate::api::error::HexError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Input {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Input {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Input> for crate::api::types::Input {
    fn into_into_dart(self) -> crate::api::types::Input {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::KeychainKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ExternalChain => 0.into_dart(),
            Self::InternalChain => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::KeychainKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::KeychainKind>
    for crate::api::types::KeychainKind
{
    fn into_into_dart(self) -> crate::api::types::KeychainKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LocalUtxo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LocalUtxo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LocalUtxo>
    for crate::api::types::LocalUtxo
{
    fn into_into_dart(self) -> crate::api::types::LocalUtxo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::LockTime::Blocks(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::LockTime::Seconds(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LockTime {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LockTime>
    for crate::api::types::LockTime
{
    fn into_into_dart(self) -> crate::api::types::LockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Testnet => 0.into_dart(),
            Self::Regtest => 1.into_dart(),
            Self::Bitcoin => 2.into_dart(),
            Self::Signet => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Payload {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Payload::PubkeyHash { pubkey_hash } => {
                [0.into_dart(), pubkey_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::Payload::ScriptHash { script_hash } => {
                [1.into_dart(), script_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::Payload::WitnessProgram { version, program } => [
                2.into_dart(),
                version.into_into_dart().into_dart(),
                program.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Payload {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Payload> for crate::api::types::Payload {
    fn into_into_dart(self) -> crate::api::types::Payload {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PkOrF {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PkOrF::Pubkey { value } => {
                [0.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::PkOrF::XOnlyPubkey { value } => {
                [1.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::PkOrF::Fingerprint { value } => {
                [2.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PkOrF {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PkOrF> for crate::api::types::PkOrF {
    fn into_into_dart(self) -> crate::api::types::PkOrF {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PsbtSigHashType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PsbtSigHashType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PsbtSigHashType>
    for crate::api::types::PsbtSigHashType
{
    fn into_into_dart(self) -> crate::api::types::PsbtSigHashType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::RbfValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::RbfValue::RbfDefault => [0.into_dart()].into_dart(),
            crate::api::types::RbfValue::Value(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::RbfValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::RbfValue>
    for crate::api::types::RbfValue
{
    fn into_into_dart(self) -> crate::api::types::RbfValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::RpcConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.auth.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.sync_params.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::RpcConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::RpcConfig>
    for crate::api::blockchain::RpcConfig
{
    fn into_into_dart(self) -> crate::api::blockchain::RpcConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::RpcSyncParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.start_script_count.into_into_dart().into_dart(),
            self.start_time.into_into_dart().into_dart(),
            self.force_start_time.into_into_dart().into_dart(),
            self.poll_rate_sec.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::RpcSyncParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::RpcSyncParams>
    for crate::api::blockchain::RpcSyncParams
{
    fn into_into_dart(self) -> crate::api::blockchain::RpcSyncParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Satisfaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Satisfaction::Partial {
                n,
                m,
                items,
                sorted,
                conditions,
            } => [
                0.into_dart(),
                n.into_into_dart().into_dart(),
                m.into_into_dart().into_dart(),
                items.into_into_dart().into_dart(),
                sorted.into_into_dart().into_dart(),
                conditions.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Satisfaction::PartialComplete {
                n,
                m,
                items,
                sorted,
                conditions,
            } => [
                1.into_dart(),
                n.into_into_dart().into_dart(),
                m.into_into_dart().into_dart(),
                items.into_into_dart().into_dart(),
                sorted.into_into_dart().into_dart(),
                conditions.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Satisfaction::Complete { condition } => {
                [2.into_dart(), condition.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::Satisfaction::None { msg } => {
                [3.into_dart(), msg.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::Satisfaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Satisfaction>
    for crate::api::types::Satisfaction
{
    fn into_into_dart(self) -> crate::api::types::Satisfaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SatisfiableItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::SatisfiableItem::EcdsaSignature { key } => {
                [0.into_dart(), key.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::SchnorrSignature { key } => {
                [1.into_dart(), key.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::Sha256Preimage { hash } => {
                [2.into_dart(), hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::Hash256Preimage { hash } => {
                [3.into_dart(), hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::Ripemd160Preimage { hash } => {
                [4.into_dart(), hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::Hash160Preimage { hash } => {
                [5.into_dart(), hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::AbsoluteTimelock { value } => {
                [6.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::RelativeTimelock { value } => {
                [7.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SatisfiableItem::Multisig { keys, threshold } => [
                8.into_dart(),
                keys.into_into_dart().into_dart(),
                threshold.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SatisfiableItem::Thresh { items, threshold } => [
                9.into_dart(),
                items.into_into_dart().into_dart(),
                threshold.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SatisfiableItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SatisfiableItem>
    for crate::api::types::SatisfiableItem
{
    fn into_into_dart(self) -> crate::api::types::SatisfiableItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ScriptAmount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.script.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ScriptAmount
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ScriptAmount>
    for crate::api::types::ScriptAmount
{
    fn into_into_dart(self) -> crate::api::types::ScriptAmount {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SignOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.trust_witness_utxo.into_into_dart().into_dart(),
            self.assume_height.into_into_dart().into_dart(),
            self.allow_all_sighashes.into_into_dart().into_dart(),
            self.remove_partial_sigs.into_into_dart().into_dart(),
            self.try_finalize.into_into_dart().into_dart(),
            self.sign_with_tap_internal_key.into_into_dart().into_dart(),
            self.allow_grinding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SignOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SignOptions>
    for crate::api::types::SignOptions
{
    fn into_into_dart(self) -> crate::api::types::SignOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SledDbConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path.into_into_dart().into_dart(),
            self.tree_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SledDbConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SledDbConfiguration>
    for crate::api::types::SledDbConfiguration
{
    fn into_into_dart(self) -> crate::api::types::SledDbConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SqliteDbConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.path.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SqliteDbConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SqliteDbConfiguration>
    for crate::api::types::SqliteDbConfiguration
{
    fn into_into_dart(self) -> crate::api::types::SqliteDbConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Variant {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bech32 => 0.into_dart(),
            Self::Bech32m => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Variant {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Variant> for crate::api::types::Variant {
    fn into_into_dart(self) -> crate::api::types::Variant {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::WitnessVersion {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::V0 => 0.into_dart(),
            Self::V1 => 1.into_dart(),
            Self::V2 => 2.into_dart(),
            Self::V3 => 3.into_dart(),
            Self::V4 => 4.into_dart(),
            Self::V5 => 5.into_dart(),
            Self::V6 => 6.into_dart(),
            Self::V7 => 7.into_dart(),
            Self::V8 => 8.into_dart(),
            Self::V9 => 9.into_dart(),
            Self::V10 => 10.into_dart(),
            Self::V11 => 11.into_dart(),
            Self::V12 => 12.into_dart(),
            Self::V13 => 13.into_dart(),
            Self::V14 => 14.into_dart(),
            Self::V15 => 15.into_dart(),
            Self::V16 => 16.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::WitnessVersion
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::WitnessVersion>
    for crate::api::types::WitnessVersion
{
    fn into_into_dart(self) -> crate::api::types::WitnessVersion {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::WordCount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Words12 => 0.into_dart(),
            Self::Words18 => 1.into_dart(),
            Self::Words24 => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::WordCount {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::WordCount>
    for crate::api::types::WordCount
{
    fn into_into_dart(self) -> crate::api::types::WordCount {
        self
    }
}

impl SseEncode for std::collections::HashMap<String, Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Vec<u32>)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<Vec<u32>, Vec<crate::api::types::Condition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(Vec<u32>, Vec<crate::api::types::Condition>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<u32, Vec<crate::api::types::Condition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(u32, Vec<crate::api::types::Condition>)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for RustOpaqueNom<bdk::bitcoin::Address> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::blockchain::AnyBlockchain> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::descriptor::ExtendedDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::descriptor::Policy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::keys::DescriptorPublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::keys::DescriptorSecretKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::keys::KeyMap> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<bdk::keys::bip39::Mnemonic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<std::sync::Mutex<bdk::bitcoin::psbt::PartiallySignedTransaction>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::error::AddressError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::AddressError::Base58(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::Bech32(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::EmptyBech32Payload => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::AddressError::InvalidBech32Variant { expected, found } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::Variant>::sse_encode(expected, serializer);
                <crate::api::types::Variant>::sse_encode(found, serializer);
            }
            crate::api::error::AddressError::InvalidWitnessVersion(field0) => {
                <i32>::sse_encode(4, serializer);
                <u8>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::UnparsableWitnessVersion(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::MalformedWitnessVersion => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::error::AddressError::InvalidWitnessProgramLength(field0) => {
                <i32>::sse_encode(7, serializer);
                <usize>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::InvalidSegwitV0ProgramLength(field0) => {
                <i32>::sse_encode(8, serializer);
                <usize>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::UncompressedPubkey => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::AddressError::ExcessiveScriptSize => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::error::AddressError::UnrecognizedScript => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::error::AddressError::UnknownAddressType(field0) => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::AddressError::NetworkValidation {
                network_required,
                network_found,
                address,
            } => {
                <i32>::sse_encode(13, serializer);
                <crate::api::types::Network>::sse_encode(network_required, serializer);
                <crate::api::types::Network>::sse_encode(network_found, serializer);
                <String>::sse_encode(address, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::AddressIndex::Increase => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::AddressIndex::LastUnused => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::types::AddressIndex::Peek { index } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(index, serializer);
            }
            crate::api::types::AddressIndex::Reset { index } => {
                <i32>::sse_encode(3, serializer);
                <u32>::sse_encode(index, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::blockchain::Auth {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::blockchain::Auth::None => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::blockchain::Auth::UserPass { username, password } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(username, serializer);
                <String>::sse_encode(password, serializer);
            }
            crate::api::blockchain::Auth::Cookie { file } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(file, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.immature, serializer);
        <u64>::sse_encode(self.trusted_pending, serializer);
        <u64>::sse_encode(self.untrusted_pending, serializer);
        <u64>::sse_encode(self.confirmed, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.total, serializer);
    }
}

impl SseEncode for crate::api::types::BdkAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::bitcoin::Address>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::blockchain::BdkBlockchain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::blockchain::AnyBlockchain>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::key::BdkDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::descriptor::BdkDescriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::descriptor::ExtendedDescriptor>>::sse_encode(
            self.extended_descriptor,
            serializer,
        );
        <RustOpaqueNom<bdk::keys::KeyMap>>::sse_encode(self.key_map, serializer);
    }
}

impl SseEncode for crate::api::key::BdkDescriptorPublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::keys::DescriptorPublicKey>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::key::BdkDescriptorSecretKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::keys::DescriptorSecretKey>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::error::BdkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::BdkError::Hex(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::error::HexError>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Consensus(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::error::ConsensusError>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::VerifyTransaction(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Address(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::api::error::AddressError>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Descriptor(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::api::error::DescriptorError>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidU32Bytes(field0) => {
                <i32>::sse_encode(5, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Generic(field0) => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::ScriptDoesntHaveAddressForm => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::error::BdkError::NoRecipients => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::error::BdkError::NoUtxosSelected => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::error::BdkError::OutputBelowDustLimit(field0) => {
                <i32>::sse_encode(10, serializer);
                <usize>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InsufficientFunds { needed, available } => {
                <i32>::sse_encode(11, serializer);
                <u64>::sse_encode(needed, serializer);
                <u64>::sse_encode(available, serializer);
            }
            crate::api::error::BdkError::BnBTotalTriesExceeded => {
                <i32>::sse_encode(12, serializer);
            }
            crate::api::error::BdkError::BnBNoExactMatch => {
                <i32>::sse_encode(13, serializer);
            }
            crate::api::error::BdkError::UnknownUtxo => {
                <i32>::sse_encode(14, serializer);
            }
            crate::api::error::BdkError::TransactionNotFound => {
                <i32>::sse_encode(15, serializer);
            }
            crate::api::error::BdkError::TransactionConfirmed => {
                <i32>::sse_encode(16, serializer);
            }
            crate::api::error::BdkError::IrreplaceableTransaction => {
                <i32>::sse_encode(17, serializer);
            }
            crate::api::error::BdkError::FeeRateTooLow { needed } => {
                <i32>::sse_encode(18, serializer);
                <f32>::sse_encode(needed, serializer);
            }
            crate::api::error::BdkError::FeeTooLow { needed } => {
                <i32>::sse_encode(19, serializer);
                <u64>::sse_encode(needed, serializer);
            }
            crate::api::error::BdkError::FeeRateUnavailable => {
                <i32>::sse_encode(20, serializer);
            }
            crate::api::error::BdkError::MissingKeyOrigin(field0) => {
                <i32>::sse_encode(21, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Key(field0) => {
                <i32>::sse_encode(22, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::ChecksumMismatch => {
                <i32>::sse_encode(23, serializer);
            }
            crate::api::error::BdkError::SpendingPolicyRequired(field0) => {
                <i32>::sse_encode(24, serializer);
                <crate::api::types::KeychainKind>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidPolicyPathError(field0) => {
                <i32>::sse_encode(25, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Signer(field0) => {
                <i32>::sse_encode(26, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidNetwork { requested, found } => {
                <i32>::sse_encode(27, serializer);
                <crate::api::types::Network>::sse_encode(requested, serializer);
                <crate::api::types::Network>::sse_encode(found, serializer);
            }
            crate::api::error::BdkError::InvalidOutpoint(field0) => {
                <i32>::sse_encode(28, serializer);
                <crate::api::types::OutPoint>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Encode(field0) => {
                <i32>::sse_encode(29, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Miniscript(field0) => {
                <i32>::sse_encode(30, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::MiniscriptPsbt(field0) => {
                <i32>::sse_encode(31, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Bip32(field0) => {
                <i32>::sse_encode(32, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Bip39(field0) => {
                <i32>::sse_encode(33, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Secp256k1(field0) => {
                <i32>::sse_encode(34, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Json(field0) => {
                <i32>::sse_encode(35, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Psbt(field0) => {
                <i32>::sse_encode(36, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::PsbtParse(field0) => {
                <i32>::sse_encode(37, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::MissingCachedScripts(field0, field1) => {
                <i32>::sse_encode(38, serializer);
                <usize>::sse_encode(field0, serializer);
                <usize>::sse_encode(field1, serializer);
            }
            crate::api::error::BdkError::Electrum(field0) => {
                <i32>::sse_encode(39, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Esplora(field0) => {
                <i32>::sse_encode(40, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Sled(field0) => {
                <i32>::sse_encode(41, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Rpc(field0) => {
                <i32>::sse_encode(42, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::Rusqlite(field0) => {
                <i32>::sse_encode(43, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidInput(field0) => {
                <i32>::sse_encode(44, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidLockTime(field0) => {
                <i32>::sse_encode(45, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::BdkError::InvalidTransaction(field0) => {
                <i32>::sse_encode(46, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::key::BdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::keys::bip39::Mnemonic>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::types::BdkPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<bdk::descriptor::Policy>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::psbt::BdkPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<std :: sync :: Mutex < bdk :: bitcoin :: psbt :: PartiallySignedTransaction >>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::types::BdkScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.bytes, serializer);
    }
}

impl SseEncode for crate::api::types::BdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::BdkTransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::types::BdkTransaction>>::sse_encode(self.transaction, serializer);
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.received, serializer);
        <u64>::sse_encode(self.sent, serializer);
        <Option<u64>>::sse_encode(self.fee, serializer);
        <Option<crate::api::types::BlockTime>>::sse_encode(self.confirmation_time, serializer);
    }
}

impl SseEncode for crate::api::types::BdkTxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::OutPoint>::sse_encode(self.previous_output, serializer);
        <Option<crate::api::types::BdkScriptBuf>>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for crate::api::types::BdkTxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <crate::api::types::BdkScriptBuf>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for crate::api::wallet::BdkWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>>>::sse_encode(
            self.ptr, serializer,
        );
    }
}

impl SseEncode for crate::api::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::api::blockchain::BlockchainConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::blockchain::BlockchainConfig::Electrum { config } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::blockchain::ElectrumConfig>::sse_encode(config, serializer);
            }
            crate::api::blockchain::BlockchainConfig::Esplora { config } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::blockchain::EsploraConfig>::sse_encode(config, serializer);
            }
            crate::api::blockchain::BlockchainConfig::Rpc { config } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::blockchain::RpcConfig>::sse_encode(config, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::ChangeSpendPolicy::ChangeAllowed => 0,
                crate::api::types::ChangeSpendPolicy::OnlyChange => 1,
                crate::api::types::ChangeSpendPolicy::ChangeForbidden => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::Condition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.csv, serializer);
        <Option<crate::api::types::LockTime>>::sse_encode(self.timelock, serializer);
    }
}

impl SseEncode for crate::api::error::ConsensusError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::ConsensusError::Io(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::ConsensusError::OversizedVectorAllocation { requested, max } => {
                <i32>::sse_encode(1, serializer);
                <usize>::sse_encode(requested, serializer);
                <usize>::sse_encode(max, serializer);
            }
            crate::api::error::ConsensusError::InvalidChecksum { expected, actual } => {
                <i32>::sse_encode(2, serializer);
                <[u8; 4]>::sse_encode(expected, serializer);
                <[u8; 4]>::sse_encode(actual, serializer);
            }
            crate::api::error::ConsensusError::NonMinimalVarInt => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::ConsensusError::ParseFailed(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::ConsensusError::UnsupportedSegwitFlag(field0) => {
                <i32>::sse_encode(5, serializer);
                <u8>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::DatabaseConfig::Memory => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::DatabaseConfig::Sqlite { config } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::SqliteDbConfiguration>::sse_encode(config, serializer);
            }
            crate::api::types::DatabaseConfig::Sled { config } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::SledDbConfiguration>::sse_encode(config, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::error::DescriptorError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::DescriptorError::InvalidHdKeyPath => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::error::DescriptorError::InvalidDescriptorChecksum => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::error::DescriptorError::HardenedDerivationXpub => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::error::DescriptorError::MultiPath => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::error::DescriptorError::Key(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Policy(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::InvalidDescriptorCharacter(field0) => {
                <i32>::sse_encode(6, serializer);
                <u8>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Bip32(field0) => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Base58(field0) => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Pk(field0) => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Miniscript(field0) => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::error::DescriptorError::Hex(field0) => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::blockchain::ElectrumConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.socks5, serializer);
        <u8>::sse_encode(self.retry, serializer);
        <Option<u8>>::sse_encode(self.timeout, serializer);
        <u64>::sse_encode(self.stop_gap, serializer);
        <bool>::sse_encode(self.validate_domain, serializer);
    }
}

impl SseEncode for crate::api::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.base_url, serializer);
        <Option<String>>::sse_encode(self.proxy, serializer);
        <Option<u8>>::sse_encode(self.concurrency, serializer);
        <u64>::sse_encode(self.stop_gap, serializer);
        <Option<u64>>::sse_encode(self.timeout, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::FeeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.sat_per_vb, serializer);
    }
}

impl SseEncode for crate::api::error::HexError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::error::HexError::InvalidChar(field0) => {
                <i32>::sse_encode(0, serializer);
                <u8>::sse_encode(field0, serializer);
            }
            crate::api::error::HexError::OddLengthString(field0) => {
                <i32>::sse_encode(1, serializer);
                <usize>::sse_encode(field0, serializer);
            }
            crate::api::error::HexError::InvalidLength(field0, field1) => {
                <i32>::sse_encode(2, serializer);
                <usize>::sse_encode(field0, serializer);
                <usize>::sse_encode(field1, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::Input {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::KeychainKind::ExternalChain => 0,
                crate::api::types::KeychainKind::InternalChain => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<crate::api::types::BdkPolicy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::BdkPolicy>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::BdkTransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::BdkTransactionDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::BdkTxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::BdkTxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::BdkTxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::BdkTxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::Condition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::Condition>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::LocalUtxo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::OutPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PkOrF> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PkOrF>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(Vec<u32>, Vec<crate::api::types::Condition>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(Vec<u32>, Vec<crate::api::types::Condition>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Vec<u32>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Vec<u32>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(u32, Vec<crate::api::types::Condition>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(u32, Vec<crate::api::types::Condition>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::ScriptAmount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::types::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::OutPoint>::sse_encode(self.outpoint, serializer);
        <crate::api::types::BdkTxOut>::sse_encode(self.txout, serializer);
        <crate::api::types::KeychainKind>::sse_encode(self.keychain, serializer);
        <bool>::sse_encode(self.is_spent, serializer);
    }
}

impl SseEncode for crate::api::types::LockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::LockTime::Blocks(field0) => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::api::types::LockTime::Seconds(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Testnet => 0,
                crate::api::types::Network::Regtest => 1,
                crate::api::types::Network::Bitcoin => 2,
                crate::api::types::Network::Signet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<std::collections::HashMap<String, Vec<u32>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <std::collections::HashMap<String, Vec<u32>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::BdkAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::BdkAddress>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::descriptor::BdkDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::descriptor::BdkDescriptor>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::BdkPolicy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::BdkPolicy>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::BdkScriptBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::BdkScriptBuf>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::BdkTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::BdkTransaction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::BlockTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::FeeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::FeeRate>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::LockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::LockTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PsbtSigHashType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PsbtSigHashType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::RbfValue>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(crate::api::types::OutPoint, crate::api::types::Input, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(crate::api::types::OutPoint, crate::api::types::Input, usize)>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::blockchain::RpcSyncParams> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::blockchain::RpcSyncParams>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::SignOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::Payload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Payload::PubkeyHash { pubkey_hash } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(pubkey_hash, serializer);
            }
            crate::api::types::Payload::ScriptHash { script_hash } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(script_hash, serializer);
            }
            crate::api::types::Payload::WitnessProgram { version, program } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::WitnessVersion>::sse_encode(version, serializer);
                <Vec<u8>>::sse_encode(program, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PkOrF {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PkOrF::Pubkey { value } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::api::types::PkOrF::XOnlyPubkey { value } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::api::types::PkOrF::Fingerprint { value } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(value, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PsbtSigHashType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for crate::api::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::RbfValue::RbfDefault => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::RbfValue::Value(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for (crate::api::types::BdkAddress, u32) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::BdkAddress>::sse_encode(self.0, serializer);
        <u32>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        crate::api::psbt::BdkPsbt,
        crate::api::types::BdkTransactionDetails,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::psbt::BdkPsbt>::sse_encode(self.0, serializer);
        <crate::api::types::BdkTransactionDetails>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (Vec<u32>, Vec<crate::api::types::Condition>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u32>>::sse_encode(self.0, serializer);
        <Vec<crate::api::types::Condition>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (crate::api::types::OutPoint, crate::api::types::Input, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::OutPoint>::sse_encode(self.0, serializer);
        <crate::api::types::Input>::sse_encode(self.1, serializer);
        <usize>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, Vec<u32>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Vec<u32>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (u32, Vec<crate::api::types::Condition>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.0, serializer);
        <Vec<crate::api::types::Condition>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::blockchain::RpcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <crate::api::blockchain::Auth>::sse_encode(self.auth, serializer);
        <crate::api::types::Network>::sse_encode(self.network, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <Option<crate::api::blockchain::RpcSyncParams>>::sse_encode(self.sync_params, serializer);
    }
}

impl SseEncode for crate::api::blockchain::RpcSyncParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.start_script_count, serializer);
        <u64>::sse_encode(self.start_time, serializer);
        <bool>::sse_encode(self.force_start_time, serializer);
        <u64>::sse_encode(self.poll_rate_sec, serializer);
    }
}

impl SseEncode for crate::api::types::Satisfaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Satisfaction::Partial {
                n,
                m,
                items,
                sorted,
                conditions,
            } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(n, serializer);
                <u64>::sse_encode(m, serializer);
                <Vec<u64>>::sse_encode(items, serializer);
                <Option<bool>>::sse_encode(sorted, serializer);
                <std::collections::HashMap<u32, Vec<crate::api::types::Condition>>>::sse_encode(
                    conditions, serializer,
                );
            }
            crate::api::types::Satisfaction::PartialComplete {
                n,
                m,
                items,
                sorted,
                conditions,
            } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(n, serializer);
                <u64>::sse_encode(m, serializer);
                <Vec<u64>>::sse_encode(items, serializer);
                <Option<bool>>::sse_encode(sorted, serializer);
                <std::collections::HashMap<Vec<u32>, Vec<crate::api::types::Condition>>>::sse_encode(conditions, serializer);
            }
            crate::api::types::Satisfaction::Complete { condition } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::Condition>::sse_encode(condition, serializer);
            }
            crate::api::types::Satisfaction::None { msg } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(msg, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::SatisfiableItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::SatisfiableItem::EcdsaSignature { key } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::PkOrF>::sse_encode(key, serializer);
            }
            crate::api::types::SatisfiableItem::SchnorrSignature { key } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PkOrF>::sse_encode(key, serializer);
            }
            crate::api::types::SatisfiableItem::Sha256Preimage { hash } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(hash, serializer);
            }
            crate::api::types::SatisfiableItem::Hash256Preimage { hash } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(hash, serializer);
            }
            crate::api::types::SatisfiableItem::Ripemd160Preimage { hash } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(hash, serializer);
            }
            crate::api::types::SatisfiableItem::Hash160Preimage { hash } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(hash, serializer);
            }
            crate::api::types::SatisfiableItem::AbsoluteTimelock { value } => {
                <i32>::sse_encode(6, serializer);
                <crate::api::types::LockTime>::sse_encode(value, serializer);
            }
            crate::api::types::SatisfiableItem::RelativeTimelock { value } => {
                <i32>::sse_encode(7, serializer);
                <u32>::sse_encode(value, serializer);
            }
            crate::api::types::SatisfiableItem::Multisig { keys, threshold } => {
                <i32>::sse_encode(8, serializer);
                <Vec<crate::api::types::PkOrF>>::sse_encode(keys, serializer);
                <u64>::sse_encode(threshold, serializer);
            }
            crate::api::types::SatisfiableItem::Thresh { items, threshold } => {
                <i32>::sse_encode(9, serializer);
                <Vec<crate::api::types::BdkPolicy>>::sse_encode(items, serializer);
                <u64>::sse_encode(threshold, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::BdkScriptBuf>::sse_encode(self.script, serializer);
        <u64>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::api::types::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.trust_witness_utxo, serializer);
        <Option<u32>>::sse_encode(self.assume_height, serializer);
        <bool>::sse_encode(self.allow_all_sighashes, serializer);
        <bool>::sse_encode(self.remove_partial_sigs, serializer);
        <bool>::sse_encode(self.try_finalize, serializer);
        <bool>::sse_encode(self.sign_with_tap_internal_key, serializer);
        <bool>::sse_encode(self.allow_grinding, serializer);
    }
}

impl SseEncode for crate::api::types::SledDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
        <String>::sse_encode(self.tree_name, serializer);
    }
}

impl SseEncode for crate::api::types::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::types::Variant {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Variant::Bech32 => 0,
                crate::api::types::Variant::Bech32m => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::WitnessVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::WitnessVersion::V0 => 0,
                crate::api::types::WitnessVersion::V1 => 1,
                crate::api::types::WitnessVersion::V2 => 2,
                crate::api::types::WitnessVersion::V3 => 3,
                crate::api::types::WitnessVersion::V4 => 4,
                crate::api::types::WitnessVersion::V5 => 5,
                crate::api::types::WitnessVersion::V6 => 6,
                crate::api::types::WitnessVersion::V7 => 7,
                crate::api::types::WitnessVersion::V8 => 8,
                crate::api::types::WitnessVersion::V9 => 9,
                crate::api::types::WitnessVersion::V10 => 10,
                crate::api::types::WitnessVersion::V11 => 11,
                crate::api::types::WitnessVersion::V12 => 12,
                crate::api::types::WitnessVersion::V13 => 13,
                crate::api::types::WitnessVersion::V14 => 14,
                crate::api::types::WitnessVersion::V15 => 15,
                crate::api::types::WitnessVersion::V16 => 16,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::WordCount::Words12 => 0,
                crate::api::types::WordCount::Words18 => 1,
                crate::api::types::WordCount::Words24 => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<std::collections::HashMap<String, Vec<u32>>>
        for *mut wire_cst_list_record_string_list_prim_u_32_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<String, Vec<u32>> {
            let vec: Vec<(String, Vec<u32>)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl CstDecode<std::collections::HashMap<Vec<u32>, Vec<crate::api::types::Condition>>>
        for *mut wire_cst_list_record_list_prim_u_32_strict_list_condition
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> std::collections::HashMap<Vec<u32>, Vec<crate::api::types::Condition>> {
            let vec: Vec<(Vec<u32>, Vec<crate::api::types::Condition>)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl CstDecode<std::collections::HashMap<u32, Vec<crate::api::types::Condition>>>
        for *mut wire_cst_list_record_u_32_list_condition
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<u32, Vec<crate::api::types::Condition>> {
            let vec: Vec<(u32, Vec<crate::api::types::Condition>)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::bitcoin::Address>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::bitcoin::Address> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::bitcoin::bip32::DerivationPath> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::blockchain::AnyBlockchain>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::blockchain::AnyBlockchain> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::descriptor::ExtendedDescriptor>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::descriptor::ExtendedDescriptor> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::descriptor::Policy>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::descriptor::Policy> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::keys::DescriptorPublicKey>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::keys::DescriptorPublicKey> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::keys::DescriptorSecretKey>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::keys::DescriptorSecretKey> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::keys::KeyMap>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::keys::KeyMap> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<bdk::keys::bip39::Mnemonic>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<bdk::keys::bip39::Mnemonic> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<std::sync::Mutex<bdk::Wallet<bdk::database::AnyDatabase>>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<std::sync::Mutex<bdk::bitcoin::psbt::PartiallySignedTransaction>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<std::sync::Mutex<bdk::bitcoin::psbt::PartiallySignedTransaction>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::error::AddressError> for wire_cst_address_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::AddressError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Base58 };
                    crate::api::error::AddressError::Base58(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.Bech32 };
                    crate::api::error::AddressError::Bech32(ans.field0.cst_decode())
                }
                2 => crate::api::error::AddressError::EmptyBech32Payload,
                3 => {
                    let ans = unsafe { self.kind.InvalidBech32Variant };
                    crate::api::error::AddressError::InvalidBech32Variant {
                        expected: ans.expected.cst_decode(),
                        found: ans.found.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.InvalidWitnessVersion };
                    crate::api::error::AddressError::InvalidWitnessVersion(ans.field0.cst_decode())
                }
                5 => {
                    let ans = unsafe { self.kind.UnparsableWitnessVersion };
                    crate::api::error::AddressError::UnparsableWitnessVersion(
                        ans.field0.cst_decode(),
                    )
                }
                6 => crate::api::error::AddressError::MalformedWitnessVersion,
                7 => {
                    let ans = unsafe { self.kind.InvalidWitnessProgramLength };
                    crate::api::error::AddressError::InvalidWitnessProgramLength(
                        ans.field0.cst_decode(),
                    )
                }
                8 => {
                    let ans = unsafe { self.kind.InvalidSegwitV0ProgramLength };
                    crate::api::error::AddressError::InvalidSegwitV0ProgramLength(
                        ans.field0.cst_decode(),
                    )
                }
                9 => crate::api::error::AddressError::UncompressedPubkey,
                10 => crate::api::error::AddressError::ExcessiveScriptSize,
                11 => crate::api::error::AddressError::UnrecognizedScript,
                12 => {
                    let ans = unsafe { self.kind.UnknownAddressType };
                    crate::api::error::AddressError::UnknownAddressType(ans.field0.cst_decode())
                }
                13 => {
                    let ans = unsafe { self.kind.NetworkValidation };
                    crate::api::error::AddressError::NetworkValidation {
                        network_required: ans.network_required.cst_decode(),
                        network_found: ans.network_found.cst_decode(),
                        address: ans.address.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::AddressIndex> for wire_cst_address_index {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::AddressIndex {
            match self.tag {
                0 => crate::api::types::AddressIndex::Increase,
                1 => crate::api::types::AddressIndex::LastUnused,
                2 => {
                    let ans = unsafe { self.kind.Peek };
                    crate::api::types::AddressIndex::Peek {
                        index: ans.index.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Reset };
                    crate::api::types::AddressIndex::Reset {
                        index: ans.index.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::Auth> for wire_cst_auth {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::Auth {
            match self.tag {
                0 => crate::api::blockchain::Auth::None,
                1 => {
                    let ans = unsafe { self.kind.UserPass };
                    crate::api::blockchain::Auth::UserPass {
                        username: ans.username.cst_decode(),
                        password: ans.password.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Cookie };
                    crate::api::blockchain::Auth::Cookie {
                        file: ans.file.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Balance> for wire_cst_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Balance {
            crate::api::types::Balance {
                immature: self.immature.cst_decode(),
                trusted_pending: self.trusted_pending.cst_decode(),
                untrusted_pending: self.untrusted_pending.cst_decode(),
                confirmed: self.confirmed.cst_decode(),
                spendable: self.spendable.cst_decode(),
                total: self.total.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkAddress> for wire_cst_bdk_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkAddress {
            crate::api::types::BdkAddress {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::BdkBlockchain> for wire_cst_bdk_blockchain {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::BdkBlockchain {
            crate::api::blockchain::BdkBlockchain {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::key::BdkDerivationPath> for wire_cst_bdk_derivation_path {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDerivationPath {
            crate::api::key::BdkDerivationPath {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::descriptor::BdkDescriptor> for wire_cst_bdk_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::BdkDescriptor {
            crate::api::descriptor::BdkDescriptor {
                extended_descriptor: self.extended_descriptor.cst_decode(),
                key_map: self.key_map.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::key::BdkDescriptorPublicKey> for wire_cst_bdk_descriptor_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDescriptorPublicKey {
            crate::api::key::BdkDescriptorPublicKey {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::key::BdkDescriptorSecretKey> for wire_cst_bdk_descriptor_secret_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDescriptorSecretKey {
            crate::api::key::BdkDescriptorSecretKey {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::BdkError> for wire_cst_bdk_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::BdkError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Hex };
                    crate::api::error::BdkError::Hex(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.Consensus };
                    crate::api::error::BdkError::Consensus(ans.field0.cst_decode())
                }
                2 => {
                    let ans = unsafe { self.kind.VerifyTransaction };
                    crate::api::error::BdkError::VerifyTransaction(ans.field0.cst_decode())
                }
                3 => {
                    let ans = unsafe { self.kind.Address };
                    crate::api::error::BdkError::Address(ans.field0.cst_decode())
                }
                4 => {
                    let ans = unsafe { self.kind.Descriptor };
                    crate::api::error::BdkError::Descriptor(ans.field0.cst_decode())
                }
                5 => {
                    let ans = unsafe { self.kind.InvalidU32Bytes };
                    crate::api::error::BdkError::InvalidU32Bytes(ans.field0.cst_decode())
                }
                6 => {
                    let ans = unsafe { self.kind.Generic };
                    crate::api::error::BdkError::Generic(ans.field0.cst_decode())
                }
                7 => crate::api::error::BdkError::ScriptDoesntHaveAddressForm,
                8 => crate::api::error::BdkError::NoRecipients,
                9 => crate::api::error::BdkError::NoUtxosSelected,
                10 => {
                    let ans = unsafe { self.kind.OutputBelowDustLimit };
                    crate::api::error::BdkError::OutputBelowDustLimit(ans.field0.cst_decode())
                }
                11 => {
                    let ans = unsafe { self.kind.InsufficientFunds };
                    crate::api::error::BdkError::InsufficientFunds {
                        needed: ans.needed.cst_decode(),
                        available: ans.available.cst_decode(),
                    }
                }
                12 => crate::api::error::BdkError::BnBTotalTriesExceeded,
                13 => crate::api::error::BdkError::BnBNoExactMatch,
                14 => crate::api::error::BdkError::UnknownUtxo,
                15 => crate::api::error::BdkError::TransactionNotFound,
                16 => crate::api::error::BdkError::TransactionConfirmed,
                17 => crate::api::error::BdkError::IrreplaceableTransaction,
                18 => {
                    let ans = unsafe { self.kind.FeeRateTooLow };
                    crate::api::error::BdkError::FeeRateTooLow {
                        needed: ans.needed.cst_decode(),
                    }
                }
                19 => {
                    let ans = unsafe { self.kind.FeeTooLow };
                    crate::api::error::BdkError::FeeTooLow {
                        needed: ans.needed.cst_decode(),
                    }
                }
                20 => crate::api::error::BdkError::FeeRateUnavailable,
                21 => {
                    let ans = unsafe { self.kind.MissingKeyOrigin };
                    crate::api::error::BdkError::MissingKeyOrigin(ans.field0.cst_decode())
                }
                22 => {
                    let ans = unsafe { self.kind.Key };
                    crate::api::error::BdkError::Key(ans.field0.cst_decode())
                }
                23 => crate::api::error::BdkError::ChecksumMismatch,
                24 => {
                    let ans = unsafe { self.kind.SpendingPolicyRequired };
                    crate::api::error::BdkError::SpendingPolicyRequired(ans.field0.cst_decode())
                }
                25 => {
                    let ans = unsafe { self.kind.InvalidPolicyPathError };
                    crate::api::error::BdkError::InvalidPolicyPathError(ans.field0.cst_decode())
                }
                26 => {
                    let ans = unsafe { self.kind.Signer };
                    crate::api::error::BdkError::Signer(ans.field0.cst_decode())
                }
                27 => {
                    let ans = unsafe { self.kind.InvalidNetwork };
                    crate::api::error::BdkError::InvalidNetwork {
                        requested: ans.requested.cst_decode(),
                        found: ans.found.cst_decode(),
                    }
                }
                28 => {
                    let ans = unsafe { self.kind.InvalidOutpoint };
                    crate::api::error::BdkError::InvalidOutpoint(ans.field0.cst_decode())
                }
                29 => {
                    let ans = unsafe { self.kind.Encode };
                    crate::api::error::BdkError::Encode(ans.field0.cst_decode())
                }
                30 => {
                    let ans = unsafe { self.kind.Miniscript };
                    crate::api::error::BdkError::Miniscript(ans.field0.cst_decode())
                }
                31 => {
                    let ans = unsafe { self.kind.MiniscriptPsbt };
                    crate::api::error::BdkError::MiniscriptPsbt(ans.field0.cst_decode())
                }
                32 => {
                    let ans = unsafe { self.kind.Bip32 };
                    crate::api::error::BdkError::Bip32(ans.field0.cst_decode())
                }
                33 => {
                    let ans = unsafe { self.kind.Bip39 };
                    crate::api::error::BdkError::Bip39(ans.field0.cst_decode())
                }
                34 => {
                    let ans = unsafe { self.kind.Secp256k1 };
                    crate::api::error::BdkError::Secp256k1(ans.field0.cst_decode())
                }
                35 => {
                    let ans = unsafe { self.kind.Json };
                    crate::api::error::BdkError::Json(ans.field0.cst_decode())
                }
                36 => {
                    let ans = unsafe { self.kind.Psbt };
                    crate::api::error::BdkError::Psbt(ans.field0.cst_decode())
                }
                37 => {
                    let ans = unsafe { self.kind.PsbtParse };
                    crate::api::error::BdkError::PsbtParse(ans.field0.cst_decode())
                }
                38 => {
                    let ans = unsafe { self.kind.MissingCachedScripts };
                    crate::api::error::BdkError::MissingCachedScripts(
                        ans.field0.cst_decode(),
                        ans.field1.cst_decode(),
                    )
                }
                39 => {
                    let ans = unsafe { self.kind.Electrum };
                    crate::api::error::BdkError::Electrum(ans.field0.cst_decode())
                }
                40 => {
                    let ans = unsafe { self.kind.Esplora };
                    crate::api::error::BdkError::Esplora(ans.field0.cst_decode())
                }
                41 => {
                    let ans = unsafe { self.kind.Sled };
                    crate::api::error::BdkError::Sled(ans.field0.cst_decode())
                }
                42 => {
                    let ans = unsafe { self.kind.Rpc };
                    crate::api::error::BdkError::Rpc(ans.field0.cst_decode())
                }
                43 => {
                    let ans = unsafe { self.kind.Rusqlite };
                    crate::api::error::BdkError::Rusqlite(ans.field0.cst_decode())
                }
                44 => {
                    let ans = unsafe { self.kind.InvalidInput };
                    crate::api::error::BdkError::InvalidInput(ans.field0.cst_decode())
                }
                45 => {
                    let ans = unsafe { self.kind.InvalidLockTime };
                    crate::api::error::BdkError::InvalidLockTime(ans.field0.cst_decode())
                }
                46 => {
                    let ans = unsafe { self.kind.InvalidTransaction };
                    crate::api::error::BdkError::InvalidTransaction(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::key::BdkMnemonic> for wire_cst_bdk_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkMnemonic {
            crate::api::key::BdkMnemonic {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkPolicy> for wire_cst_bdk_policy {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkPolicy {
            crate::api::types::BdkPolicy {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::psbt::BdkPsbt> for wire_cst_bdk_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::psbt::BdkPsbt {
            crate::api::psbt::BdkPsbt {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkScriptBuf> for wire_cst_bdk_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkScriptBuf {
            crate::api::types::BdkScriptBuf {
                bytes: self.bytes.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkTransaction> for wire_cst_bdk_transaction {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkTransaction {
            crate::api::types::BdkTransaction {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkTransactionDetails> for wire_cst_bdk_transaction_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkTransactionDetails {
            crate::api::types::BdkTransactionDetails {
                transaction: self.transaction.cst_decode(),
                txid: self.txid.cst_decode(),
                received: self.received.cst_decode(),
                sent: self.sent.cst_decode(),
                fee: self.fee.cst_decode(),
                confirmation_time: self.confirmation_time.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkTxIn> for wire_cst_bdk_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkTxIn {
            crate::api::types::BdkTxIn {
                previous_output: self.previous_output.cst_decode(),
                script_sig: self.script_sig.cst_decode(),
                sequence: self.sequence.cst_decode(),
                witness: self.witness.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BdkTxOut> for wire_cst_bdk_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkTxOut {
            crate::api::types::BdkTxOut {
                value: self.value.cst_decode(),
                script_pubkey: self.script_pubkey.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::wallet::BdkWallet> for wire_cst_bdk_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::BdkWallet {
            crate::api::wallet::BdkWallet {
                ptr: self.ptr.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BlockTime> for wire_cst_block_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BlockTime {
            crate::api::types::BlockTime {
                height: self.height.cst_decode(),
                timestamp: self.timestamp.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::BlockchainConfig> for wire_cst_blockchain_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::BlockchainConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Electrum };
                    crate::api::blockchain::BlockchainConfig::Electrum {
                        config: ans.config.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Esplora };
                    crate::api::blockchain::BlockchainConfig::Esplora {
                        config: ans.config.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Rpc };
                    crate::api::blockchain::BlockchainConfig::Rpc {
                        config: ans.config.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::AddressError> for *mut wire_cst_address_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::AddressError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::error::AddressError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::AddressIndex> for *mut wire_cst_address_index {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::AddressIndex {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::AddressIndex>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BdkAddress> for *mut wire_cst_bdk_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkAddress {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BdkAddress>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::blockchain::BdkBlockchain> for *mut wire_cst_bdk_blockchain {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::BdkBlockchain {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::BdkBlockchain>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::BdkDerivationPath> for *mut wire_cst_bdk_derivation_path {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDerivationPath {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::BdkDerivationPath>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::descriptor::BdkDescriptor> for *mut wire_cst_bdk_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::BdkDescriptor {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::descriptor::BdkDescriptor>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::BdkDescriptorPublicKey>
        for *mut wire_cst_bdk_descriptor_public_key
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDescriptorPublicKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::BdkDescriptorPublicKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::BdkDescriptorSecretKey>
        for *mut wire_cst_bdk_descriptor_secret_key
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkDescriptorSecretKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::BdkDescriptorSecretKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::key::BdkMnemonic> for *mut wire_cst_bdk_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::key::BdkMnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::key::BdkMnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BdkPolicy> for *mut wire_cst_bdk_policy {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkPolicy {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BdkPolicy>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::psbt::BdkPsbt> for *mut wire_cst_bdk_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::psbt::BdkPsbt {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::psbt::BdkPsbt>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BdkScriptBuf> for *mut wire_cst_bdk_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkScriptBuf {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BdkScriptBuf>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BdkTransaction> for *mut wire_cst_bdk_transaction {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BdkTransaction {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BdkTransaction>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::wallet::BdkWallet> for *mut wire_cst_bdk_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::BdkWallet {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::wallet::BdkWallet>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BlockTime> for *mut wire_cst_block_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BlockTime {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BlockTime>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::blockchain::BlockchainConfig> for *mut wire_cst_blockchain_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::BlockchainConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::BlockchainConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::types::Condition> for *mut wire_cst_condition {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Condition {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Condition>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::error::ConsensusError> for *mut wire_cst_consensus_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::ConsensusError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::error::ConsensusError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::DatabaseConfig> for *mut wire_cst_database_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::DatabaseConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::DatabaseConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::error::DescriptorError> for *mut wire_cst_descriptor_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::DescriptorError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::error::DescriptorError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::blockchain::ElectrumConfig> for *mut wire_cst_electrum_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::ElectrumConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::ElectrumConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::blockchain::EsploraConfig> for *mut wire_cst_esplora_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::EsploraConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::EsploraConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<f32> for *mut f32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::types::FeeRate> for *mut wire_cst_fee_rate {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FeeRate {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::FeeRate>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::error::HexError> for *mut wire_cst_hex_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::HexError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::error::HexError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LocalUtxo> for *mut wire_cst_local_utxo {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LocalUtxo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LocalUtxo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LockTime> for *mut wire_cst_lock_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LockTime {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LockTime>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::OutPoint> for *mut wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::OutPoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PkOrF> for *mut wire_cst_pk_or_f {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PkOrF {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PkOrF>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PsbtSigHashType> for *mut wire_cst_psbt_sig_hash_type {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PsbtSigHashType {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PsbtSigHashType>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::RbfValue> for *mut wire_cst_rbf_value {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::RbfValue {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::RbfValue>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<(crate::api::types::OutPoint, crate::api::types::Input, usize)>
        for *mut wire_cst_record_out_point_input_usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (crate::api::types::OutPoint, crate::api::types::Input, usize) {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<(crate::api::types::OutPoint, crate::api::types::Input, usize)>::cst_decode(
                *wrap,
            )
            .into()
        }
    }
    impl CstDecode<crate::api::blockchain::RpcConfig> for *mut wire_cst_rpc_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::RpcConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::RpcConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::blockchain::RpcSyncParams> for *mut wire_cst_rpc_sync_params {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::RpcSyncParams {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::RpcSyncParams>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SignOptions> for *mut wire_cst_sign_options {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SignOptions {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SignOptions>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SledDbConfiguration> for *mut wire_cst_sled_db_configuration {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SledDbConfiguration {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SledDbConfiguration>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SqliteDbConfiguration> for *mut wire_cst_sqlite_db_configuration {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SqliteDbConfiguration {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SqliteDbConfiguration>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u8> for *mut u8 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::types::Condition> for wire_cst_condition {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Condition {
            crate::api::types::Condition {
                csv: self.csv.cst_decode(),
                timelock: self.timelock.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::ConsensusError> for wire_cst_consensus_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::ConsensusError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Io };
                    crate::api::error::ConsensusError::Io(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.OversizedVectorAllocation };
                    crate::api::error::ConsensusError::OversizedVectorAllocation {
                        requested: ans.requested.cst_decode(),
                        max: ans.max.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.InvalidChecksum };
                    crate::api::error::ConsensusError::InvalidChecksum {
                        expected: ans.expected.cst_decode(),
                        actual: ans.actual.cst_decode(),
                    }
                }
                3 => crate::api::error::ConsensusError::NonMinimalVarInt,
                4 => {
                    let ans = unsafe { self.kind.ParseFailed };
                    crate::api::error::ConsensusError::ParseFailed(ans.field0.cst_decode())
                }
                5 => {
                    let ans = unsafe { self.kind.UnsupportedSegwitFlag };
                    crate::api::error::ConsensusError::UnsupportedSegwitFlag(
                        ans.field0.cst_decode(),
                    )
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::DatabaseConfig> for wire_cst_database_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::DatabaseConfig {
            match self.tag {
                0 => crate::api::types::DatabaseConfig::Memory,
                1 => {
                    let ans = unsafe { self.kind.Sqlite };
                    crate::api::types::DatabaseConfig::Sqlite {
                        config: ans.config.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Sled };
                    crate::api::types::DatabaseConfig::Sled {
                        config: ans.config.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::error::DescriptorError> for wire_cst_descriptor_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::DescriptorError {
            match self.tag {
                0 => crate::api::error::DescriptorError::InvalidHdKeyPath,
                1 => crate::api::error::DescriptorError::InvalidDescriptorChecksum,
                2 => crate::api::error::DescriptorError::HardenedDerivationXpub,
                3 => crate::api::error::DescriptorError::MultiPath,
                4 => {
                    let ans = unsafe { self.kind.Key };
                    crate::api::error::DescriptorError::Key(ans.field0.cst_decode())
                }
                5 => {
                    let ans = unsafe { self.kind.Policy };
                    crate::api::error::DescriptorError::Policy(ans.field0.cst_decode())
                }
                6 => {
                    let ans = unsafe { self.kind.InvalidDescriptorCharacter };
                    crate::api::error::DescriptorError::InvalidDescriptorCharacter(
                        ans.field0.cst_decode(),
                    )
                }
                7 => {
                    let ans = unsafe { self.kind.Bip32 };
                    crate::api::error::DescriptorError::Bip32(ans.field0.cst_decode())
                }
                8 => {
                    let ans = unsafe { self.kind.Base58 };
                    crate::api::error::DescriptorError::Base58(ans.field0.cst_decode())
                }
                9 => {
                    let ans = unsafe { self.kind.Pk };
                    crate::api::error::DescriptorError::Pk(ans.field0.cst_decode())
                }
                10 => {
                    let ans = unsafe { self.kind.Miniscript };
                    crate::api::error::DescriptorError::Miniscript(ans.field0.cst_decode())
                }
                11 => {
                    let ans = unsafe { self.kind.Hex };
                    crate::api::error::DescriptorError::Hex(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::ElectrumConfig> for wire_cst_electrum_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::ElectrumConfig {
            crate::api::blockchain::ElectrumConfig {
                url: self.url.cst_decode(),
                socks5: self.socks5.cst_decode(),
                retry: self.retry.cst_decode(),
                timeout: self.timeout.cst_decode(),
                stop_gap: self.stop_gap.cst_decode(),
                validate_domain: self.validate_domain.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::EsploraConfig> for wire_cst_esplora_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::EsploraConfig {
            crate::api::blockchain::EsploraConfig {
                base_url: self.base_url.cst_decode(),
                proxy: self.proxy.cst_decode(),
                concurrency: self.concurrency.cst_decode(),
                stop_gap: self.stop_gap.cst_decode(),
                timeout: self.timeout.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::FeeRate> for wire_cst_fee_rate {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::FeeRate {
            crate::api::types::FeeRate {
                sat_per_vb: self.sat_per_vb.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::HexError> for wire_cst_hex_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::HexError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.InvalidChar };
                    crate::api::error::HexError::InvalidChar(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.OddLengthString };
                    crate::api::error::HexError::OddLengthString(ans.field0.cst_decode())
                }
                2 => {
                    let ans = unsafe { self.kind.InvalidLength };
                    crate::api::error::HexError::InvalidLength(
                        ans.field0.cst_decode(),
                        ans.field1.cst_decode(),
                    )
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Input> for wire_cst_input {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Input {
            crate::api::types::Input {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::BdkPolicy>> for *mut wire_cst_list_bdk_policy {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::BdkPolicy> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::BdkTransactionDetails>>
        for *mut wire_cst_list_bdk_transaction_details
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::BdkTransactionDetails> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::BdkTxIn>> for *mut wire_cst_list_bdk_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::BdkTxIn> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::BdkTxOut>> for *mut wire_cst_list_bdk_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::BdkTxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::Condition>> for *mut wire_cst_list_condition {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::Condition> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::LocalUtxo>> for *mut wire_cst_list_local_utxo {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::LocalUtxo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::OutPoint>> for *mut wire_cst_list_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::OutPoint> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::PkOrF>> for *mut wire_cst_list_pk_or_f {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::PkOrF> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u32>> for *mut wire_cst_list_prim_u_32_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u32> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(Vec<u32>, Vec<crate::api::types::Condition>)>>
        for *mut wire_cst_list_record_list_prim_u_32_strict_list_condition
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(Vec<u32>, Vec<crate::api::types::Condition>)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<(String, Vec<u32>)>> for *mut wire_cst_list_record_string_list_prim_u_32_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, Vec<u32>)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<(u32, Vec<crate::api::types::Condition>)>>
        for *mut wire_cst_list_record_u_32_list_condition
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(u32, Vec<crate::api::types::Condition>)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::ScriptAmount>> for *mut wire_cst_list_script_amount {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::ScriptAmount> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::api::types::LocalUtxo> for wire_cst_local_utxo {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LocalUtxo {
            crate::api::types::LocalUtxo {
                outpoint: self.outpoint.cst_decode(),
                txout: self.txout.cst_decode(),
                keychain: self.keychain.cst_decode(),
                is_spent: self.is_spent.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::LockTime> for wire_cst_lock_time {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LockTime {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Blocks };
                    crate::api::types::LockTime::Blocks(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.Seconds };
                    crate::api::types::LockTime::Seconds(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            crate::api::types::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Payload> for wire_cst_payload {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Payload {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PubkeyHash };
                    crate::api::types::Payload::PubkeyHash {
                        pubkey_hash: ans.pubkey_hash.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.ScriptHash };
                    crate::api::types::Payload::ScriptHash {
                        script_hash: ans.script_hash.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.WitnessProgram };
                    crate::api::types::Payload::WitnessProgram {
                        version: ans.version.cst_decode(),
                        program: ans.program.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::PkOrF> for wire_cst_pk_or_f {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PkOrF {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Pubkey };
                    crate::api::types::PkOrF::Pubkey {
                        value: ans.value.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.XOnlyPubkey };
                    crate::api::types::PkOrF::XOnlyPubkey {
                        value: ans.value.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Fingerprint };
                    crate::api::types::PkOrF::Fingerprint {
                        value: ans.value.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::PsbtSigHashType> for wire_cst_psbt_sig_hash_type {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PsbtSigHashType {
            crate::api::types::PsbtSigHashType {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::RbfValue> for wire_cst_rbf_value {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::RbfValue {
            match self.tag {
                0 => crate::api::types::RbfValue::RbfDefault,
                1 => {
                    let ans = unsafe { self.kind.Value };
                    crate::api::types::RbfValue::Value(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<(crate::api::types::BdkAddress, u32)> for wire_cst_record_bdk_address_u_32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (crate::api::types::BdkAddress, u32) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl
        CstDecode<(
            crate::api::psbt::BdkPsbt,
            crate::api::types::BdkTransactionDetails,
        )> for wire_cst_record_bdk_psbt_bdk_transaction_details
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> (
            crate::api::psbt::BdkPsbt,
            crate::api::types::BdkTransactionDetails,
        ) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<(Vec<u32>, Vec<crate::api::types::Condition>)>
        for wire_cst_record_list_prim_u_32_strict_list_condition
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<u32>, Vec<crate::api::types::Condition>) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<(crate::api::types::OutPoint, crate::api::types::Input, usize)>
        for wire_cst_record_out_point_input_usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (crate::api::types::OutPoint, crate::api::types::Input, usize) {
            (
                self.field0.cst_decode(),
                self.field1.cst_decode(),
                self.field2.cst_decode(),
            )
        }
    }
    impl CstDecode<(String, Vec<u32>)> for wire_cst_record_string_list_prim_u_32_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, Vec<u32>) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<(u32, Vec<crate::api::types::Condition>)> for wire_cst_record_u_32_list_condition {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (u32, Vec<crate::api::types::Condition>) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<crate::api::blockchain::RpcConfig> for wire_cst_rpc_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::RpcConfig {
            crate::api::blockchain::RpcConfig {
                url: self.url.cst_decode(),
                auth: self.auth.cst_decode(),
                network: self.network.cst_decode(),
                wallet_name: self.wallet_name.cst_decode(),
                sync_params: self.sync_params.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::RpcSyncParams> for wire_cst_rpc_sync_params {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::RpcSyncParams {
            crate::api::blockchain::RpcSyncParams {
                start_script_count: self.start_script_count.cst_decode(),
                start_time: self.start_time.cst_decode(),
                force_start_time: self.force_start_time.cst_decode(),
                poll_rate_sec: self.poll_rate_sec.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Satisfaction> for wire_cst_satisfaction {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Satisfaction {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Partial };
                    crate::api::types::Satisfaction::Partial {
                        n: ans.n.cst_decode(),
                        m: ans.m.cst_decode(),
                        items: ans.items.cst_decode(),
                        sorted: ans.sorted.cst_decode(),
                        conditions: ans.conditions.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.PartialComplete };
                    crate::api::types::Satisfaction::PartialComplete {
                        n: ans.n.cst_decode(),
                        m: ans.m.cst_decode(),
                        items: ans.items.cst_decode(),
                        sorted: ans.sorted.cst_decode(),
                        conditions: ans.conditions.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Complete };
                    crate::api::types::Satisfaction::Complete {
                        condition: ans.condition.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.None };
                    crate::api::types::Satisfaction::None {
                        msg: ans.msg.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::SatisfiableItem> for wire_cst_satisfiable_item {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SatisfiableItem {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.EcdsaSignature };
                    crate::api::types::SatisfiableItem::EcdsaSignature {
                        key: ans.key.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.SchnorrSignature };
                    crate::api::types::SatisfiableItem::SchnorrSignature {
                        key: ans.key.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Sha256Preimage };
                    crate::api::types::SatisfiableItem::Sha256Preimage {
                        hash: ans.hash.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Hash256Preimage };
                    crate::api::types::SatisfiableItem::Hash256Preimage {
                        hash: ans.hash.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.Ripemd160Preimage };
                    crate::api::types::SatisfiableItem::Ripemd160Preimage {
                        hash: ans.hash.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.Hash160Preimage };
                    crate::api::types::SatisfiableItem::Hash160Preimage {
                        hash: ans.hash.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.AbsoluteTimelock };
                    crate::api::types::SatisfiableItem::AbsoluteTimelock {
                        value: ans.value.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.RelativeTimelock };
                    crate::api::types::SatisfiableItem::RelativeTimelock {
                        value: ans.value.cst_decode(),
                    }
                }
                8 => {
                    let ans = unsafe { self.kind.Multisig };
                    crate::api::types::SatisfiableItem::Multisig {
                        keys: ans.keys.cst_decode(),
                        threshold: ans.threshold.cst_decode(),
                    }
                }
                9 => {
                    let ans = unsafe { self.kind.Thresh };
                    crate::api::types::SatisfiableItem::Thresh {
                        items: ans.items.cst_decode(),
                        threshold: ans.threshold.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::ScriptAmount> for wire_cst_script_amount {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ScriptAmount {
            crate::api::types::ScriptAmount {
                script: self.script.cst_decode(),
                amount: self.amount.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::SignOptions> for wire_cst_sign_options {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SignOptions {
            crate::api::types::SignOptions {
                trust_witness_utxo: self.trust_witness_utxo.cst_decode(),
                assume_height: self.assume_height.cst_decode(),
                allow_all_sighashes: self.allow_all_sighashes.cst_decode(),
                remove_partial_sigs: self.remove_partial_sigs.cst_decode(),
                try_finalize: self.try_finalize.cst_decode(),
                sign_with_tap_internal_key: self.sign_with_tap_internal_key.cst_decode(),
                allow_grinding: self.allow_grinding.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::SledDbConfiguration> for wire_cst_sled_db_configuration {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SledDbConfiguration {
            crate::api::types::SledDbConfiguration {
                path: self.path.cst_decode(),
                tree_name: self.tree_name.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::SqliteDbConfiguration> for wire_cst_sqlite_db_configuration {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SqliteDbConfiguration {
            crate::api::types::SqliteDbConfiguration {
                path: self.path.cst_decode(),
            }
        }
    }
    impl CstDecode<[u8; 4]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 4] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl NewWithNullPtr for wire_cst_address_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: AddressErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_address_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_index {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: AddressIndexKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_address_index {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_auth {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: AuthKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_auth {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                immature: Default::default(),
                trusted_pending: Default::default(),
                untrusted_pending: Default::default(),
                confirmed: Default::default(),
                spendable: Default::default(),
                total: Default::default(),
            }
        }
    }
    impl Default for wire_cst_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_address {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_address {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_blockchain {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_blockchain {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_derivation_path {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_derivation_path {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_descriptor {
        fn new_with_null_ptr() -> Self {
            Self {
                extended_descriptor: Default::default(),
                key_map: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_descriptor {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_descriptor_public_key {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_descriptor_public_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_descriptor_secret_key {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_descriptor_secret_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: BdkErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_bdk_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_policy {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_policy {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_psbt {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_psbt {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_script_buf {
        fn new_with_null_ptr() -> Self {
            Self {
                bytes: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bdk_script_buf {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_transaction {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bdk_transaction {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_transaction_details {
        fn new_with_null_ptr() -> Self {
            Self {
                transaction: core::ptr::null_mut(),
                txid: core::ptr::null_mut(),
                received: Default::default(),
                sent: Default::default(),
                fee: core::ptr::null_mut(),
                confirmation_time: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bdk_transaction_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_tx_in {
        fn new_with_null_ptr() -> Self {
            Self {
                previous_output: Default::default(),
                script_sig: core::ptr::null_mut(),
                sequence: Default::default(),
                witness: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bdk_tx_in {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                script_pubkey: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bdk_wallet {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: Default::default(),
            }
        }
    }
    impl Default for wire_cst_bdk_wallet {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_block_time {
        fn new_with_null_ptr() -> Self {
            Self {
                height: Default::default(),
                timestamp: Default::default(),
            }
        }
    }
    impl Default for wire_cst_block_time {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_blockchain_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: BlockchainConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_blockchain_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_condition {
        fn new_with_null_ptr() -> Self {
            Self {
                csv: core::ptr::null_mut(),
                timelock: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_condition {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_consensus_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ConsensusErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_consensus_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_database_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: DatabaseConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_database_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_descriptor_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: DescriptorErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_descriptor_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_electrum_config {
        fn new_with_null_ptr() -> Self {
            Self {
                url: core::ptr::null_mut(),
                socks5: core::ptr::null_mut(),
                retry: Default::default(),
                timeout: core::ptr::null_mut(),
                stop_gap: Default::default(),
                validate_domain: Default::default(),
            }
        }
    }
    impl Default for wire_cst_electrum_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_esplora_config {
        fn new_with_null_ptr() -> Self {
            Self {
                base_url: core::ptr::null_mut(),
                proxy: core::ptr::null_mut(),
                concurrency: core::ptr::null_mut(),
                stop_gap: Default::default(),
                timeout: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_esplora_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_fee_rate {
        fn new_with_null_ptr() -> Self {
            Self {
                sat_per_vb: Default::default(),
            }
        }
    }
    impl Default for wire_cst_fee_rate {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_hex_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: HexErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_hex_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_input {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_input {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_local_utxo {
        fn new_with_null_ptr() -> Self {
            Self {
                outpoint: Default::default(),
                txout: Default::default(),
                keychain: Default::default(),
                is_spent: Default::default(),
            }
        }
    }
    impl Default for wire_cst_local_utxo {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lock_time {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: LockTimeKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_lock_time {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payload {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PayloadKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_payload {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pk_or_f {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PkOrFKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_pk_or_f {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt_sig_hash_type {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: Default::default(),
            }
        }
    }
    impl Default for wire_cst_psbt_sig_hash_type {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_rbf_value {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: RbfValueKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_rbf_value {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_bdk_address_u_32 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_bdk_address_u_32 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_bdk_psbt_bdk_transaction_details {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_bdk_psbt_bdk_transaction_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_list_prim_u_32_strict_list_condition {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_list_prim_u_32_strict_list_condition {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_out_point_input_usize {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
                field2: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_out_point_input_usize {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_string_list_prim_u_32_strict {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_list_prim_u_32_strict {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_u_32_list_condition {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_u_32_list_condition {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_rpc_config {
        fn new_with_null_ptr() -> Self {
            Self {
                url: core::ptr::null_mut(),
                auth: Default::default(),
                network: Default::default(),
                wallet_name: core::ptr::null_mut(),
                sync_params: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_rpc_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_rpc_sync_params {
        fn new_with_null_ptr() -> Self {
            Self {
                start_script_count: Default::default(),
                start_time: Default::default(),
                force_start_time: Default::default(),
                poll_rate_sec: Default::default(),
            }
        }
    }
    impl Default for wire_cst_rpc_sync_params {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_satisfaction {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: SatisfactionKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_satisfaction {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_satisfiable_item {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: SatisfiableItemKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_satisfiable_item {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_script_amount {
        fn new_with_null_ptr() -> Self {
            Self {
                script: Default::default(),
                amount: Default::default(),
            }
        }
    }
    impl Default for wire_cst_script_amount {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sign_options {
        fn new_with_null_ptr() -> Self {
            Self {
                trust_witness_utxo: Default::default(),
                assume_height: core::ptr::null_mut(),
                allow_all_sighashes: Default::default(),
                remove_partial_sigs: Default::default(),
                try_finalize: Default::default(),
                sign_with_tap_internal_key: Default::default(),
                allow_grinding: Default::default(),
            }
        }
    }
    impl Default for wire_cst_sign_options {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sled_db_configuration {
        fn new_with_null_ptr() -> Self {
            Self {
                path: core::ptr::null_mut(),
                tree_name: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sled_db_configuration {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sqlite_db_configuration {
        fn new_with_null_ptr() -> Self {
            Self {
                path: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sqlite_db_configuration {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_as_string(
        that: *mut wire_cst_bdk_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_from_script(
        script: *mut wire_cst_bdk_script_buf,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_from_script_impl(script, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_from_string(
        address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_from_string_impl(address, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_is_valid_for_network(
        that: *mut wire_cst_bdk_address,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_is_valid_for_network_impl(that, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_network(
        that: *mut wire_cst_bdk_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_network_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_payload(
        that: *mut wire_cst_bdk_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_payload_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_script(
        ptr: *mut wire_cst_bdk_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_script_impl(ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_address_to_qr_uri(
        that: *mut wire_cst_bdk_address,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_address_to_qr_uri_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__blockchain__bdk_blockchain_broadcast(
        port_: i64,
        ptr: *mut wire_cst_bdk_blockchain,
        transaction: *mut wire_cst_bdk_transaction,
    ) {
        wire__crate__api__blockchain__bdk_blockchain_broadcast_impl(port_, ptr, transaction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__blockchain__bdk_blockchain_create(
        port_: i64,
        blockchain_config: *mut wire_cst_blockchain_config,
    ) {
        wire__crate__api__blockchain__bdk_blockchain_create_impl(port_, blockchain_config)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__blockchain__bdk_blockchain_estimate_fee(
        port_: i64,
        that: *mut wire_cst_bdk_blockchain,
        target: u64,
    ) {
        wire__crate__api__blockchain__bdk_blockchain_estimate_fee_impl(port_, that, target)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__blockchain__bdk_blockchain_get_block_hash(
        port_: i64,
        that: *mut wire_cst_bdk_blockchain,
        height: u32,
    ) {
        wire__crate__api__blockchain__bdk_blockchain_get_block_hash_impl(port_, that, height)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__blockchain__bdk_blockchain_get_height(
        port_: i64,
        that: *mut wire_cst_bdk_blockchain,
    ) {
        wire__crate__api__blockchain__bdk_blockchain_get_height_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_derivation_path_as_string(
        that: *mut wire_cst_bdk_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_derivation_path_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_derivation_path_from_string(
        path: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_derivation_path_from_string_impl(path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_as_string(
        that: *mut wire_cst_bdk_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_create(
        descriptor: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_create_impl(descriptor, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_max_satisfaction_weight(
        that: *mut wire_cst_bdk_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_max_satisfaction_weight_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip44(
        secret_key: *mut wire_cst_bdk_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip44_impl(
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip44_public(
        public_key: *mut wire_cst_bdk_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip44_public_impl(
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip49(
        secret_key: *mut wire_cst_bdk_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip49_impl(
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip49_public(
        public_key: *mut wire_cst_bdk_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip49_public_impl(
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip84(
        secret_key: *mut wire_cst_bdk_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip84_impl(
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip84_public(
        public_key: *mut wire_cst_bdk_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip84_public_impl(
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip86(
        secret_key: *mut wire_cst_bdk_descriptor_secret_key,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip86_impl(
            secret_key,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_new_bip86_public(
        public_key: *mut wire_cst_bdk_descriptor_public_key,
        fingerprint: *mut wire_cst_list_prim_u_8_strict,
        keychain_kind: i32,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_new_bip86_public_impl(
            public_key,
            fingerprint,
            keychain_kind,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_public_key_as_string(
        that: *mut wire_cst_bdk_descriptor_public_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_public_key_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_public_key_derive(
        ptr: *mut wire_cst_bdk_descriptor_public_key,
        path: *mut wire_cst_bdk_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_public_key_derive_impl(ptr, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_public_key_extend(
        ptr: *mut wire_cst_bdk_descriptor_public_key,
        path: *mut wire_cst_bdk_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_public_key_extend_impl(ptr, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_public_key_from_string(
        public_key: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_public_key_from_string_impl(public_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_as_public(
        ptr: *mut wire_cst_bdk_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_as_public_impl(ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_as_string(
        that: *mut wire_cst_bdk_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_create(
        network: i32,
        mnemonic: *mut wire_cst_bdk_mnemonic,
        password: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_create_impl(network, mnemonic, password)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_derive(
        ptr: *mut wire_cst_bdk_descriptor_secret_key,
        path: *mut wire_cst_bdk_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_derive_impl(ptr, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_extend(
        ptr: *mut wire_cst_bdk_descriptor_secret_key,
        path: *mut wire_cst_bdk_derivation_path,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_extend_impl(ptr, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_from_string(
        port_: i64,
        secret_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__key__bdk_descriptor_secret_key_from_string_impl(port_, secret_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_descriptor_secret_key_secret_bytes(
        that: *mut wire_cst_bdk_descriptor_secret_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_descriptor_secret_key_secret_bytes_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__descriptor__bdk_descriptor_to_string_private(
        that: *mut wire_cst_bdk_descriptor,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__descriptor__bdk_descriptor_to_string_private_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_mnemonic_as_string(
        that: *mut wire_cst_bdk_mnemonic,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_mnemonic_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_mnemonic_create(
        word_count: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_mnemonic_create_impl(word_count)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_mnemonic_from_entropy(
        entropy: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_mnemonic_from_entropy_impl(entropy)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__key__bdk_mnemonic_from_string(
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__key__bdk_mnemonic_from_string_impl(mnemonic)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_as_string(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_contribution(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_contribution_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_id(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_item(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_item_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_requires_path(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_requires_path_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_policy_satisfaction(
        that: *mut wire_cst_bdk_policy,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_policy_satisfaction_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_as_string(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_combine(
        ptr: *mut wire_cst_bdk_psbt,
        other: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_combine_impl(ptr, other)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_extract_tx(
        ptr: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_extract_tx_impl(ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_fee_amount(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_fee_amount_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_fee_rate(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_fee_rate_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_from_str(
        psbt_base64: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_from_str_impl(psbt_base64)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_json_serialize(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_json_serialize_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_serialize(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_serialize_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__psbt__bdk_psbt_txid(
        that: *mut wire_cst_bdk_psbt,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__psbt__bdk_psbt_txid_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_script_buf_as_string(
        that: *mut wire_cst_bdk_script_buf,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_script_buf_as_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_script_buf_empty(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_script_buf_empty_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_script_buf_from_hex(
        s: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_script_buf_from_hex_impl(s)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_script_buf_with_capacity(
        capacity: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_script_buf_with_capacity_impl(capacity)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_create(
        version: i32,
        lock_time: *mut wire_cst_lock_time,
        input: *mut wire_cst_list_bdk_tx_in,
        output: *mut wire_cst_list_bdk_tx_out,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_create_impl(version, lock_time, input, output)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_from_bytes(
        transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_from_bytes_impl(transaction_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_input(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_input_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_is_coin_base(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_is_coin_base_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_is_explicitly_rbf(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_is_explicitly_rbf_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_is_lock_time_enabled(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_is_lock_time_enabled_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_lock_time(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_lock_time_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_output(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_output_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_serialize(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_serialize_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_size(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_size_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_txid(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_txid_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_version(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_version_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_vsize(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_vsize_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__bdk_transaction_weight(
        that: *mut wire_cst_bdk_transaction,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__types__bdk_transaction_weight_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_create(
        port_: i64,
        descriptor: *mut wire_cst_bdk_descriptor,
        change_descriptor: *mut wire_cst_bdk_descriptor,
        network: i32,
        database_config: *mut wire_cst_database_config,
    ) {
        wire__crate__api__wallet__bdk_wallet_create_impl(
            port_,
            descriptor,
            change_descriptor,
            network,
            database_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_get_address(
        ptr: *mut wire_cst_bdk_wallet,
        address_index: *mut wire_cst_address_index,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_get_address_impl(ptr, address_index)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_get_balance(
        that: *mut wire_cst_bdk_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_get_balance_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_get_descriptor_for_keychain(
        ptr: *mut wire_cst_bdk_wallet,
        keychain: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_get_descriptor_for_keychain_impl(ptr, keychain)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_get_internal_address(
        ptr: *mut wire_cst_bdk_wallet,
        address_index: *mut wire_cst_address_index,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_get_internal_address_impl(ptr, address_index)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_get_psbt_input(
        that: *mut wire_cst_bdk_wallet,
        utxo: *mut wire_cst_local_utxo,
        only_witness_utxo: bool,
        sighash_type: *mut wire_cst_psbt_sig_hash_type,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_get_psbt_input_impl(
            that,
            utxo,
            only_witness_utxo,
            sighash_type,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_is_mine(
        ptr: *mut wire_cst_bdk_wallet,
        script: *mut wire_cst_bdk_script_buf,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_is_mine_impl(ptr, script)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_list_transactions(
        that: *mut wire_cst_bdk_wallet,
        include_raw: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_list_transactions_impl(that, include_raw)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_list_unspent(
        that: *mut wire_cst_bdk_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_list_unspent_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_network(
        that: *mut wire_cst_bdk_wallet,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_network_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_policies(
        ptr: *mut wire_cst_bdk_wallet,
        keychain: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_policies_impl(ptr, keychain)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_sign(
        ptr: *mut wire_cst_bdk_wallet,
        psbt: *mut wire_cst_bdk_psbt,
        sign_options: *mut wire_cst_sign_options,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__wallet__bdk_wallet_sign_impl(ptr, psbt, sign_options)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__bdk_wallet_sync(
        port_: i64,
        ptr: *mut wire_cst_bdk_wallet,
        blockchain: *mut wire_cst_bdk_blockchain,
    ) {
        wire__crate__api__wallet__bdk_wallet_sync_impl(port_, ptr, blockchain)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__finish_bump_fee_tx_builder(
        port_: i64,
        txid: *mut wire_cst_list_prim_u_8_strict,
        fee_rate: f32,
        allow_shrinking: *mut wire_cst_bdk_address,
        wallet: *mut wire_cst_bdk_wallet,
        enable_rbf: bool,
        n_sequence: *mut u32,
    ) {
        wire__crate__api__wallet__finish_bump_fee_tx_builder_impl(
            port_,
            txid,
            fee_rate,
            allow_shrinking,
            wallet,
            enable_rbf,
            n_sequence,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__network_default(port_: i64) {
        wire__crate__api__types__network_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__types__sign_options_default(port_: i64) {
        wire__crate__api__types__sign_options_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_wire__crate__api__wallet__tx_builder_finish(
        port_: i64,
        wallet: *mut wire_cst_bdk_wallet,
        recipients: *mut wire_cst_list_script_amount,
        utxos: *mut wire_cst_list_out_point,
        foreign_utxo: *mut wire_cst_record_out_point_input_usize,
        un_spendable: *mut wire_cst_list_out_point,
        change_policy: i32,
        manually_selected_only: bool,
        fee_rate: *mut f32,
        fee_absolute: *mut u64,
        drain_wallet: bool,
        drain_to: *mut wire_cst_bdk_script_buf,
        rbf: *mut wire_cst_rbf_value,
        internal_policy_path: *mut wire_cst_list_record_string_list_prim_u_32_strict,
        external_policy_path: *mut wire_cst_list_record_string_list_prim_u_32_strict,
        data: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__wallet__tx_builder_finish_impl(
            port_,
            wallet,
            recipients,
            utxos,
            foreign_utxo,
            un_spendable,
            change_policy,
            manually_selected_only,
            fee_rate,
            fee_absolute,
            drain_wallet,
            drain_to,
            rbf,
            internal_policy_path,
            external_policy_path,
            data,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkbitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::bitcoin::Address>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::bitcoin::Address>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkbitcoinbip32DerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::bitcoin::bip32::DerivationPath>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinbip32DerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::bitcoin::bip32::DerivationPath>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkblockchainAnyBlockchain(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::blockchain::AnyBlockchain>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkblockchainAnyBlockchain(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::blockchain::AnyBlockchain>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkdescriptorExtendedDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::descriptor::ExtendedDescriptor>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkdescriptorExtendedDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::descriptor::ExtendedDescriptor>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkdescriptorPolicy(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::descriptor::Policy>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkdescriptorPolicy(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::descriptor::Policy>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkkeysDescriptorPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::DescriptorPublicKey>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkkeysDescriptorPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::DescriptorPublicKey>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkkeysDescriptorSecretKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::DescriptorSecretKey>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkkeysDescriptorSecretKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::DescriptorSecretKey>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkkeysKeyMap(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::KeyMap>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkkeysKeyMap(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::KeyMap>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_bdkkeysbip39Mnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::bip39::Mnemonic>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_bdkkeysbip39Mnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<bdk::keys::bip39::Mnemonic>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk :: Wallet < bdk :: database :: AnyDatabase > >>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk :: Wallet < bdk :: database :: AnyDatabase > >>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk :: bitcoin :: psbt :: PartiallySignedTransaction >>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<std :: sync :: Mutex < bdk :: bitcoin :: psbt :: PartiallySignedTransaction >>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_address_error(
    ) -> *mut wire_cst_address_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_error::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_address_index(
    ) -> *mut wire_cst_address_index {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_index::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_address(
    ) -> *mut wire_cst_bdk_address {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_address::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_blockchain(
    ) -> *mut wire_cst_bdk_blockchain {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_blockchain::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_derivation_path(
    ) -> *mut wire_cst_bdk_derivation_path {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_derivation_path::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_descriptor(
    ) -> *mut wire_cst_bdk_descriptor {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_descriptor::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_descriptor_public_key(
    ) -> *mut wire_cst_bdk_descriptor_public_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_descriptor_public_key::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_descriptor_secret_key(
    ) -> *mut wire_cst_bdk_descriptor_secret_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_descriptor_secret_key::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_mnemonic(
    ) -> *mut wire_cst_bdk_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_mnemonic::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_policy() -> *mut wire_cst_bdk_policy
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_policy::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_psbt() -> *mut wire_cst_bdk_psbt {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_bdk_psbt::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_script_buf(
    ) -> *mut wire_cst_bdk_script_buf {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_script_buf::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_transaction(
    ) -> *mut wire_cst_bdk_transaction {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_transaction::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bdk_wallet() -> *mut wire_cst_bdk_wallet
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bdk_wallet::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_block_time() -> *mut wire_cst_block_time
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_block_time::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_blockchain_config(
    ) -> *mut wire_cst_blockchain_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_blockchain_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_condition() -> *mut wire_cst_condition
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_condition::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_consensus_error(
    ) -> *mut wire_cst_consensus_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_consensus_error::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_database_config(
    ) -> *mut wire_cst_database_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_database_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_descriptor_error(
    ) -> *mut wire_cst_descriptor_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_descriptor_error::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_electrum_config(
    ) -> *mut wire_cst_electrum_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_electrum_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_esplora_config(
    ) -> *mut wire_cst_esplora_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_esplora_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_f_32(value: f32) -> *mut f32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_fee_rate() -> *mut wire_cst_fee_rate {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_fee_rate::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_hex_error() -> *mut wire_cst_hex_error
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_hex_error::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_local_utxo() -> *mut wire_cst_local_utxo
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_local_utxo::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_lock_time() -> *mut wire_cst_lock_time
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_lock_time::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_out_point() -> *mut wire_cst_out_point
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_out_point::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_pk_or_f() -> *mut wire_cst_pk_or_f {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_pk_or_f::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_psbt_sig_hash_type(
    ) -> *mut wire_cst_psbt_sig_hash_type {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_psbt_sig_hash_type::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_rbf_value() -> *mut wire_cst_rbf_value
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_rbf_value::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_record_out_point_input_usize(
    ) -> *mut wire_cst_record_out_point_input_usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_record_out_point_input_usize::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_rpc_config() -> *mut wire_cst_rpc_config
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_rpc_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_rpc_sync_params(
    ) -> *mut wire_cst_rpc_sync_params {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_rpc_sync_params::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_sign_options(
    ) -> *mut wire_cst_sign_options {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sign_options::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_sled_db_configuration(
    ) -> *mut wire_cst_sled_db_configuration {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sled_db_configuration::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_sqlite_db_configuration(
    ) -> *mut wire_cst_sqlite_db_configuration {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sqlite_db_configuration::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_u_8(value: u8) -> *mut u8 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_bdk_policy(
        len: i32,
    ) -> *mut wire_cst_list_bdk_policy {
        let wrap = wire_cst_list_bdk_policy {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_bdk_policy>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_bdk_transaction_details(
        len: i32,
    ) -> *mut wire_cst_list_bdk_transaction_details {
        let wrap = wire_cst_list_bdk_transaction_details {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_bdk_transaction_details>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_bdk_tx_in(
        len: i32,
    ) -> *mut wire_cst_list_bdk_tx_in {
        let wrap = wire_cst_list_bdk_tx_in {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_bdk_tx_in>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_bdk_tx_out(
        len: i32,
    ) -> *mut wire_cst_list_bdk_tx_out {
        let wrap = wire_cst_list_bdk_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_bdk_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_condition(
        len: i32,
    ) -> *mut wire_cst_list_condition {
        let wrap = wire_cst_list_condition {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_condition>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_local_utxo(
        len: i32,
    ) -> *mut wire_cst_list_local_utxo {
        let wrap = wire_cst_list_local_utxo {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_local_utxo>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_out_point(
        len: i32,
    ) -> *mut wire_cst_list_out_point {
        let wrap = wire_cst_list_out_point {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_out_point>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_pk_or_f(
        len: i32,
    ) -> *mut wire_cst_list_pk_or_f {
        let wrap = wire_cst_list_pk_or_f {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_pk_or_f>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_32_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_32_strict {
        let ans = wire_cst_list_prim_u_32_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_record_list_prim_u_32_strict_list_condition(
        len: i32,
    ) -> *mut wire_cst_list_record_list_prim_u_32_strict_list_condition {
        let wrap = wire_cst_list_record_list_prim_u_32_strict_list_condition {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_list_prim_u_32_strict_list_condition>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_record_string_list_prim_u_32_strict(
        len: i32,
    ) -> *mut wire_cst_list_record_string_list_prim_u_32_strict {
        let wrap = wire_cst_list_record_string_list_prim_u_32_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_list_prim_u_32_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_record_u_32_list_condition(
        len: i32,
    ) -> *mut wire_cst_list_record_u_32_list_condition {
        let wrap = wire_cst_list_record_u_32_list_condition {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_u_32_list_condition>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_bdk_flutter_cst_new_list_script_amount(
        len: i32,
    ) -> *mut wire_cst_list_script_amount {
        let wrap = wire_cst_list_script_amount {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_script_amount>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_error {
        tag: i32,
        kind: AddressErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union AddressErrorKind {
        Base58: wire_cst_AddressError_Base58,
        Bech32: wire_cst_AddressError_Bech32,
        InvalidBech32Variant: wire_cst_AddressError_InvalidBech32Variant,
        InvalidWitnessVersion: wire_cst_AddressError_InvalidWitnessVersion,
        UnparsableWitnessVersion: wire_cst_AddressError_UnparsableWitnessVersion,
        InvalidWitnessProgramLength: wire_cst_AddressError_InvalidWitnessProgramLength,
        InvalidSegwitV0ProgramLength: wire_cst_AddressError_InvalidSegwitV0ProgramLength,
        UnknownAddressType: wire_cst_AddressError_UnknownAddressType,
        NetworkValidation: wire_cst_AddressError_NetworkValidation,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_Base58 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_Bech32 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_InvalidBech32Variant {
        expected: i32,
        found: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_InvalidWitnessVersion {
        field0: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_UnparsableWitnessVersion {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_InvalidWitnessProgramLength {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_InvalidSegwitV0ProgramLength {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_UnknownAddressType {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressError_NetworkValidation {
        network_required: i32,
        network_found: i32,
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_index {
        tag: i32,
        kind: AddressIndexKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union AddressIndexKind {
        Peek: wire_cst_AddressIndex_Peek,
        Reset: wire_cst_AddressIndex_Reset,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressIndex_Peek {
        index: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AddressIndex_Reset {
        index: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_auth {
        tag: i32,
        kind: AuthKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union AuthKind {
        UserPass: wire_cst_Auth_UserPass,
        Cookie: wire_cst_Auth_Cookie,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Auth_UserPass {
        username: *mut wire_cst_list_prim_u_8_strict,
        password: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Auth_Cookie {
        file: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance {
        immature: u64,
        trusted_pending: u64,
        untrusted_pending: u64,
        confirmed: u64,
        spendable: u64,
        total: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_address {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_blockchain {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_derivation_path {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_descriptor {
        extended_descriptor: usize,
        key_map: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_descriptor_public_key {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_descriptor_secret_key {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_error {
        tag: i32,
        kind: BdkErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union BdkErrorKind {
        Hex: wire_cst_BdkError_Hex,
        Consensus: wire_cst_BdkError_Consensus,
        VerifyTransaction: wire_cst_BdkError_VerifyTransaction,
        Address: wire_cst_BdkError_Address,
        Descriptor: wire_cst_BdkError_Descriptor,
        InvalidU32Bytes: wire_cst_BdkError_InvalidU32Bytes,
        Generic: wire_cst_BdkError_Generic,
        OutputBelowDustLimit: wire_cst_BdkError_OutputBelowDustLimit,
        InsufficientFunds: wire_cst_BdkError_InsufficientFunds,
        FeeRateTooLow: wire_cst_BdkError_FeeRateTooLow,
        FeeTooLow: wire_cst_BdkError_FeeTooLow,
        MissingKeyOrigin: wire_cst_BdkError_MissingKeyOrigin,
        Key: wire_cst_BdkError_Key,
        SpendingPolicyRequired: wire_cst_BdkError_SpendingPolicyRequired,
        InvalidPolicyPathError: wire_cst_BdkError_InvalidPolicyPathError,
        Signer: wire_cst_BdkError_Signer,
        InvalidNetwork: wire_cst_BdkError_InvalidNetwork,
        InvalidOutpoint: wire_cst_BdkError_InvalidOutpoint,
        Encode: wire_cst_BdkError_Encode,
        Miniscript: wire_cst_BdkError_Miniscript,
        MiniscriptPsbt: wire_cst_BdkError_MiniscriptPsbt,
        Bip32: wire_cst_BdkError_Bip32,
        Bip39: wire_cst_BdkError_Bip39,
        Secp256k1: wire_cst_BdkError_Secp256k1,
        Json: wire_cst_BdkError_Json,
        Psbt: wire_cst_BdkError_Psbt,
        PsbtParse: wire_cst_BdkError_PsbtParse,
        MissingCachedScripts: wire_cst_BdkError_MissingCachedScripts,
        Electrum: wire_cst_BdkError_Electrum,
        Esplora: wire_cst_BdkError_Esplora,
        Sled: wire_cst_BdkError_Sled,
        Rpc: wire_cst_BdkError_Rpc,
        Rusqlite: wire_cst_BdkError_Rusqlite,
        InvalidInput: wire_cst_BdkError_InvalidInput,
        InvalidLockTime: wire_cst_BdkError_InvalidLockTime,
        InvalidTransaction: wire_cst_BdkError_InvalidTransaction,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Hex {
        field0: *mut wire_cst_hex_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Consensus {
        field0: *mut wire_cst_consensus_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_VerifyTransaction {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Address {
        field0: *mut wire_cst_address_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Descriptor {
        field0: *mut wire_cst_descriptor_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidU32Bytes {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Generic {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_OutputBelowDustLimit {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InsufficientFunds {
        needed: u64,
        available: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_FeeRateTooLow {
        needed: f32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_FeeTooLow {
        needed: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_MissingKeyOrigin {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Key {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_SpendingPolicyRequired {
        field0: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidPolicyPathError {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Signer {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidNetwork {
        requested: i32,
        found: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidOutpoint {
        field0: *mut wire_cst_out_point,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Encode {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Miniscript {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_MiniscriptPsbt {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Bip32 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Bip39 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Secp256k1 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Json {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Psbt {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_PsbtParse {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_MissingCachedScripts {
        field0: usize,
        field1: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Electrum {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Esplora {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Sled {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Rpc {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_Rusqlite {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidInput {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidLockTime {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BdkError_InvalidTransaction {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_mnemonic {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_policy {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_psbt {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_script_buf {
        bytes: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_transaction {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_transaction_details {
        transaction: *mut wire_cst_bdk_transaction,
        txid: *mut wire_cst_list_prim_u_8_strict,
        received: u64,
        sent: u64,
        fee: *mut u64,
        confirmation_time: *mut wire_cst_block_time,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_tx_in {
        previous_output: wire_cst_out_point,
        script_sig: *mut wire_cst_bdk_script_buf,
        sequence: u32,
        witness: *mut wire_cst_list_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_tx_out {
        value: u64,
        script_pubkey: wire_cst_bdk_script_buf,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bdk_wallet {
        ptr: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_block_time {
        height: u32,
        timestamp: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_blockchain_config {
        tag: i32,
        kind: BlockchainConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union BlockchainConfigKind {
        Electrum: wire_cst_BlockchainConfig_Electrum,
        Esplora: wire_cst_BlockchainConfig_Esplora,
        Rpc: wire_cst_BlockchainConfig_Rpc,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BlockchainConfig_Electrum {
        config: *mut wire_cst_electrum_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BlockchainConfig_Esplora {
        config: *mut wire_cst_esplora_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_BlockchainConfig_Rpc {
        config: *mut wire_cst_rpc_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_condition {
        csv: *mut u32,
        timelock: *mut wire_cst_lock_time,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_consensus_error {
        tag: i32,
        kind: ConsensusErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ConsensusErrorKind {
        Io: wire_cst_ConsensusError_Io,
        OversizedVectorAllocation: wire_cst_ConsensusError_OversizedVectorAllocation,
        InvalidChecksum: wire_cst_ConsensusError_InvalidChecksum,
        ParseFailed: wire_cst_ConsensusError_ParseFailed,
        UnsupportedSegwitFlag: wire_cst_ConsensusError_UnsupportedSegwitFlag,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ConsensusError_Io {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ConsensusError_OversizedVectorAllocation {
        requested: usize,
        max: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ConsensusError_InvalidChecksum {
        expected: *mut wire_cst_list_prim_u_8_strict,
        actual: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ConsensusError_ParseFailed {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ConsensusError_UnsupportedSegwitFlag {
        field0: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_database_config {
        tag: i32,
        kind: DatabaseConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union DatabaseConfigKind {
        Sqlite: wire_cst_DatabaseConfig_Sqlite,
        Sled: wire_cst_DatabaseConfig_Sled,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DatabaseConfig_Sqlite {
        config: *mut wire_cst_sqlite_db_configuration,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DatabaseConfig_Sled {
        config: *mut wire_cst_sled_db_configuration,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_descriptor_error {
        tag: i32,
        kind: DescriptorErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union DescriptorErrorKind {
        Key: wire_cst_DescriptorError_Key,
        Policy: wire_cst_DescriptorError_Policy,
        InvalidDescriptorCharacter: wire_cst_DescriptorError_InvalidDescriptorCharacter,
        Bip32: wire_cst_DescriptorError_Bip32,
        Base58: wire_cst_DescriptorError_Base58,
        Pk: wire_cst_DescriptorError_Pk,
        Miniscript: wire_cst_DescriptorError_Miniscript,
        Hex: wire_cst_DescriptorError_Hex,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Key {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Policy {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_InvalidDescriptorCharacter {
        field0: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Bip32 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Base58 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Pk {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Miniscript {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DescriptorError_Hex {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_electrum_config {
        url: *mut wire_cst_list_prim_u_8_strict,
        socks5: *mut wire_cst_list_prim_u_8_strict,
        retry: u8,
        timeout: *mut u8,
        stop_gap: u64,
        validate_domain: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_esplora_config {
        base_url: *mut wire_cst_list_prim_u_8_strict,
        proxy: *mut wire_cst_list_prim_u_8_strict,
        concurrency: *mut u8,
        stop_gap: u64,
        timeout: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_fee_rate {
        sat_per_vb: f32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_hex_error {
        tag: i32,
        kind: HexErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union HexErrorKind {
        InvalidChar: wire_cst_HexError_InvalidChar,
        OddLengthString: wire_cst_HexError_OddLengthString,
        InvalidLength: wire_cst_HexError_InvalidLength,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_HexError_InvalidChar {
        field0: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_HexError_OddLengthString {
        field0: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_HexError_InvalidLength {
        field0: usize,
        field1: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_input {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_bdk_policy {
        ptr: *mut wire_cst_bdk_policy,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_bdk_transaction_details {
        ptr: *mut wire_cst_bdk_transaction_details,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_bdk_tx_in {
        ptr: *mut wire_cst_bdk_tx_in,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_bdk_tx_out {
        ptr: *mut wire_cst_bdk_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_condition {
        ptr: *mut wire_cst_condition,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_local_utxo {
        ptr: *mut wire_cst_local_utxo,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_out_point {
        ptr: *mut wire_cst_out_point,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_pk_or_f {
        ptr: *mut wire_cst_pk_or_f,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_32_strict {
        ptr: *mut u32,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_list_prim_u_32_strict_list_condition {
        ptr: *mut wire_cst_record_list_prim_u_32_strict_list_condition,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_list_prim_u_32_strict {
        ptr: *mut wire_cst_record_string_list_prim_u_32_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_u_32_list_condition {
        ptr: *mut wire_cst_record_u_32_list_condition,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_script_amount {
        ptr: *mut wire_cst_script_amount,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_local_utxo {
        outpoint: wire_cst_out_point,
        txout: wire_cst_bdk_tx_out,
        keychain: i32,
        is_spent: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lock_time {
        tag: i32,
        kind: LockTimeKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union LockTimeKind {
        Blocks: wire_cst_LockTime_Blocks,
        Seconds: wire_cst_LockTime_Seconds,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LockTime_Blocks {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LockTime_Seconds {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: *mut wire_cst_list_prim_u_8_strict,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payload {
        tag: i32,
        kind: PayloadKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PayloadKind {
        PubkeyHash: wire_cst_Payload_PubkeyHash,
        ScriptHash: wire_cst_Payload_ScriptHash,
        WitnessProgram: wire_cst_Payload_WitnessProgram,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Payload_PubkeyHash {
        pubkey_hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Payload_ScriptHash {
        script_hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Payload_WitnessProgram {
        version: i32,
        program: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pk_or_f {
        tag: i32,
        kind: PkOrFKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PkOrFKind {
        Pubkey: wire_cst_PkOrF_Pubkey,
        XOnlyPubkey: wire_cst_PkOrF_XOnlyPubkey,
        Fingerprint: wire_cst_PkOrF_Fingerprint,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PkOrF_Pubkey {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PkOrF_XOnlyPubkey {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PkOrF_Fingerprint {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt_sig_hash_type {
        inner: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_rbf_value {
        tag: i32,
        kind: RbfValueKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union RbfValueKind {
        Value: wire_cst_RbfValue_Value,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_RbfValue_Value {
        field0: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_bdk_address_u_32 {
        field0: wire_cst_bdk_address,
        field1: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_bdk_psbt_bdk_transaction_details {
        field0: wire_cst_bdk_psbt,
        field1: wire_cst_bdk_transaction_details,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_list_prim_u_32_strict_list_condition {
        field0: *mut wire_cst_list_prim_u_32_strict,
        field1: *mut wire_cst_list_condition,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_out_point_input_usize {
        field0: wire_cst_out_point,
        field1: wire_cst_input,
        field2: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_list_prim_u_32_strict {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_32_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_u_32_list_condition {
        field0: u32,
        field1: *mut wire_cst_list_condition,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_rpc_config {
        url: *mut wire_cst_list_prim_u_8_strict,
        auth: wire_cst_auth,
        network: i32,
        wallet_name: *mut wire_cst_list_prim_u_8_strict,
        sync_params: *mut wire_cst_rpc_sync_params,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_rpc_sync_params {
        start_script_count: u64,
        start_time: u64,
        force_start_time: bool,
        poll_rate_sec: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_satisfaction {
        tag: i32,
        kind: SatisfactionKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union SatisfactionKind {
        Partial: wire_cst_Satisfaction_Partial,
        PartialComplete: wire_cst_Satisfaction_PartialComplete,
        Complete: wire_cst_Satisfaction_Complete,
        None: wire_cst_Satisfaction_None,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Satisfaction_Partial {
        n: u64,
        m: u64,
        items: *mut wire_cst_list_prim_u_64_strict,
        sorted: *mut bool,
        conditions: *mut wire_cst_list_record_u_32_list_condition,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Satisfaction_PartialComplete {
        n: u64,
        m: u64,
        items: *mut wire_cst_list_prim_u_64_strict,
        sorted: *mut bool,
        conditions: *mut wire_cst_list_record_list_prim_u_32_strict_list_condition,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Satisfaction_Complete {
        condition: *mut wire_cst_condition,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Satisfaction_None {
        msg: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_satisfiable_item {
        tag: i32,
        kind: SatisfiableItemKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union SatisfiableItemKind {
        EcdsaSignature: wire_cst_SatisfiableItem_EcdsaSignature,
        SchnorrSignature: wire_cst_SatisfiableItem_SchnorrSignature,
        Sha256Preimage: wire_cst_SatisfiableItem_Sha256Preimage,
        Hash256Preimage: wire_cst_SatisfiableItem_Hash256Preimage,
        Ripemd160Preimage: wire_cst_SatisfiableItem_Ripemd160Preimage,
        Hash160Preimage: wire_cst_SatisfiableItem_Hash160Preimage,
        AbsoluteTimelock: wire_cst_SatisfiableItem_AbsoluteTimelock,
        RelativeTimelock: wire_cst_SatisfiableItem_RelativeTimelock,
        Multisig: wire_cst_SatisfiableItem_Multisig,
        Thresh: wire_cst_SatisfiableItem_Thresh,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_EcdsaSignature {
        key: *mut wire_cst_pk_or_f,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_SchnorrSignature {
        key: *mut wire_cst_pk_or_f,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Sha256Preimage {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Hash256Preimage {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Ripemd160Preimage {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Hash160Preimage {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_AbsoluteTimelock {
        value: *mut wire_cst_lock_time,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_RelativeTimelock {
        value: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Multisig {
        keys: *mut wire_cst_list_pk_or_f,
        threshold: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SatisfiableItem_Thresh {
        items: *mut wire_cst_list_bdk_policy,
        threshold: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_script_amount {
        script: wire_cst_bdk_script_buf,
        amount: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sign_options {
        trust_witness_utxo: bool,
        assume_height: *mut u32,
        allow_all_sighashes: bool,
        remove_partial_sigs: bool,
        try_finalize: bool,
        sign_with_tap_internal_key: bool,
        allow_grinding: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sled_db_configuration {
        path: *mut wire_cst_list_prim_u_8_strict,
        tree_name: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sqlite_db_configuration {
        path: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
