// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// Section: imports

use super::*;
use crate::api::blockchain::*;
use crate::api::descriptor::*;
use crate::api::key::*;
use crate::api::psbt::*;
use crate::api::types::*;
use crate::api::wallet::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::for_generated::wasm_bindgen;
use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate_web!();

// Section: dart2rust

impl CstDecode<String> for String {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> String {
        self
    }
}
impl CstDecode<crate::api::error::AddressError>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::AddressError {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::error::AddressError::Base58(self_.get(1).cst_decode()),
            1 => crate::api::error::AddressError::Bech32(self_.get(1).cst_decode()),
            2 => crate::api::error::AddressError::EmptyBech32Payload,
            3 => crate::api::error::AddressError::InvalidBech32Variant {
                expected: self_.get(1).cst_decode(),
                found: self_.get(2).cst_decode(),
            },
            4 => crate::api::error::AddressError::InvalidWitnessVersion(self_.get(1).cst_decode()),
            5 => {
                crate::api::error::AddressError::UnparsableWitnessVersion(self_.get(1).cst_decode())
            }
            6 => crate::api::error::AddressError::MalformedWitnessVersion,
            7 => crate::api::error::AddressError::InvalidWitnessProgramLength(
                self_.get(1).cst_decode(),
            ),
            8 => crate::api::error::AddressError::InvalidSegwitV0ProgramLength(
                self_.get(1).cst_decode(),
            ),
            9 => crate::api::error::AddressError::UncompressedPubkey,
            10 => crate::api::error::AddressError::ExcessiveScriptSize,
            11 => crate::api::error::AddressError::UnrecognizedScript,
            12 => crate::api::error::AddressError::UnknownAddressType(self_.get(1).cst_decode()),
            13 => crate::api::error::AddressError::NetworkValidation {
                network_required: self_.get(1).cst_decode(),
                network_found: self_.get(2).cst_decode(),
                address: self_.get(3).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::AddressIndex>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::AddressIndex {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::types::AddressIndex::Increase,
            1 => crate::api::types::AddressIndex::LastUnused,
            2 => crate::api::types::AddressIndex::Peek {
                index: self_.get(1).cst_decode(),
            },
            3 => crate::api::types::AddressIndex::Reset {
                index: self_.get(1).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::blockchain::Auth>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::Auth {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::blockchain::Auth::None,
            1 => crate::api::blockchain::Auth::UserPass {
                username: self_.get(1).cst_decode(),
                password: self_.get(2).cst_decode(),
            },
            2 => crate::api::blockchain::Auth::Cookie {
                file: self_.get(1).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::Balance>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Balance {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            6,
            "Expected 6 elements, got {}",
            self_.length()
        );
        crate::api::types::Balance {
            immature: self_.get(0).cst_decode(),
            trusted_pending: self_.get(1).cst_decode(),
            untrusted_pending: self_.get(2).cst_decode(),
            confirmed: self_.get(3).cst_decode(),
            spendable: self_.get(4).cst_decode(),
            total: self_.get(5).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::BdkAddress>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::BdkAddress {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::BdkAddress {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::blockchain::BdkBlockchain>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::BdkBlockchain {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::blockchain::BdkBlockchain {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::key::BdkDerivationPath>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::BdkDerivationPath {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::key::BdkDerivationPath {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::descriptor::BdkDescriptor>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::descriptor::BdkDescriptor {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::descriptor::BdkDescriptor {
            extended_descriptor: self_.get(0).cst_decode(),
            key_map: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::key::BdkDescriptorPublicKey>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::BdkDescriptorPublicKey {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::key::BdkDescriptorPublicKey {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::key::BdkDescriptorSecretKey>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::BdkDescriptorSecretKey {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::key::BdkDescriptorSecretKey {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::error::BdkError>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::BdkError {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::error::BdkError::Hex(self_.get(1).cst_decode()),
            1 => crate::api::error::BdkError::Consensus(self_.get(1).cst_decode()),
            2 => crate::api::error::BdkError::Address(self_.get(1).cst_decode()),
            3 => crate::api::error::BdkError::Descriptor(self_.get(1).cst_decode()),
            4 => crate::api::error::BdkError::InvalidU32Bytes(self_.get(1).cst_decode()),
            5 => crate::api::error::BdkError::Generic(self_.get(1).cst_decode()),
            6 => crate::api::error::BdkError::ScriptDoesntHaveAddressForm,
            7 => crate::api::error::BdkError::NoRecipients,
            8 => crate::api::error::BdkError::NoUtxosSelected,
            9 => crate::api::error::BdkError::OutputBelowDustLimit(self_.get(1).cst_decode()),
            10 => crate::api::error::BdkError::InsufficientFunds {
                needed: self_.get(1).cst_decode(),
                available: self_.get(2).cst_decode(),
            },
            11 => crate::api::error::BdkError::BnBTotalTriesExceeded,
            12 => crate::api::error::BdkError::BnBNoExactMatch,
            13 => crate::api::error::BdkError::UnknownUtxo,
            14 => crate::api::error::BdkError::TransactionNotFound,
            15 => crate::api::error::BdkError::TransactionConfirmed,
            16 => crate::api::error::BdkError::IrreplaceableTransaction,
            17 => crate::api::error::BdkError::FeeRateTooLow {
                needed: self_.get(1).cst_decode(),
            },
            18 => crate::api::error::BdkError::FeeTooLow {
                needed: self_.get(1).cst_decode(),
            },
            19 => crate::api::error::BdkError::FeeRateUnavailable,
            20 => crate::api::error::BdkError::MissingKeyOrigin(self_.get(1).cst_decode()),
            21 => crate::api::error::BdkError::Key(self_.get(1).cst_decode()),
            22 => crate::api::error::BdkError::ChecksumMismatch,
            23 => crate::api::error::BdkError::SpendingPolicyRequired(self_.get(1).cst_decode()),
            24 => crate::api::error::BdkError::InvalidPolicyPathError(self_.get(1).cst_decode()),
            25 => crate::api::error::BdkError::Signer(self_.get(1).cst_decode()),
            26 => crate::api::error::BdkError::InvalidNetwork {
                requested: self_.get(1).cst_decode(),
                found: self_.get(2).cst_decode(),
            },
            27 => crate::api::error::BdkError::InvalidOutpoint(self_.get(1).cst_decode()),
            28 => crate::api::error::BdkError::Encode(self_.get(1).cst_decode()),
            29 => crate::api::error::BdkError::Miniscript(self_.get(1).cst_decode()),
            30 => crate::api::error::BdkError::MiniscriptPsbt(self_.get(1).cst_decode()),
            31 => crate::api::error::BdkError::Bip32(self_.get(1).cst_decode()),
            32 => crate::api::error::BdkError::Bip39(self_.get(1).cst_decode()),
            33 => crate::api::error::BdkError::Secp256k1(self_.get(1).cst_decode()),
            34 => crate::api::error::BdkError::Json(self_.get(1).cst_decode()),
            35 => crate::api::error::BdkError::Psbt(self_.get(1).cst_decode()),
            36 => crate::api::error::BdkError::PsbtParse(self_.get(1).cst_decode()),
            37 => crate::api::error::BdkError::MissingCachedScripts(
                self_.get(1).cst_decode(),
                self_.get(2).cst_decode(),
            ),
            38 => crate::api::error::BdkError::Electrum(self_.get(1).cst_decode()),
            39 => crate::api::error::BdkError::Esplora(self_.get(1).cst_decode()),
            40 => crate::api::error::BdkError::Sled(self_.get(1).cst_decode()),
            41 => crate::api::error::BdkError::Rpc(self_.get(1).cst_decode()),
            42 => crate::api::error::BdkError::Rusqlite(self_.get(1).cst_decode()),
            43 => crate::api::error::BdkError::InvalidInput(self_.get(1).cst_decode()),
            44 => crate::api::error::BdkError::InvalidLockTime(self_.get(1).cst_decode()),
            45 => crate::api::error::BdkError::InvalidTransaction(self_.get(1).cst_decode()),
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::key::BdkMnemonic>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::key::BdkMnemonic {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::key::BdkMnemonic {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::psbt::BdkPsbt>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::psbt::BdkPsbt {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::psbt::BdkPsbt {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::BdkScriptBuf>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::BdkScriptBuf {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::BdkScriptBuf {
            bytes: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::BdkTransaction>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::BdkTransaction {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::BdkTransaction {
            inner: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::wallet::BdkWallet>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::wallet::BdkWallet {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::wallet::BdkWallet {
            ptr: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::BlockTime>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::BlockTime {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::types::BlockTime {
            height: self_.get(0).cst_decode(),
            timestamp: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::blockchain::BlockchainConfig>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::BlockchainConfig {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::blockchain::BlockchainConfig::Electrum {
                config: self_.get(1).cst_decode(),
            },
            1 => crate::api::blockchain::BlockchainConfig::Esplora {
                config: self_.get(1).cst_decode(),
            },
            2 => crate::api::blockchain::BlockchainConfig::Rpc {
                config: self_.get(1).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::ConsensusError>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::ConsensusError {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::error::ConsensusError::Io(self_.get(1).cst_decode()),
            1 => crate::api::error::ConsensusError::OversizedVectorAllocation {
                requested: self_.get(1).cst_decode(),
                max: self_.get(2).cst_decode(),
            },
            2 => crate::api::error::ConsensusError::InvalidChecksum {
                expected: self_.get(1).cst_decode(),
                actual: self_.get(2).cst_decode(),
            },
            3 => crate::api::error::ConsensusError::NonMinimalVarInt,
            4 => crate::api::error::ConsensusError::ParseFailed(self_.get(1).cst_decode()),
            5 => {
                crate::api::error::ConsensusError::UnsupportedSegwitFlag(self_.get(1).cst_decode())
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::DatabaseConfig>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::DatabaseConfig {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::types::DatabaseConfig::Memory,
            1 => crate::api::types::DatabaseConfig::Sqlite {
                config: self_.get(1).cst_decode(),
            },
            2 => crate::api::types::DatabaseConfig::Sled {
                config: self_.get(1).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::error::DescriptorError>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::DescriptorError {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::error::DescriptorError::InvalidHdKeyPath,
            1 => crate::api::error::DescriptorError::InvalidDescriptorChecksum,
            2 => crate::api::error::DescriptorError::HardenedDerivationXpub,
            3 => crate::api::error::DescriptorError::MultiPath,
            4 => crate::api::error::DescriptorError::Key(self_.get(1).cst_decode()),
            5 => crate::api::error::DescriptorError::Policy(self_.get(1).cst_decode()),
            6 => crate::api::error::DescriptorError::InvalidDescriptorCharacter(
                self_.get(1).cst_decode(),
            ),
            7 => crate::api::error::DescriptorError::Bip32(self_.get(1).cst_decode()),
            8 => crate::api::error::DescriptorError::Base58(self_.get(1).cst_decode()),
            9 => crate::api::error::DescriptorError::Pk(self_.get(1).cst_decode()),
            10 => crate::api::error::DescriptorError::Miniscript(self_.get(1).cst_decode()),
            11 => crate::api::error::DescriptorError::Hex(self_.get(1).cst_decode()),
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::blockchain::ElectrumConfig>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::ElectrumConfig {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            6,
            "Expected 6 elements, got {}",
            self_.length()
        );
        crate::api::blockchain::ElectrumConfig {
            url: self_.get(0).cst_decode(),
            socks5: self_.get(1).cst_decode(),
            retry: self_.get(2).cst_decode(),
            timeout: self_.get(3).cst_decode(),
            stop_gap: self_.get(4).cst_decode(),
            validate_domain: self_.get(5).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::blockchain::EsploraConfig>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::EsploraConfig {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            5,
            "Expected 5 elements, got {}",
            self_.length()
        );
        crate::api::blockchain::EsploraConfig {
            base_url: self_.get(0).cst_decode(),
            proxy: self_.get(1).cst_decode(),
            concurrency: self_.get(2).cst_decode(),
            stop_gap: self_.get(3).cst_decode(),
            timeout: self_.get(4).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::FeeRate>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::FeeRate {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::FeeRate {
            sat_per_vb: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::error::HexError>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::HexError {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::error::HexError::InvalidChar(self_.get(1).cst_decode()),
            1 => crate::api::error::HexError::OddLengthString(self_.get(1).cst_decode()),
            2 => crate::api::error::HexError::InvalidLength(
                self_.get(1).cst_decode(),
                self_.get(2).cst_decode(),
            ),
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::Input>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Input {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::Input {
            s: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<Vec<Vec<u8>>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<Vec<u8>> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<crate::api::types::LocalUtxo>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::LocalUtxo> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<crate::api::types::OutPoint>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::OutPoint> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<u8>> for Box<[u8]> {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        self.into_vec()
    }
}
impl CstDecode<Vec<crate::api::types::ScriptAmount>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::ScriptAmount> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<crate::api::types::TransactionDetails>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::TransactionDetails> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<crate::api::types::TxIn>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::TxIn> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<Vec<crate::api::types::TxOut>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::TxOut> {
        self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap()
            .iter()
            .map(CstDecode::cst_decode)
            .collect()
    }
}
impl CstDecode<crate::api::types::LocalUtxo>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LocalUtxo {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            4,
            "Expected 4 elements, got {}",
            self_.length()
        );
        crate::api::types::LocalUtxo {
            outpoint: self_.get(0).cst_decode(),
            txout: self_.get(1).cst_decode(),
            keychain: self_.get(2).cst_decode(),
            is_spent: self_.get(3).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::LockTime>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LockTime {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::types::LockTime::Blocks(self_.get(1).cst_decode()),
            1 => crate::api::types::LockTime::Seconds(self_.get(1).cst_decode()),
            _ => unreachable!(),
        }
    }
}
impl CstDecode<Option<String>> for Option<String> {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Option<String> {
        self.map(CstDecode::cst_decode)
    }
}
impl CstDecode<crate::api::types::OutPoint>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::OutPoint {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::types::OutPoint {
            txid: self_.get(0).cst_decode(),
            vout: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::Payload>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Payload {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::types::Payload::PubkeyHash {
                pubkey_hash: self_.get(1).cst_decode(),
            },
            1 => crate::api::types::Payload::ScriptHash {
                script_hash: self_.get(1).cst_decode(),
            },
            2 => crate::api::types::Payload::WitnessProgram {
                version: self_.get(1).cst_decode(),
                program: self_.get(2).cst_decode(),
            },
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::PsbtSigHashType>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PsbtSigHashType {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::PsbtSigHashType {
            inner: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::RbfValue>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::RbfValue {
        let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
        match self_.get(0).unchecked_into_f64() as _ {
            0 => crate::api::types::RbfValue::RbfDefault,
            1 => crate::api::types::RbfValue::Value(self_.get(1).cst_decode()),
            _ => unreachable!(),
        }
    }
}
impl CstDecode<(crate::api::types::BdkAddress, u32)>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> (crate::api::types::BdkAddress, u32) {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        (self_.get(0).cst_decode(), self_.get(1).cst_decode())
    }
}
impl
    CstDecode<(
        crate::api::psbt::BdkPsbt,
        crate::api::types::TransactionDetails,
    )> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> (
        crate::api::psbt::BdkPsbt,
        crate::api::types::TransactionDetails,
    ) {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        (self_.get(0).cst_decode(), self_.get(1).cst_decode())
    }
}
impl CstDecode<(crate::api::types::OutPoint, crate::api::types::Input, usize)>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> (crate::api::types::OutPoint, crate::api::types::Input, usize) {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            3,
            "Expected 3 elements, got {}",
            self_.length()
        );
        (
            self_.get(0).cst_decode(),
            self_.get(1).cst_decode(),
            self_.get(2).cst_decode(),
        )
    }
}
impl CstDecode<crate::api::blockchain::RpcConfig>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::RpcConfig {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            5,
            "Expected 5 elements, got {}",
            self_.length()
        );
        crate::api::blockchain::RpcConfig {
            url: self_.get(0).cst_decode(),
            auth: self_.get(1).cst_decode(),
            network: self_.get(2).cst_decode(),
            wallet_name: self_.get(3).cst_decode(),
            sync_params: self_.get(4).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::blockchain::RpcSyncParams>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::blockchain::RpcSyncParams {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            4,
            "Expected 4 elements, got {}",
            self_.length()
        );
        crate::api::blockchain::RpcSyncParams {
            start_script_count: self_.get(0).cst_decode(),
            start_time: self_.get(1).cst_decode(),
            force_start_time: self_.get(2).cst_decode(),
            poll_rate_sec: self_.get(3).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::ScriptAmount>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ScriptAmount {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::types::ScriptAmount {
            script: self_.get(0).cst_decode(),
            amount: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::SignOptions>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SignOptions {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            8,
            "Expected 8 elements, got {}",
            self_.length()
        );
        crate::api::types::SignOptions {
            multi_sig: self_.get(0).cst_decode(),
            trust_witness_utxo: self_.get(1).cst_decode(),
            assume_height: self_.get(2).cst_decode(),
            allow_all_sighashes: self_.get(3).cst_decode(),
            remove_partial_sigs: self_.get(4).cst_decode(),
            try_finalize: self_.get(5).cst_decode(),
            sign_with_tap_internal_key: self_.get(6).cst_decode(),
            allow_grinding: self_.get(7).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::SledDbConfiguration>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SledDbConfiguration {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::types::SledDbConfiguration {
            path: self_.get(0).cst_decode(),
            tree_name: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::SqliteDbConfiguration>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SqliteDbConfiguration {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            1,
            "Expected 1 elements, got {}",
            self_.length()
        );
        crate::api::types::SqliteDbConfiguration {
            path: self_.get(0).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TransactionDetails>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TransactionDetails {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            6,
            "Expected 6 elements, got {}",
            self_.length()
        );
        crate::api::types::TransactionDetails {
            transaction: self_.get(0).cst_decode(),
            txid: self_.get(1).cst_decode(),
            received: self_.get(2).cst_decode(),
            sent: self_.get(3).cst_decode(),
            fee: self_.get(4).cst_decode(),
            confirmation_time: self_.get(5).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TxIn>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TxIn {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            4,
            "Expected 4 elements, got {}",
            self_.length()
        );
        crate::api::types::TxIn {
            previous_output: self_.get(0).cst_decode(),
            script_sig: self_.get(1).cst_decode(),
            sequence: self_.get(2).cst_decode(),
            witness: self_.get(3).cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TxOut>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TxOut {
        let self_ = self
            .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
            .unwrap();
        assert_eq!(
            self_.length(),
            2,
            "Expected 2 elements, got {}",
            self_.length()
        );
        crate::api::types::TxOut {
            value: self_.get(0).cst_decode(),
            script_pubkey: self_.get(1).cst_decode(),
        }
    }
}
impl CstDecode<[u8; 4]> for Box<[u8]> {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> [u8; 4] {
        let vec: Vec<u8> = self.cst_decode();
        flutter_rust_bridge::for_generated::from_vec_to_array(vec)
    }
}
impl CstDecode<RustOpaqueNom<AnyBlockchain>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<AnyBlockchain> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<ExtendedDescriptor>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<ExtendedDescriptor> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<Mutex<PartiallySignedTransaction>>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<Mutex<PartiallySignedTransaction>> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<Mutex<bdk::Wallet<AnyDatabase>>>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<Mutex<bdk::Wallet<AnyDatabase>>> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<bdk::bitcoin::Address>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bdk::bitcoin::Address> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<bitcoin::bip32::DerivationPath>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<bitcoin::bip32::DerivationPath> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<keys::DescriptorPublicKey>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<keys::DescriptorPublicKey> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<keys::DescriptorSecretKey>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<keys::DescriptorSecretKey> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<keys::KeyMap>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<keys::KeyMap> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<RustOpaqueNom<keys::bip39::Mnemonic>>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> RustOpaqueNom<keys::bip39::Mnemonic> {
        #[cfg(target_pointer_width = "64")]
        {
            compile_error!("64-bit pointers are not supported.");
        }
        unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
    }
}
impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> String {
        self.as_string().expect("non-UTF-8 string, or not a string")
    }
}
impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self.is_truthy()
    }
}
impl CstDecode<crate::api::types::ChangeSpendPolicy>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ChangeSpendPolicy {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}
impl CstDecode<f32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f32 {
        self.unchecked_into_f64() as _
    }
}
impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self.unchecked_into_f64() as _
    }
}
impl CstDecode<crate::api::types::KeychainKind>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::KeychainKind {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}
impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
            .to_vec()
            .into()
    }
}
impl CstDecode<crate::api::types::Network>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}
impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self.unchecked_into_f64() as _
    }
}
impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        ::std::convert::TryInto::try_into(
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::BigInt>()
                .unwrap(),
        )
        .unwrap()
    }
}
impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self.unchecked_into_f64() as _
    }
}
impl CstDecode<[u8; 4]> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> [u8; 4] {
        let vec: Vec<u8> = self.cst_decode();
        flutter_rust_bridge::for_generated::from_vec_to_array(vec)
    }
}
impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self.unchecked_into_f64() as _
    }
}
impl CstDecode<crate::api::types::Variant>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Variant {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}
impl CstDecode<crate::api::types::WitnessVersion>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::WitnessVersion {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}
impl CstDecode<crate::api::types::WordCount>
    for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::WordCount {
        (self.unchecked_into_f64() as i32).cst_decode()
    }
}

#[wasm_bindgen]
pub fn wire_bdk_blockchain_broadcast(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    transaction: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_blockchain_broadcast_impl(port_, that, transaction)
}

#[wasm_bindgen]
pub fn wire_bdk_blockchain_estimate_fee(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    target: u64,
) {
    wire_bdk_blockchain_estimate_fee_impl(port_, that, target)
}

#[wasm_bindgen]
pub fn wire_bdk_blockchain_get_block_hash(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    height: u32,
) {
    wire_bdk_blockchain_get_block_hash_impl(port_, that, height)
}

#[wasm_bindgen]
pub fn wire_bdk_blockchain_get_height(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_blockchain_get_height_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_blockchain_new(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    blockchain_config: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_blockchain_new_impl(port_, blockchain_config)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_as_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_as_string_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_as_string_private(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_as_string_private_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_max_satisfaction_weight(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_max_satisfaction_weight_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: String,
    network: i32,
) {
    wire_bdk_descriptor_new_impl(port_, descriptor, network)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip44(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip44_impl(port_, secret_key, keychain_kind, network)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip44_public(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    fingerprint: String,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip44_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip49(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip49_impl(port_, secret_key, keychain_kind, network)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip49_public(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    fingerprint: String,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip49_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip84(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip84_impl(port_, secret_key, keychain_kind, network)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip84_public(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    fingerprint: String,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip84_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip86(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip86_impl(port_, secret_key, keychain_kind, network)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_new_bip86_public(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    fingerprint: String,
    keychain_kind: i32,
    network: i32,
) {
    wire_bdk_descriptor_new_bip86_public_impl(
        port_,
        public_key,
        fingerprint,
        keychain_kind,
        network,
    )
}

#[wasm_bindgen]
pub fn wire_bdk_derivation_path_from_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: String,
) {
    wire_bdk_derivation_path_from_string_impl(port_, path)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_public_key_as_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_public_key_as_string_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_public_key_derive(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    path: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_public_key_derive_impl(port_, ptr, path)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_public_key_extend(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    path: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_public_key_extend_impl(port_, ptr, path)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_public_key_from_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    public_key: String,
) {
    wire_bdk_descriptor_public_key_from_string_impl(port_, public_key)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_as_public(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_secret_key_as_public_impl(port_, ptr)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_as_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_secret_key_as_string_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_create(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    network: i32,
    mnemonic: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    password: Option<String>,
) {
    wire_bdk_descriptor_secret_key_create_impl(port_, network, mnemonic, password)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_derive(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    path: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_secret_key_derive_impl(port_, ptr, path)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_extend(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    path: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_secret_key_extend_impl(port_, ptr, path)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_from_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: String,
) {
    wire_bdk_descriptor_secret_key_from_string_impl(port_, secret_key)
}

#[wasm_bindgen]
pub fn wire_bdk_descriptor_secret_key_secret_bytes(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_descriptor_secret_key_secret_bytes_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_mnemonic_as_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_mnemonic_as_string_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_mnemonic_from_entropy(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entropy: Box<[u8]>,
) {
    wire_bdk_mnemonic_from_entropy_impl(port_, entropy)
}

#[wasm_bindgen]
pub fn wire_bdk_mnemonic_from_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: String,
) {
    wire_bdk_mnemonic_from_string_impl(port_, mnemonic)
}

#[wasm_bindgen]
pub fn wire_bdk_mnemonic_new(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    word_count: i32,
) {
    wire_bdk_mnemonic_new_impl(port_, word_count)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_combine(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    other: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_combine_impl(port_, ptr, other)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_extract_tx(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_extract_tx_impl(port_, ptr)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_fee_amount(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_fee_amount_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_fee_rate(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_fee_rate_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_from_str(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    psbt_base64: String,
) {
    wire_bdk_psbt_from_str_impl(port_, psbt_base64)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_json_serialize(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_json_serialize_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_serialize(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_serialize_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_psbt_txid(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_psbt_txid_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_address_as_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_address_as_string_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_address_from_script(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    script: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    network: i32,
) {
    wire_bdk_address_from_script_impl(port_, script, network)
}

#[wasm_bindgen]
pub fn wire_bdk_address_from_string(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: String,
    network: i32,
) {
    wire_bdk_address_from_string_impl(port_, address, network)
}

#[wasm_bindgen]
pub fn wire_bdk_address_is_valid_for_network(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    network: i32,
) {
    wire_bdk_address_is_valid_for_network_impl(port_, that, network)
}

#[wasm_bindgen]
pub fn wire_bdk_address_network(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_address_network_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_address_payload(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_address_payload_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_address_script(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_address_script_impl(port_, ptr)
}

#[wasm_bindgen]
pub fn wire_bdk_address_to_qr_uri(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_address_to_qr_uri_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_script_buf_empty(port_: flutter_rust_bridge::for_generated::MessagePort) {
    wire_bdk_script_buf_empty_impl(port_)
}

#[wasm_bindgen]
pub fn wire_bdk_script_buf_from_hex(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: String,
) {
    wire_bdk_script_buf_from_hex_impl(port_, s)
}

#[wasm_bindgen]
pub fn wire_bdk_script_buf_with_capacity(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    capacity: usize,
) {
    wire_bdk_script_buf_with_capacity_impl(port_, capacity)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_from_bytes(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    transaction_bytes: Box<[u8]>,
) {
    wire_bdk_transaction_from_bytes_impl(port_, transaction_bytes)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_input(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_input_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_is_coin_base(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_is_coin_base_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_is_explicitly_rbf(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_is_explicitly_rbf_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_is_lock_time_enabled(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_is_lock_time_enabled_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_lock_time(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_lock_time_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_new(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    version: i32,
    lock_time: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    input: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    output: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_new_impl(port_, version, lock_time, input, output)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_output(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_output_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_serialize(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_serialize_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_size(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_size_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_txid(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_txid_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_version(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_version_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_vsize(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_vsize_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_transaction_weight(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_transaction_weight_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_get_address(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    address_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_get_address_impl(port_, ptr, address_index)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_get_balance(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_get_balance_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_get_descriptor_for_keychain(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    keychain: i32,
) {
    wire_bdk_wallet_get_descriptor_for_keychain_impl(port_, ptr, keychain)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_get_internal_address(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    address_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_get_internal_address_impl(port_, ptr, address_index)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_get_psbt_input(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    utxo: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    only_witness_utxo: bool,
    sighash_type: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_get_psbt_input_impl(port_, that, utxo, only_witness_utxo, sighash_type)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_is_mine(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    script: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_is_mine_impl(port_, that, script)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_list_transactions(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    include_raw: bool,
) {
    wire_bdk_wallet_list_transactions_impl(port_, that, include_raw)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_list_unspent(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_list_unspent_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_network(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_network_impl(port_, that)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_new(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    descriptor: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    change_descriptor: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    network: i32,
    database_config: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_new_impl(
        port_,
        descriptor,
        change_descriptor,
        network,
        database_config,
    )
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_sign(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    psbt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    sign_options: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_sign_impl(port_, ptr, psbt, sign_options)
}

#[wasm_bindgen]
pub fn wire_bdk_wallet_sync(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    blockchain: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_bdk_wallet_sync_impl(port_, ptr, blockchain)
}

#[wasm_bindgen]
pub fn wire_finish_bump_fee_tx_builder(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    txid: String,
    fee_rate: f32,
    allow_shrinking: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    wallet: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    enable_rbf: bool,
    n_sequence: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
) {
    wire_finish_bump_fee_tx_builder_impl(
        port_,
        txid,
        fee_rate,
        allow_shrinking,
        wallet,
        enable_rbf,
        n_sequence,
    )
}

#[wasm_bindgen]
pub fn wire_tx_builder_finish(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    recipients: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    utxos: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    foreign_utxo: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    un_spendable: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    change_policy: i32,
    manually_selected_only: bool,
    fee_rate: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    fee_absolute: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    drain_wallet: bool,
    drain_to: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    rbf: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    data: Box<[u8]>,
) {
    wire_tx_builder_finish_impl(
        port_,
        wallet,
        recipients,
        utxos,
        foreign_utxo,
        un_spendable,
        change_policy,
        manually_selected_only,
        fee_rate,
        fee_absolute,
        drain_wallet,
        drain_to,
        rbf,
        data,
    )
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_AnyBlockchain(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<AnyBlockchain>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_AnyBlockchain(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<AnyBlockchain>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_ExtendedDescriptor(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<ExtendedDescriptor>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_ExtendedDescriptor(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<ExtendedDescriptor>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_MutexPartiallySignedTransaction(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<Mutex<PartiallySignedTransaction>>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_MutexPartiallySignedTransaction(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<Mutex<PartiallySignedTransaction>>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_MutexbdkWalletAnyDatabase(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<Mutex<bdk::Wallet<AnyDatabase>>>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_MutexbdkWalletAnyDatabase(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<Mutex<bdk::Wallet<AnyDatabase>>>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_bdkbitcoinAddress(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<bdk::bitcoin::Address>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinAddress(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<bdk::bitcoin::Address>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_bitcoinbip32DerivationPath(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bitcoin::bip32::DerivationPath>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_bitcoinbip32DerivationPath(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<bitcoin::bip32::DerivationPath>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_keysDescriptorPublicKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<keys::DescriptorPublicKey>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_keysDescriptorPublicKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<keys::DescriptorPublicKey>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_keysDescriptorSecretKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<keys::DescriptorSecretKey>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_keysDescriptorSecretKey(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<keys::DescriptorSecretKey>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_keysKeyMap(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<keys::KeyMap>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_keysKeyMap(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<keys::KeyMap>::decrement_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_increment_strong_count_RustOpaque_keysbip39Mnemonic(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<keys::bip39::Mnemonic>::increment_strong_count(ptr as _);
    }
}

#[wasm_bindgen]
pub fn rust_arc_decrement_strong_count_RustOpaque_keysbip39Mnemonic(ptr: *const std::ffi::c_void) {
    unsafe {
        StdArc::<keys::bip39::Mnemonic>::decrement_strong_count(ptr as _);
    }
}
