// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/blockchain.dart';
import 'api/descriptor.dart';
import 'api/error.dart';
import 'api/key.dart';
import 'api/psbt.dart';
import 'api/types.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class core extends BaseEntrypoint<coreApi, coreApiImpl, coreWire> {
  @internal
  static final instance = core._();

  core._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    coreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required coreApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<coreApiImpl, coreWire> get apiImplConstructor =>
      coreApiImpl.new;

  @override
  WireConstructor<coreWire> get wireConstructor => coreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 1986252746;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'bdk_flutter',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class coreApi extends BaseApi {
  String crateApiTypesBdkAddressAsString({required BdkAddress that});

  BdkAddress crateApiTypesBdkAddressFromScript({
    required BdkScriptBuf script,
    required Network network,
  });

  BdkAddress crateApiTypesBdkAddressFromString({
    required String address,
    required Network network,
  });

  bool crateApiTypesBdkAddressIsValidForNetwork({
    required BdkAddress that,
    required Network network,
  });

  Network crateApiTypesBdkAddressNetwork({required BdkAddress that});

  Payload crateApiTypesBdkAddressPayload({required BdkAddress that});

  BdkScriptBuf crateApiTypesBdkAddressScript({required BdkAddress ptr});

  String crateApiTypesBdkAddressToQrUri({required BdkAddress that});

  Future<String> crateApiBlockchainBdkBlockchainBroadcast({
    required BdkBlockchain ptr,
    required BdkTransaction transaction,
  });

  Future<BdkBlockchain> crateApiBlockchainBdkBlockchainCreate({
    required BlockchainConfig blockchainConfig,
  });

  Future<FeeRate> crateApiBlockchainBdkBlockchainEstimateFee({
    required BdkBlockchain that,
    required BigInt target,
  });

  Future<String> crateApiBlockchainBdkBlockchainGetBlockHash({
    required BdkBlockchain that,
    required int height,
  });

  Future<int> crateApiBlockchainBdkBlockchainGetHeight({
    required BdkBlockchain that,
  });

  String crateApiKeyBdkDerivationPathAsString({
    required BdkDerivationPath that,
  });

  BdkDerivationPath crateApiKeyBdkDerivationPathFromString({
    required String path,
  });

  String crateApiDescriptorBdkDescriptorAsString({required BdkDescriptor that});

  BdkDescriptor crateApiDescriptorBdkDescriptorCreate({
    required String descriptor,
    required Network network,
  });

  BigInt crateApiDescriptorBdkDescriptorMaxSatisfactionWeight({
    required BdkDescriptor that,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip44({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip44Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip49({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip49Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip84({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip84Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip86({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  });

  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip86Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  });

  String crateApiKeyBdkDescriptorPublicKeyAsString({
    required BdkDescriptorPublicKey that,
  });

  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyDerive({
    required BdkDescriptorPublicKey ptr,
    required BdkDerivationPath path,
  });

  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyExtend({
    required BdkDescriptorPublicKey ptr,
    required BdkDerivationPath path,
  });

  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyFromString({
    required String publicKey,
  });

  BdkDescriptorPublicKey crateApiKeyBdkDescriptorSecretKeyAsPublic({
    required BdkDescriptorSecretKey ptr,
  });

  String crateApiKeyBdkDescriptorSecretKeyAsString({
    required BdkDescriptorSecretKey that,
  });

  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyCreate({
    required Network network,
    required BdkMnemonic mnemonic,
    String? password,
  });

  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyDerive({
    required BdkDescriptorSecretKey ptr,
    required BdkDerivationPath path,
  });

  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyExtend({
    required BdkDescriptorSecretKey ptr,
    required BdkDerivationPath path,
  });

  Future<BdkDescriptorSecretKey> crateApiKeyBdkDescriptorSecretKeyFromString({
    required String secretKey,
  });

  Uint8List crateApiKeyBdkDescriptorSecretKeySecretBytes({
    required BdkDescriptorSecretKey that,
  });

  String crateApiDescriptorBdkDescriptorToStringPrivate({
    required BdkDescriptor that,
  });

  String crateApiKeyBdkMnemonicAsString({required BdkMnemonic that});

  BdkMnemonic crateApiKeyBdkMnemonicCreate({required WordCount wordCount});

  BdkMnemonic crateApiKeyBdkMnemonicFromEntropy({required List<int> entropy});

  BdkMnemonic crateApiKeyBdkMnemonicFromString({required String mnemonic});

  String crateApiTypesBdkPolicyAsString({required BdkPolicy that});

  Satisfaction crateApiTypesBdkPolicyContribution({required BdkPolicy that});

  String crateApiTypesBdkPolicyId({required BdkPolicy that});

  SatisfiableItem crateApiTypesBdkPolicyItem({required BdkPolicy that});

  bool crateApiTypesBdkPolicyRequiresPath({required BdkPolicy that});

  Satisfaction crateApiTypesBdkPolicySatisfaction({required BdkPolicy that});

  String crateApiPsbtBdkPsbtAsString({required BdkPsbt that});

  BdkPsbt crateApiPsbtBdkPsbtCombine({
    required BdkPsbt ptr,
    required BdkPsbt other,
  });

  BdkTransaction crateApiPsbtBdkPsbtExtractTx({required BdkPsbt ptr});

  BigInt? crateApiPsbtBdkPsbtFeeAmount({required BdkPsbt that});

  FeeRate? crateApiPsbtBdkPsbtFeeRate({required BdkPsbt that});

  BdkPsbt crateApiPsbtBdkPsbtFromStr({required String psbtBase64});

  String crateApiPsbtBdkPsbtJsonSerialize({required BdkPsbt that});

  Uint8List crateApiPsbtBdkPsbtSerialize({required BdkPsbt that});

  String crateApiPsbtBdkPsbtTxid({required BdkPsbt that});

  String crateApiTypesBdkScriptBufAsString({required BdkScriptBuf that});

  BdkScriptBuf crateApiTypesBdkScriptBufEmpty();

  BdkScriptBuf crateApiTypesBdkScriptBufFromHex({required String s});

  BdkScriptBuf crateApiTypesBdkScriptBufWithCapacity({
    required BigInt capacity,
  });

  BdkTransaction crateApiTypesBdkTransactionCreate({
    required int version,
    required LockTime lockTime,
    required List<BdkTxIn> input,
    required List<BdkTxOut> output,
  });

  BdkTransaction crateApiTypesBdkTransactionFromBytes({
    required List<int> transactionBytes,
  });

  List<BdkTxIn> crateApiTypesBdkTransactionInput({
    required BdkTransaction that,
  });

  bool crateApiTypesBdkTransactionIsCoinBase({required BdkTransaction that});

  bool crateApiTypesBdkTransactionIsExplicitlyRbf({
    required BdkTransaction that,
  });

  bool crateApiTypesBdkTransactionIsLockTimeEnabled({
    required BdkTransaction that,
  });

  LockTime crateApiTypesBdkTransactionLockTime({required BdkTransaction that});

  List<BdkTxOut> crateApiTypesBdkTransactionOutput({
    required BdkTransaction that,
  });

  Uint8List crateApiTypesBdkTransactionSerialize({
    required BdkTransaction that,
  });

  BigInt crateApiTypesBdkTransactionSize({required BdkTransaction that});

  String crateApiTypesBdkTransactionTxid({required BdkTransaction that});

  int crateApiTypesBdkTransactionVersion({required BdkTransaction that});

  BigInt crateApiTypesBdkTransactionVsize({required BdkTransaction that});

  BigInt crateApiTypesBdkTransactionWeight({required BdkTransaction that});

  Future<BdkWallet> crateApiWalletBdkWalletCreate({
    required BdkDescriptor descriptor,
    BdkDescriptor? changeDescriptor,
    required Network network,
    required DatabaseConfig databaseConfig,
  });

  (BdkAddress, int) crateApiWalletBdkWalletGetAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  });

  Balance crateApiWalletBdkWalletGetBalance({required BdkWallet that});

  BdkDescriptor crateApiWalletBdkWalletGetDescriptorForKeychain({
    required BdkWallet ptr,
    required KeychainKind keychain,
  });

  (BdkAddress, int) crateApiWalletBdkWalletGetInternalAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  });

  Input crateApiWalletBdkWalletGetPsbtInput({
    required BdkWallet that,
    required LocalUtxo utxo,
    required bool onlyWitnessUtxo,
    PsbtSigHashType? sighashType,
  });

  bool crateApiWalletBdkWalletIsMine({
    required BdkWallet ptr,
    required BdkScriptBuf script,
  });

  List<BdkTransactionDetails> crateApiWalletBdkWalletListTransactions({
    required BdkWallet that,
    required bool includeRaw,
  });

  List<LocalUtxo> crateApiWalletBdkWalletListUnspent({required BdkWallet that});

  Network crateApiWalletBdkWalletNetwork({required BdkWallet that});

  BdkPolicy? crateApiWalletBdkWalletPolicies({
    required BdkWallet ptr,
    required KeychainKind keychain,
  });

  bool crateApiWalletBdkWalletSign({
    required BdkWallet ptr,
    required BdkPsbt psbt,
    SignOptions? signOptions,
  });

  Future<void> crateApiWalletBdkWalletSync({
    required BdkWallet ptr,
    required BdkBlockchain blockchain,
  });

  Future<(BdkPsbt, BdkTransactionDetails)>
  crateApiWalletFinishBumpFeeTxBuilder({
    required String txid,
    required double feeRate,
    BdkAddress? allowShrinking,
    required BdkWallet wallet,
    required bool enableRbf,
    int? nSequence,
  });

  Future<Network> crateApiTypesNetworkDefault();

  Future<SignOptions> crateApiTypesSignOptionsDefault();

  Future<(BdkPsbt, BdkTransactionDetails)> crateApiWalletTxBuilderFinish({
    required BdkWallet wallet,
    required List<ScriptAmount> recipients,
    required List<OutPoint> utxos,
    (OutPoint, Input, BigInt)? foreignUtxo,
    required List<OutPoint> unSpendable,
    required ChangeSpendPolicy changePolicy,
    required bool manuallySelectedOnly,
    double? feeRate,
    BigInt? feeAbsolute,
    required bool drainWallet,
    BdkScriptBuf? drainTo,
    RbfValue? rbf,
    Map<String, Uint32List>? internalPolicyPath,
    Map<String, Uint32List>? externalPolicyPath,
    required List<int> data,
  });

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Address;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Address;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AddressPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DerivationPath;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DerivationPath;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_DerivationPathPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_AnyBlockchain;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_AnyBlockchain;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_AnyBlockchainPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ExtendedDescriptor;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ExtendedDescriptor;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ExtendedDescriptorPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Policy;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Policy;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PolicyPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DescriptorPublicKey;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DescriptorPublicKey;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_DescriptorPublicKeyPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DescriptorSecretKey;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DescriptorSecretKey;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_DescriptorSecretKeyPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_KeyMap;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_KeyMap;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_KeyMapPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_Mnemonic;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_Mnemonic;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MutexWalletAnyDatabase;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MutexWalletAnyDatabase;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_MutexWalletAnyDatabasePtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MutexPartiallySignedTransaction;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MutexPartiallySignedTransaction;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_MutexPartiallySignedTransactionPtr;
}

class coreApiImpl extends coreApiImplPlatform implements coreApi {
  coreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  String crateApiTypesBdkAddressAsString({required BdkAddress that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(that);
          return wire.wire__crate__api__types__bdk_address_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_address_as_string",
        argNames: ["that"],
      );

  @override
  BdkAddress crateApiTypesBdkAddressFromScript({
    required BdkScriptBuf script,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_script_buf(script);
          var arg1 = cst_encode_network(network);
          return wire.wire__crate__api__types__bdk_address_from_script(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_address,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkAddressFromScriptConstMeta,
        argValues: [script, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressFromScriptConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_address_from_script",
        argNames: ["script", "network"],
      );

  @override
  BdkAddress crateApiTypesBdkAddressFromString({
    required String address,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(address);
          var arg1 = cst_encode_network(network);
          return wire.wire__crate__api__types__bdk_address_from_string(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_address,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkAddressFromStringConstMeta,
        argValues: [address, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_address_from_string",
        argNames: ["address", "network"],
      );

  @override
  bool crateApiTypesBdkAddressIsValidForNetwork({
    required BdkAddress that,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(that);
          var arg1 = cst_encode_network(network);
          return wire.wire__crate__api__types__bdk_address_is_valid_for_network(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressIsValidForNetworkConstMeta,
        argValues: [that, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressIsValidForNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_address_is_valid_for_network",
        argNames: ["that", "network"],
      );

  @override
  Network crateApiTypesBdkAddressNetwork({required BdkAddress that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(that);
          return wire.wire__crate__api__types__bdk_address_network(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_network,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressNetworkConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressNetworkConstMeta =>
      const TaskConstMeta(debugName: "bdk_address_network", argNames: ["that"]);

  @override
  Payload crateApiTypesBdkAddressPayload({required BdkAddress that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(that);
          return wire.wire__crate__api__types__bdk_address_payload(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_payload,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressPayloadConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressPayloadConstMeta =>
      const TaskConstMeta(debugName: "bdk_address_payload", argNames: ["that"]);

  @override
  BdkScriptBuf crateApiTypesBdkAddressScript({required BdkAddress ptr}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(ptr);
          return wire.wire__crate__api__types__bdk_address_script(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_script_buf,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressScriptConstMeta,
        argValues: [ptr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressScriptConstMeta =>
      const TaskConstMeta(debugName: "bdk_address_script", argNames: ["ptr"]);

  @override
  String crateApiTypesBdkAddressToQrUri({required BdkAddress that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_address(that);
          return wire.wire__crate__api__types__bdk_address_to_qr_uri(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkAddressToQrUriConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkAddressToQrUriConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_address_to_qr_uri",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiBlockchainBdkBlockchainBroadcast({
    required BdkBlockchain ptr,
    required BdkTransaction transaction,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_blockchain(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_transaction(transaction);
          return wire.wire__crate__api__blockchain__bdk_blockchain_broadcast(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiBlockchainBdkBlockchainBroadcastConstMeta,
        argValues: [ptr, transaction],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBlockchainBdkBlockchainBroadcastConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_blockchain_broadcast",
        argNames: ["ptr", "transaction"],
      );

  @override
  Future<BdkBlockchain> crateApiBlockchainBdkBlockchainCreate({
    required BlockchainConfig blockchainConfig,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_blockchain_config(blockchainConfig);
          return wire.wire__crate__api__blockchain__bdk_blockchain_create(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_blockchain,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiBlockchainBdkBlockchainCreateConstMeta,
        argValues: [blockchainConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBlockchainBdkBlockchainCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_blockchain_create",
        argNames: ["blockchainConfig"],
      );

  @override
  Future<FeeRate> crateApiBlockchainBdkBlockchainEstimateFee({
    required BdkBlockchain that,
    required BigInt target,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
          var arg1 = cst_encode_u_64(target);
          return wire.wire__crate__api__blockchain__bdk_blockchain_estimate_fee(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_fee_rate,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiBlockchainBdkBlockchainEstimateFeeConstMeta,
        argValues: [that, target],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBlockchainBdkBlockchainEstimateFeeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_blockchain_estimate_fee",
        argNames: ["that", "target"],
      );

  @override
  Future<String> crateApiBlockchainBdkBlockchainGetBlockHash({
    required BdkBlockchain that,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
          var arg1 = cst_encode_u_32(height);
          return wire
              .wire__crate__api__blockchain__bdk_blockchain_get_block_hash(
                port_,
                arg0,
                arg1,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiBlockchainBdkBlockchainGetBlockHashConstMeta,
        argValues: [that, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBlockchainBdkBlockchainGetBlockHashConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_blockchain_get_block_hash",
        argNames: ["that", "height"],
      );

  @override
  Future<int> crateApiBlockchainBdkBlockchainGetHeight({
    required BdkBlockchain that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
          return wire.wire__crate__api__blockchain__bdk_blockchain_get_height(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_32,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiBlockchainBdkBlockchainGetHeightConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBlockchainBdkBlockchainGetHeightConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_blockchain_get_height",
        argNames: ["that"],
      );

  @override
  String crateApiKeyBdkDerivationPathAsString({
    required BdkDerivationPath that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_derivation_path(that);
          return wire.wire__crate__api__key__bdk_derivation_path_as_string(
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiKeyBdkDerivationPathAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDerivationPathAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_derivation_path_as_string",
        argNames: ["that"],
      );

  @override
  BdkDerivationPath crateApiKeyBdkDerivationPathFromString({
    required String path,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(path);
          return wire.wire__crate__api__key__bdk_derivation_path_from_string(
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_derivation_path,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDerivationPathFromStringConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDerivationPathFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_derivation_path_from_string",
        argNames: ["path"],
      );

  @override
  String crateApiDescriptorBdkDescriptorAsString({
    required BdkDescriptor that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
          return wire.wire__crate__api__descriptor__bdk_descriptor_as_string(
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_as_string",
        argNames: ["that"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorCreate({
    required String descriptor,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(descriptor);
          var arg1 = cst_encode_network(network);
          return wire.wire__crate__api__descriptor__bdk_descriptor_create(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorCreateConstMeta,
        argValues: [descriptor, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_create",
        argNames: ["descriptor", "network"],
      );

  @override
  BigInt crateApiDescriptorBdkDescriptorMaxSatisfactionWeight({
    required BdkDescriptor that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_max_satisfaction_weight(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta:
            kCrateApiDescriptorBdkDescriptorMaxSatisfactionWeightConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDescriptorBdkDescriptorMaxSatisfactionWeightConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_max_satisfaction_weight",
        argNames: ["that"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip44({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(
            secretKey,
          );
          var arg1 = cst_encode_keychain_kind(keychainKind);
          var arg2 = cst_encode_network(network);
          return wire.wire__crate__api__descriptor__bdk_descriptor_new_bip44(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip44ConstMeta,
        argValues: [secretKey, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip44ConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip44",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip44Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(
            publicKey,
          );
          var arg1 = cst_encode_String(fingerprint);
          var arg2 = cst_encode_keychain_kind(keychainKind);
          var arg3 = cst_encode_network(network);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_new_bip44_public(
                arg0,
                arg1,
                arg2,
                arg3,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip44PublicConstMeta,
        argValues: [publicKey, fingerprint, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip44PublicConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip44_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip49({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(
            secretKey,
          );
          var arg1 = cst_encode_keychain_kind(keychainKind);
          var arg2 = cst_encode_network(network);
          return wire.wire__crate__api__descriptor__bdk_descriptor_new_bip49(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip49ConstMeta,
        argValues: [secretKey, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip49ConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip49",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip49Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(
            publicKey,
          );
          var arg1 = cst_encode_String(fingerprint);
          var arg2 = cst_encode_keychain_kind(keychainKind);
          var arg3 = cst_encode_network(network);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_new_bip49_public(
                arg0,
                arg1,
                arg2,
                arg3,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip49PublicConstMeta,
        argValues: [publicKey, fingerprint, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip49PublicConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip49_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip84({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(
            secretKey,
          );
          var arg1 = cst_encode_keychain_kind(keychainKind);
          var arg2 = cst_encode_network(network);
          return wire.wire__crate__api__descriptor__bdk_descriptor_new_bip84(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip84ConstMeta,
        argValues: [secretKey, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip84ConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip84",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip84Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(
            publicKey,
          );
          var arg1 = cst_encode_String(fingerprint);
          var arg2 = cst_encode_keychain_kind(keychainKind);
          var arg3 = cst_encode_network(network);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_new_bip84_public(
                arg0,
                arg1,
                arg2,
                arg3,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip84PublicConstMeta,
        argValues: [publicKey, fingerprint, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip84PublicConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip84_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip86({
    required BdkDescriptorSecretKey secretKey,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(
            secretKey,
          );
          var arg1 = cst_encode_keychain_kind(keychainKind);
          var arg2 = cst_encode_network(network);
          return wire.wire__crate__api__descriptor__bdk_descriptor_new_bip86(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip86ConstMeta,
        argValues: [secretKey, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip86ConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip86",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  BdkDescriptor crateApiDescriptorBdkDescriptorNewBip86Public({
    required BdkDescriptorPublicKey publicKey,
    required String fingerprint,
    required KeychainKind keychainKind,
    required Network network,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(
            publicKey,
          );
          var arg1 = cst_encode_String(fingerprint);
          var arg2 = cst_encode_keychain_kind(keychainKind);
          var arg3 = cst_encode_network(network);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_new_bip86_public(
                arg0,
                arg1,
                arg2,
                arg3,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorNewBip86PublicConstMeta,
        argValues: [publicKey, fingerprint, keychainKind, network],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorNewBip86PublicConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_new_bip86_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  String crateApiKeyBdkDescriptorPublicKeyAsString({
    required BdkDescriptorPublicKey that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(that);
          return wire
              .wire__crate__api__key__bdk_descriptor_public_key_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiKeyBdkDescriptorPublicKeyAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorPublicKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_public_key_as_string",
        argNames: ["that"],
      );

  @override
  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyDerive({
    required BdkDescriptorPublicKey ptr,
    required BdkDerivationPath path,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
          return wire.wire__crate__api__key__bdk_descriptor_public_key_derive(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_public_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorPublicKeyDeriveConstMeta,
        argValues: [ptr, path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorPublicKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_public_key_derive",
        argNames: ["ptr", "path"],
      );

  @override
  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyExtend({
    required BdkDescriptorPublicKey ptr,
    required BdkDerivationPath path,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
          return wire.wire__crate__api__key__bdk_descriptor_public_key_extend(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_public_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorPublicKeyExtendConstMeta,
        argValues: [ptr, path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorPublicKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_public_key_extend",
        argNames: ["ptr", "path"],
      );

  @override
  BdkDescriptorPublicKey crateApiKeyBdkDescriptorPublicKeyFromString({
    required String publicKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(publicKey);
          return wire
              .wire__crate__api__key__bdk_descriptor_public_key_from_string(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_public_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorPublicKeyFromStringConstMeta,
        argValues: [publicKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorPublicKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_public_key_from_string",
        argNames: ["publicKey"],
      );

  @override
  BdkDescriptorPublicKey crateApiKeyBdkDescriptorSecretKeyAsPublic({
    required BdkDescriptorSecretKey ptr,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
          return wire
              .wire__crate__api__key__bdk_descriptor_secret_key_as_public(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_public_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyAsPublicConstMeta,
        argValues: [ptr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyAsPublicConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_as_public",
        argNames: ["ptr"],
      );

  @override
  String crateApiKeyBdkDescriptorSecretKeyAsString({
    required BdkDescriptorSecretKey that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(that);
          return wire
              .wire__crate__api__key__bdk_descriptor_secret_key_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_as_string",
        argNames: ["that"],
      );

  @override
  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyCreate({
    required Network network,
    required BdkMnemonic mnemonic,
    String? password,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_network(network);
          var arg1 = cst_encode_box_autoadd_bdk_mnemonic(mnemonic);
          var arg2 = cst_encode_opt_String(password);
          return wire.wire__crate__api__key__bdk_descriptor_secret_key_create(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyCreateConstMeta,
        argValues: [network, mnemonic, password],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_create",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyDerive({
    required BdkDescriptorSecretKey ptr,
    required BdkDerivationPath path,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
          return wire.wire__crate__api__key__bdk_descriptor_secret_key_derive(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyDeriveConstMeta,
        argValues: [ptr, path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_derive",
        argNames: ["ptr", "path"],
      );

  @override
  BdkDescriptorSecretKey crateApiKeyBdkDescriptorSecretKeyExtend({
    required BdkDescriptorSecretKey ptr,
    required BdkDerivationPath path,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
          return wire.wire__crate__api__key__bdk_descriptor_secret_key_extend(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyExtendConstMeta,
        argValues: [ptr, path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_extend",
        argNames: ["ptr", "path"],
      );

  @override
  Future<BdkDescriptorSecretKey> crateApiKeyBdkDescriptorSecretKeyFromString({
    required String secretKey,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(secretKey);
          return wire
              .wire__crate__api__key__bdk_descriptor_secret_key_from_string(
                port_,
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeyFromStringConstMeta,
        argValues: [secretKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_from_string",
        argNames: ["secretKey"],
      );

  @override
  Uint8List crateApiKeyBdkDescriptorSecretKeySecretBytes({
    required BdkDescriptorSecretKey that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(that);
          return wire
              .wire__crate__api__key__bdk_descriptor_secret_key_secret_bytes(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_u_8_strict,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkDescriptorSecretKeySecretBytesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkDescriptorSecretKeySecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_secret_key_secret_bytes",
        argNames: ["that"],
      );

  @override
  String crateApiDescriptorBdkDescriptorToStringPrivate({
    required BdkDescriptor that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
          return wire
              .wire__crate__api__descriptor__bdk_descriptor_to_string_private(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDescriptorBdkDescriptorToStringPrivateConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDescriptorBdkDescriptorToStringPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_descriptor_to_string_private",
        argNames: ["that"],
      );

  @override
  String crateApiKeyBdkMnemonicAsString({required BdkMnemonic that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_mnemonic(that);
          return wire.wire__crate__api__key__bdk_mnemonic_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiKeyBdkMnemonicAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkMnemonicAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_mnemonic_as_string",
        argNames: ["that"],
      );

  @override
  BdkMnemonic crateApiKeyBdkMnemonicCreate({required WordCount wordCount}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_word_count(wordCount);
          return wire.wire__crate__api__key__bdk_mnemonic_create(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_mnemonic,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkMnemonicCreateConstMeta,
        argValues: [wordCount],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkMnemonicCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_mnemonic_create",
        argNames: ["wordCount"],
      );

  @override
  BdkMnemonic crateApiKeyBdkMnemonicFromEntropy({required List<int> entropy}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_list_prim_u_8_loose(entropy);
          return wire.wire__crate__api__key__bdk_mnemonic_from_entropy(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_mnemonic,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkMnemonicFromEntropyConstMeta,
        argValues: [entropy],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkMnemonicFromEntropyConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_mnemonic_from_entropy",
        argNames: ["entropy"],
      );

  @override
  BdkMnemonic crateApiKeyBdkMnemonicFromString({required String mnemonic}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(mnemonic);
          return wire.wire__crate__api__key__bdk_mnemonic_from_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_mnemonic,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiKeyBdkMnemonicFromStringConstMeta,
        argValues: [mnemonic],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiKeyBdkMnemonicFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_mnemonic_from_string",
        argNames: ["mnemonic"],
      );

  @override
  String crateApiTypesBdkPolicyAsString({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkPolicyAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_policy_as_string",
        argNames: ["that"],
      );

  @override
  Satisfaction crateApiTypesBdkPolicyContribution({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_contribution(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_satisfaction,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkPolicyContributionConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicyContributionConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_policy_contribution",
        argNames: ["that"],
      );

  @override
  String crateApiTypesBdkPolicyId({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_id(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkPolicyIdConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicyIdConstMeta =>
      const TaskConstMeta(debugName: "bdk_policy_id", argNames: ["that"]);

  @override
  SatisfiableItem crateApiTypesBdkPolicyItem({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_item(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_satisfiable_item,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkPolicyItemConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicyItemConstMeta =>
      const TaskConstMeta(debugName: "bdk_policy_item", argNames: ["that"]);

  @override
  bool crateApiTypesBdkPolicyRequiresPath({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_requires_path(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkPolicyRequiresPathConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicyRequiresPathConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_policy_requires_path",
        argNames: ["that"],
      );

  @override
  Satisfaction crateApiTypesBdkPolicySatisfaction({required BdkPolicy that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_policy(that);
          return wire.wire__crate__api__types__bdk_policy_satisfaction(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_satisfaction,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkPolicySatisfactionConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkPolicySatisfactionConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_policy_satisfaction",
        argNames: ["that"],
      );

  @override
  String crateApiPsbtBdkPsbtAsString({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtAsStringConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_as_string", argNames: ["that"]);

  @override
  BdkPsbt crateApiPsbtBdkPsbtCombine({
    required BdkPsbt ptr,
    required BdkPsbt other,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_psbt(other);
          return wire.wire__crate__api__psbt__bdk_psbt_combine(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_psbt,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtCombineConstMeta,
        argValues: [ptr, other],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtCombineConstMeta => const TaskConstMeta(
    debugName: "bdk_psbt_combine",
    argNames: ["ptr", "other"],
  );

  @override
  BdkTransaction crateApiPsbtBdkPsbtExtractTx({required BdkPsbt ptr}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(ptr);
          return wire.wire__crate__api__psbt__bdk_psbt_extract_tx(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_transaction,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtExtractTxConstMeta,
        argValues: [ptr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtExtractTxConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_extract_tx", argNames: ["ptr"]);

  @override
  BigInt? crateApiPsbtBdkPsbtFeeAmount({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_fee_amount(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_u_64,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtFeeAmountConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtFeeAmountConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_fee_amount", argNames: ["that"]);

  @override
  FeeRate? crateApiPsbtBdkPsbtFeeRate({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_fee_rate(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_fee_rate,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtFeeRateConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtFeeRateConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_fee_rate", argNames: ["that"]);

  @override
  BdkPsbt crateApiPsbtBdkPsbtFromStr({required String psbtBase64}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(psbtBase64);
          return wire.wire__crate__api__psbt__bdk_psbt_from_str(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_psbt,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtFromStrConstMeta,
        argValues: [psbtBase64],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtFromStrConstMeta => const TaskConstMeta(
    debugName: "bdk_psbt_from_str",
    argNames: ["psbtBase64"],
  );

  @override
  String crateApiPsbtBdkPsbtJsonSerialize({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_json_serialize(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtJsonSerializeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtJsonSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_psbt_json_serialize",
        argNames: ["that"],
      );

  @override
  Uint8List crateApiPsbtBdkPsbtSerialize({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_serialize(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_u_8_strict,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtSerializeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtSerializeConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_serialize", argNames: ["that"]);

  @override
  String crateApiPsbtBdkPsbtTxid({required BdkPsbt that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
          return wire.wire__crate__api__psbt__bdk_psbt_txid(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiPsbtBdkPsbtTxidConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsbtBdkPsbtTxidConstMeta =>
      const TaskConstMeta(debugName: "bdk_psbt_txid", argNames: ["that"]);

  @override
  String crateApiTypesBdkScriptBufAsString({required BdkScriptBuf that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_script_buf(that);
          return wire.wire__crate__api__types__bdk_script_buf_as_string(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkScriptBufAsStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkScriptBufAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_script_buf_as_string",
        argNames: ["that"],
      );

  @override
  BdkScriptBuf crateApiTypesBdkScriptBufEmpty() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__types__bdk_script_buf_empty();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_script_buf,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkScriptBufEmptyConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkScriptBufEmptyConstMeta =>
      const TaskConstMeta(debugName: "bdk_script_buf_empty", argNames: []);

  @override
  BdkScriptBuf crateApiTypesBdkScriptBufFromHex({required String s}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(s);
          return wire.wire__crate__api__types__bdk_script_buf_from_hex(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_script_buf,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkScriptBufFromHexConstMeta,
        argValues: [s],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkScriptBufFromHexConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_script_buf_from_hex",
        argNames: ["s"],
      );

  @override
  BdkScriptBuf crateApiTypesBdkScriptBufWithCapacity({
    required BigInt capacity,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_usize(capacity);
          return wire.wire__crate__api__types__bdk_script_buf_with_capacity(
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_script_buf,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesBdkScriptBufWithCapacityConstMeta,
        argValues: [capacity],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkScriptBufWithCapacityConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_script_buf_with_capacity",
        argNames: ["capacity"],
      );

  @override
  BdkTransaction crateApiTypesBdkTransactionCreate({
    required int version,
    required LockTime lockTime,
    required List<BdkTxIn> input,
    required List<BdkTxOut> output,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_i_32(version);
          var arg1 = cst_encode_box_autoadd_lock_time(lockTime);
          var arg2 = cst_encode_list_bdk_tx_in(input);
          var arg3 = cst_encode_list_bdk_tx_out(output);
          return wire.wire__crate__api__types__bdk_transaction_create(
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_transaction,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionCreateConstMeta,
        argValues: [version, lockTime, input, output],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_create",
        argNames: ["version", "lockTime", "input", "output"],
      );

  @override
  BdkTransaction crateApiTypesBdkTransactionFromBytes({
    required List<int> transactionBytes,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_list_prim_u_8_loose(transactionBytes);
          return wire.wire__crate__api__types__bdk_transaction_from_bytes(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_transaction,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionFromBytesConstMeta,
        argValues: [transactionBytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_from_bytes",
        argNames: ["transactionBytes"],
      );

  @override
  List<BdkTxIn> crateApiTypesBdkTransactionInput({
    required BdkTransaction that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_input(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_bdk_tx_in,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionInputConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionInputConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_input",
        argNames: ["that"],
      );

  @override
  bool crateApiTypesBdkTransactionIsCoinBase({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_is_coin_base(
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionIsCoinBaseConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionIsCoinBaseConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_is_coin_base",
        argNames: ["that"],
      );

  @override
  bool crateApiTypesBdkTransactionIsExplicitlyRbf({
    required BdkTransaction that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire
              .wire__crate__api__types__bdk_transaction_is_explicitly_rbf(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionIsExplicitlyRbfConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionIsExplicitlyRbfConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_is_explicitly_rbf",
        argNames: ["that"],
      );

  @override
  bool crateApiTypesBdkTransactionIsLockTimeEnabled({
    required BdkTransaction that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire
              .wire__crate__api__types__bdk_transaction_is_lock_time_enabled(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionIsLockTimeEnabledConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionIsLockTimeEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_is_lock_time_enabled",
        argNames: ["that"],
      );

  @override
  LockTime crateApiTypesBdkTransactionLockTime({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_lock_time(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_lock_time,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionLockTimeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionLockTimeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_lock_time",
        argNames: ["that"],
      );

  @override
  List<BdkTxOut> crateApiTypesBdkTransactionOutput({
    required BdkTransaction that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_output(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_bdk_tx_out,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionOutputConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionOutputConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_output",
        argNames: ["that"],
      );

  @override
  Uint8List crateApiTypesBdkTransactionSerialize({
    required BdkTransaction that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_serialize(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_u_8_strict,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionSerializeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_serialize",
        argNames: ["that"],
      );

  @override
  BigInt crateApiTypesBdkTransactionSize({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_size(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionSizeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionSizeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_size",
        argNames: ["that"],
      );

  @override
  String crateApiTypesBdkTransactionTxid({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_txid(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionTxidConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionTxidConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_txid",
        argNames: ["that"],
      );

  @override
  int crateApiTypesBdkTransactionVersion({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_version(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_i_32,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionVersionConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionVersionConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_version",
        argNames: ["that"],
      );

  @override
  BigInt crateApiTypesBdkTransactionVsize({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_vsize(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionVsizeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionVsizeConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_vsize",
        argNames: ["that"],
      );

  @override
  BigInt crateApiTypesBdkTransactionWeight({required BdkTransaction that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
          return wire.wire__crate__api__types__bdk_transaction_weight(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiTypesBdkTransactionWeightConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesBdkTransactionWeightConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_transaction_weight",
        argNames: ["that"],
      );

  @override
  Future<BdkWallet> crateApiWalletBdkWalletCreate({
    required BdkDescriptor descriptor,
    BdkDescriptor? changeDescriptor,
    required Network network,
    required DatabaseConfig databaseConfig,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_descriptor(descriptor);
          var arg1 = cst_encode_opt_box_autoadd_bdk_descriptor(
            changeDescriptor,
          );
          var arg2 = cst_encode_network(network);
          var arg3 = cst_encode_box_autoadd_database_config(databaseConfig);
          return wire.wire__crate__api__wallet__bdk_wallet_create(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_wallet,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletCreateConstMeta,
        argValues: [descriptor, changeDescriptor, network, databaseConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletCreateConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_create",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig",
        ],
      );

  @override
  (BdkAddress, int) crateApiWalletBdkWalletGetAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_box_autoadd_address_index(addressIndex);
          return wire.wire__crate__api__wallet__bdk_wallet_get_address(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_bdk_address_u_32,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletGetAddressConstMeta,
        argValues: [ptr, addressIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletGetAddressConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_get_address",
        argNames: ["ptr", "addressIndex"],
      );

  @override
  Balance crateApiWalletBdkWalletGetBalance({required BdkWallet that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
          return wire.wire__crate__api__wallet__bdk_wallet_get_balance(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_balance,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletGetBalanceConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletGetBalanceConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_get_balance",
        argNames: ["that"],
      );

  @override
  BdkDescriptor crateApiWalletBdkWalletGetDescriptorForKeychain({
    required BdkWallet ptr,
    required KeychainKind keychain,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_keychain_kind(keychain);
          return wire
              .wire__crate__api__wallet__bdk_wallet_get_descriptor_for_keychain(
                arg0,
                arg1,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bdk_descriptor,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletGetDescriptorForKeychainConstMeta,
        argValues: [ptr, keychain],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletGetDescriptorForKeychainConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_get_descriptor_for_keychain",
        argNames: ["ptr", "keychain"],
      );

  @override
  (BdkAddress, int) crateApiWalletBdkWalletGetInternalAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_box_autoadd_address_index(addressIndex);
          return wire.wire__crate__api__wallet__bdk_wallet_get_internal_address(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_bdk_address_u_32,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletGetInternalAddressConstMeta,
        argValues: [ptr, addressIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletGetInternalAddressConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_get_internal_address",
        argNames: ["ptr", "addressIndex"],
      );

  @override
  Input crateApiWalletBdkWalletGetPsbtInput({
    required BdkWallet that,
    required LocalUtxo utxo,
    required bool onlyWitnessUtxo,
    PsbtSigHashType? sighashType,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
          var arg1 = cst_encode_box_autoadd_local_utxo(utxo);
          var arg2 = cst_encode_bool(onlyWitnessUtxo);
          var arg3 = cst_encode_opt_box_autoadd_psbt_sig_hash_type(sighashType);
          return wire.wire__crate__api__wallet__bdk_wallet_get_psbt_input(
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_input,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletGetPsbtInputConstMeta,
        argValues: [that, utxo, onlyWitnessUtxo, sighashType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletGetPsbtInputConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_get_psbt_input",
        argNames: ["that", "utxo", "onlyWitnessUtxo", "sighashType"],
      );

  @override
  bool crateApiWalletBdkWalletIsMine({
    required BdkWallet ptr,
    required BdkScriptBuf script,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_script_buf(script);
          return wire.wire__crate__api__wallet__bdk_wallet_is_mine(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletIsMineConstMeta,
        argValues: [ptr, script],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletIsMineConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_is_mine",
        argNames: ["ptr", "script"],
      );

  @override
  List<BdkTransactionDetails> crateApiWalletBdkWalletListTransactions({
    required BdkWallet that,
    required bool includeRaw,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
          var arg1 = cst_encode_bool(includeRaw);
          return wire.wire__crate__api__wallet__bdk_wallet_list_transactions(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_bdk_transaction_details,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletListTransactionsConstMeta,
        argValues: [that, includeRaw],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletListTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_list_transactions",
        argNames: ["that", "includeRaw"],
      );

  @override
  List<LocalUtxo> crateApiWalletBdkWalletListUnspent({
    required BdkWallet that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
          return wire.wire__crate__api__wallet__bdk_wallet_list_unspent(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_local_utxo,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletListUnspentConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletListUnspentConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_list_unspent",
        argNames: ["that"],
      );

  @override
  Network crateApiWalletBdkWalletNetwork({required BdkWallet that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
          return wire.wire__crate__api__wallet__bdk_wallet_network(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_network,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletNetworkConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletNetworkConstMeta =>
      const TaskConstMeta(debugName: "bdk_wallet_network", argNames: ["that"]);

  @override
  BdkPolicy? crateApiWalletBdkWalletPolicies({
    required BdkWallet ptr,
    required KeychainKind keychain,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_keychain_kind(keychain);
          return wire.wire__crate__api__wallet__bdk_wallet_policies(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_bdk_policy,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletPoliciesConstMeta,
        argValues: [ptr, keychain],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletPoliciesConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_policies",
        argNames: ["ptr", "keychain"],
      );

  @override
  bool crateApiWalletBdkWalletSign({
    required BdkWallet ptr,
    required BdkPsbt psbt,
    SignOptions? signOptions,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_psbt(psbt);
          var arg2 = cst_encode_opt_box_autoadd_sign_options(signOptions);
          return wire.wire__crate__api__wallet__bdk_wallet_sign(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletSignConstMeta,
        argValues: [ptr, psbt, signOptions],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletSignConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_sign",
        argNames: ["ptr", "psbt", "signOptions"],
      );

  @override
  Future<void> crateApiWalletBdkWalletSync({
    required BdkWallet ptr,
    required BdkBlockchain blockchain,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
          var arg1 = cst_encode_box_autoadd_bdk_blockchain(blockchain);
          return wire.wire__crate__api__wallet__bdk_wallet_sync(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletBdkWalletSyncConstMeta,
        argValues: [ptr, blockchain],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletBdkWalletSyncConstMeta =>
      const TaskConstMeta(
        debugName: "bdk_wallet_sync",
        argNames: ["ptr", "blockchain"],
      );

  @override
  Future<(BdkPsbt, BdkTransactionDetails)>
  crateApiWalletFinishBumpFeeTxBuilder({
    required String txid,
    required double feeRate,
    BdkAddress? allowShrinking,
    required BdkWallet wallet,
    required bool enableRbf,
    int? nSequence,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(txid);
          var arg1 = cst_encode_f_32(feeRate);
          var arg2 = cst_encode_opt_box_autoadd_bdk_address(allowShrinking);
          var arg3 = cst_encode_box_autoadd_bdk_wallet(wallet);
          var arg4 = cst_encode_bool(enableRbf);
          var arg5 = cst_encode_opt_box_autoadd_u_32(nSequence);
          return wire.wire__crate__api__wallet__finish_bump_fee_tx_builder(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_bdk_psbt_bdk_transaction_details,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletFinishBumpFeeTxBuilderConstMeta,
        argValues: [
          txid,
          feeRate,
          allowShrinking,
          wallet,
          enableRbf,
          nSequence,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletFinishBumpFeeTxBuilderConstMeta =>
      const TaskConstMeta(
        debugName: "finish_bump_fee_tx_builder",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "wallet",
          "enableRbf",
          "nSequence",
        ],
      );

  @override
  Future<Network> crateApiTypesNetworkDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__types__network_default(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_network,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesNetworkDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesNetworkDefaultConstMeta =>
      const TaskConstMeta(debugName: "network_default", argNames: []);

  @override
  Future<SignOptions> crateApiTypesSignOptionsDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__types__sign_options_default(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_sign_options,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTypesSignOptionsDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTypesSignOptionsDefaultConstMeta =>
      const TaskConstMeta(debugName: "sign_options_default", argNames: []);

  @override
  Future<(BdkPsbt, BdkTransactionDetails)> crateApiWalletTxBuilderFinish({
    required BdkWallet wallet,
    required List<ScriptAmount> recipients,
    required List<OutPoint> utxos,
    (OutPoint, Input, BigInt)? foreignUtxo,
    required List<OutPoint> unSpendable,
    required ChangeSpendPolicy changePolicy,
    required bool manuallySelectedOnly,
    double? feeRate,
    BigInt? feeAbsolute,
    required bool drainWallet,
    BdkScriptBuf? drainTo,
    RbfValue? rbf,
    Map<String, Uint32List>? internalPolicyPath,
    Map<String, Uint32List>? externalPolicyPath,
    required List<int> data,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_bdk_wallet(wallet);
          var arg1 = cst_encode_list_script_amount(recipients);
          var arg2 = cst_encode_list_out_point(utxos);
          var arg3 = cst_encode_opt_box_autoadd_record_out_point_input_usize(
            foreignUtxo,
          );
          var arg4 = cst_encode_list_out_point(unSpendable);
          var arg5 = cst_encode_change_spend_policy(changePolicy);
          var arg6 = cst_encode_bool(manuallySelectedOnly);
          var arg7 = cst_encode_opt_box_autoadd_f_32(feeRate);
          var arg8 = cst_encode_opt_box_autoadd_u_64(feeAbsolute);
          var arg9 = cst_encode_bool(drainWallet);
          var arg10 = cst_encode_opt_box_autoadd_bdk_script_buf(drainTo);
          var arg11 = cst_encode_opt_box_autoadd_rbf_value(rbf);
          var arg12 = cst_encode_opt_Map_String_list_prim_u_32_strict_None(
            internalPolicyPath,
          );
          var arg13 = cst_encode_opt_Map_String_list_prim_u_32_strict_None(
            externalPolicyPath,
          );
          var arg14 = cst_encode_list_prim_u_8_loose(data);
          return wire.wire__crate__api__wallet__tx_builder_finish(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13,
            arg14,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_bdk_psbt_bdk_transaction_details,
          decodeErrorData: dco_decode_bdk_error,
        ),
        constMeta: kCrateApiWalletTxBuilderFinishConstMeta,
        argValues: [
          wallet,
          recipients,
          utxos,
          foreignUtxo,
          unSpendable,
          changePolicy,
          manuallySelectedOnly,
          feeRate,
          feeAbsolute,
          drainWallet,
          drainTo,
          rbf,
          internalPolicyPath,
          externalPolicyPath,
          data,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletTxBuilderFinishConstMeta =>
      const TaskConstMeta(
        debugName: "tx_builder_finish",
        argNames: [
          "wallet",
          "recipients",
          "utxos",
          "foreignUtxo",
          "unSpendable",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "internalPolicyPath",
          "externalPolicyPath",
          "data",
        ],
      );

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_Address =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkbitcoinAddress;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_Address =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinAddress;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DerivationPath =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkbitcoinbip32DerivationPath;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DerivationPath =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinbip32DerivationPath;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_AnyBlockchain =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkblockchainAnyBlockchain;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_AnyBlockchain =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkblockchainAnyBlockchain;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ExtendedDescriptor =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkdescriptorExtendedDescriptor;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ExtendedDescriptor =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkdescriptorExtendedDescriptor;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_Policy =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkdescriptorPolicy;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_Policy =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkdescriptorPolicy;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DescriptorPublicKey =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkkeysDescriptorPublicKey;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DescriptorPublicKey =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkkeysDescriptorPublicKey;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DescriptorSecretKey =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkkeysDescriptorSecretKey;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DescriptorSecretKey =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkkeysDescriptorSecretKey;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_KeyMap =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkkeysKeyMap;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_KeyMap =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkkeysKeyMap;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_Mnemonic =>
      wire.rust_arc_increment_strong_count_RustOpaque_bdkkeysbip39Mnemonic;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_Mnemonic =>
      wire.rust_arc_decrement_strong_count_RustOpaque_bdkkeysbip39Mnemonic;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MutexWalletAnyDatabase =>
      wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MutexWalletAnyDatabase =>
      wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MutexPartiallySignedTransaction =>
      wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MutexPartiallySignedTransaction =>
      wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction;

  @protected
  Map<String, Uint32List> dco_decode_Map_String_list_prim_u_32_strict_None(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_list_prim_u_32_strict(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Map<Uint32List, List<Condition>>
  dco_decode_Map_list_prim_u_32_strict_list_condition_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_list_prim_u_32_strict_list_condition(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Map<int, List<Condition>> dco_decode_Map_u_32_list_condition_None(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_u_32_list_condition(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Address dco_decode_RustOpaque_bdkbitcoinAddress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DerivationPath dco_decode_RustOpaque_bdkbitcoinbip32DerivationPath(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DerivationPathImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AnyBlockchain dco_decode_RustOpaque_bdkblockchainAnyBlockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyBlockchainImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedDescriptor dco_decode_RustOpaque_bdkdescriptorExtendedDescriptor(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedDescriptorImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Policy dco_decode_RustOpaque_bdkdescriptorPolicy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PolicyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DescriptorPublicKey dco_decode_RustOpaque_bdkkeysDescriptorPublicKey(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DescriptorPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DescriptorSecretKey dco_decode_RustOpaque_bdkkeysDescriptorSecretKey(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DescriptorSecretKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  KeyMap dco_decode_RustOpaque_bdkkeysKeyMap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeyMapImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Mnemonic dco_decode_RustOpaque_bdkkeysbip39Mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexWalletAnyDatabase
  dco_decode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexWalletAnyDatabaseImpl.frbInternalDcoDecode(
      raw as List<dynamic>,
    );
  }

  @protected
  MutexPartiallySignedTransaction
  dco_decode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexPartiallySignedTransactionImpl.frbInternalDcoDecode(
      raw as List<dynamic>,
    );
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressError dco_decode_address_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressError_Base58(dco_decode_String(raw[1]));
      case 1:
        return AddressError_Bech32(dco_decode_String(raw[1]));
      case 2:
        return AddressError_EmptyBech32Payload();
      case 3:
        return AddressError_InvalidBech32Variant(
          expected: dco_decode_variant(raw[1]),
          found: dco_decode_variant(raw[2]),
        );
      case 4:
        return AddressError_InvalidWitnessVersion(dco_decode_u_8(raw[1]));
      case 5:
        return AddressError_UnparsableWitnessVersion(dco_decode_String(raw[1]));
      case 6:
        return AddressError_MalformedWitnessVersion();
      case 7:
        return AddressError_InvalidWitnessProgramLength(
          dco_decode_usize(raw[1]),
        );
      case 8:
        return AddressError_InvalidSegwitV0ProgramLength(
          dco_decode_usize(raw[1]),
        );
      case 9:
        return AddressError_UncompressedPubkey();
      case 10:
        return AddressError_ExcessiveScriptSize();
      case 11:
        return AddressError_UnrecognizedScript();
      case 12:
        return AddressError_UnknownAddressType(dco_decode_String(raw[1]));
      case 13:
        return AddressError_NetworkValidation(
          networkRequired: dco_decode_network(raw[1]),
          networkFound: dco_decode_network(raw[2]),
          address: dco_decode_String(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressIndex dco_decode_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressIndex_Increase();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        return AddressIndex_Peek(index: dco_decode_u_32(raw[1]));
      case 3:
        return AddressIndex_Reset(index: dco_decode_u_32(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Auth dco_decode_auth(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Auth_None();
      case 1:
        return Auth_UserPass(
          username: dco_decode_String(raw[1]),
          password: dco_decode_String(raw[2]),
        );
      case 2:
        return Auth_Cookie(file: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  BdkAddress dco_decode_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkAddress(ptr: dco_decode_RustOpaque_bdkbitcoinAddress(arr[0]));
  }

  @protected
  BdkBlockchain dco_decode_bdk_blockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkBlockchain(
      ptr: dco_decode_RustOpaque_bdkblockchainAnyBlockchain(arr[0]),
    );
  }

  @protected
  BdkDerivationPath dco_decode_bdk_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDerivationPath(
      ptr: dco_decode_RustOpaque_bdkbitcoinbip32DerivationPath(arr[0]),
    );
  }

  @protected
  BdkDescriptor dco_decode_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BdkDescriptor(
      extendedDescriptor: dco_decode_RustOpaque_bdkdescriptorExtendedDescriptor(
        arr[0],
      ),
      keyMap: dco_decode_RustOpaque_bdkkeysKeyMap(arr[1]),
    );
  }

  @protected
  BdkDescriptorPublicKey dco_decode_bdk_descriptor_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDescriptorPublicKey(
      ptr: dco_decode_RustOpaque_bdkkeysDescriptorPublicKey(arr[0]),
    );
  }

  @protected
  BdkDescriptorSecretKey dco_decode_bdk_descriptor_secret_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDescriptorSecretKey(
      ptr: dco_decode_RustOpaque_bdkkeysDescriptorSecretKey(arr[0]),
    );
  }

  @protected
  BdkError dco_decode_bdk_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BdkError_Hex(dco_decode_box_autoadd_hex_error(raw[1]));
      case 1:
        return BdkError_Consensus(
          dco_decode_box_autoadd_consensus_error(raw[1]),
        );
      case 2:
        return BdkError_VerifyTransaction(dco_decode_String(raw[1]));
      case 3:
        return BdkError_Address(dco_decode_box_autoadd_address_error(raw[1]));
      case 4:
        return BdkError_Descriptor(
          dco_decode_box_autoadd_descriptor_error(raw[1]),
        );
      case 5:
        return BdkError_InvalidU32Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 6:
        return BdkError_Generic(dco_decode_String(raw[1]));
      case 7:
        return BdkError_ScriptDoesntHaveAddressForm();
      case 8:
        return BdkError_NoRecipients();
      case 9:
        return BdkError_NoUtxosSelected();
      case 10:
        return BdkError_OutputBelowDustLimit(dco_decode_usize(raw[1]));
      case 11:
        return BdkError_InsufficientFunds(
          needed: dco_decode_u_64(raw[1]),
          available: dco_decode_u_64(raw[2]),
        );
      case 12:
        return BdkError_BnBTotalTriesExceeded();
      case 13:
        return BdkError_BnBNoExactMatch();
      case 14:
        return BdkError_UnknownUtxo();
      case 15:
        return BdkError_TransactionNotFound();
      case 16:
        return BdkError_TransactionConfirmed();
      case 17:
        return BdkError_IrreplaceableTransaction();
      case 18:
        return BdkError_FeeRateTooLow(needed: dco_decode_f_32(raw[1]));
      case 19:
        return BdkError_FeeTooLow(needed: dco_decode_u_64(raw[1]));
      case 20:
        return BdkError_FeeRateUnavailable();
      case 21:
        return BdkError_MissingKeyOrigin(dco_decode_String(raw[1]));
      case 22:
        return BdkError_Key(dco_decode_String(raw[1]));
      case 23:
        return BdkError_ChecksumMismatch();
      case 24:
        return BdkError_SpendingPolicyRequired(
          dco_decode_keychain_kind(raw[1]),
        );
      case 25:
        return BdkError_InvalidPolicyPathError(dco_decode_String(raw[1]));
      case 26:
        return BdkError_Signer(dco_decode_String(raw[1]));
      case 27:
        return BdkError_InvalidNetwork(
          requested: dco_decode_network(raw[1]),
          found: dco_decode_network(raw[2]),
        );
      case 28:
        return BdkError_InvalidOutpoint(
          dco_decode_box_autoadd_out_point(raw[1]),
        );
      case 29:
        return BdkError_Encode(dco_decode_String(raw[1]));
      case 30:
        return BdkError_Miniscript(dco_decode_String(raw[1]));
      case 31:
        return BdkError_MiniscriptPsbt(dco_decode_String(raw[1]));
      case 32:
        return BdkError_Bip32(dco_decode_String(raw[1]));
      case 33:
        return BdkError_Bip39(dco_decode_String(raw[1]));
      case 34:
        return BdkError_Secp256k1(dco_decode_String(raw[1]));
      case 35:
        return BdkError_Json(dco_decode_String(raw[1]));
      case 36:
        return BdkError_Psbt(dco_decode_String(raw[1]));
      case 37:
        return BdkError_PsbtParse(dco_decode_String(raw[1]));
      case 38:
        return BdkError_MissingCachedScripts(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      case 39:
        return BdkError_Electrum(dco_decode_String(raw[1]));
      case 40:
        return BdkError_Esplora(dco_decode_String(raw[1]));
      case 41:
        return BdkError_Sled(dco_decode_String(raw[1]));
      case 42:
        return BdkError_Rpc(dco_decode_String(raw[1]));
      case 43:
        return BdkError_Rusqlite(dco_decode_String(raw[1]));
      case 44:
        return BdkError_InvalidInput(dco_decode_String(raw[1]));
      case 45:
        return BdkError_InvalidLockTime(dco_decode_String(raw[1]));
      case 46:
        return BdkError_InvalidTransaction(dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BdkMnemonic dco_decode_bdk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkMnemonic(ptr: dco_decode_RustOpaque_bdkkeysbip39Mnemonic(arr[0]));
  }

  @protected
  BdkPolicy dco_decode_bdk_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkPolicy(ptr: dco_decode_RustOpaque_bdkdescriptorPolicy(arr[0]));
  }

  @protected
  BdkPsbt dco_decode_bdk_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkPsbt(
      ptr:
          dco_decode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
            arr[0],
          ),
    );
  }

  @protected
  BdkScriptBuf dco_decode_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkScriptBuf(bytes: dco_decode_list_prim_u_8_strict(arr[0]));
  }

  @protected
  BdkTransaction dco_decode_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkTransaction(s: dco_decode_String(arr[0]));
  }

  @protected
  BdkTransactionDetails dco_decode_bdk_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return BdkTransactionDetails(
      transaction: dco_decode_opt_box_autoadd_bdk_transaction(arr[0]),
      txid: dco_decode_String(arr[1]),
      received: dco_decode_u_64(arr[2]),
      sent: dco_decode_u_64(arr[3]),
      fee: dco_decode_opt_box_autoadd_u_64(arr[4]),
      confirmationTime: dco_decode_opt_box_autoadd_block_time(arr[5]),
    );
  }

  @protected
  BdkTxIn dco_decode_bdk_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return BdkTxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_opt_box_autoadd_bdk_script_buf(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  BdkTxOut dco_decode_bdk_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BdkTxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_bdk_script_buf(arr[1]),
    );
  }

  @protected
  BdkWallet dco_decode_bdk_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkWallet(
      ptr: dco_decode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
        arr[0],
      ),
    );
  }

  @protected
  BlockTime dco_decode_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  BlockchainConfig dco_decode_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BlockchainConfig_Electrum(
          config: dco_decode_box_autoadd_electrum_config(raw[1]),
        );
      case 1:
        return BlockchainConfig_Esplora(
          config: dco_decode_box_autoadd_esplora_config(raw[1]),
        );
      case 2:
        return BlockchainConfig_Rpc(
          config: dco_decode_box_autoadd_rpc_config(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddressError dco_decode_box_autoadd_address_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_error(raw);
  }

  @protected
  AddressIndex dco_decode_box_autoadd_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_index(raw);
  }

  @protected
  BdkAddress dco_decode_box_autoadd_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_address(raw);
  }

  @protected
  BdkBlockchain dco_decode_box_autoadd_bdk_blockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_blockchain(raw);
  }

  @protected
  BdkDerivationPath dco_decode_box_autoadd_bdk_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_derivation_path(raw);
  }

  @protected
  BdkDescriptor dco_decode_box_autoadd_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor(raw);
  }

  @protected
  BdkDescriptorPublicKey dco_decode_box_autoadd_bdk_descriptor_public_key(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor_public_key(raw);
  }

  @protected
  BdkDescriptorSecretKey dco_decode_box_autoadd_bdk_descriptor_secret_key(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor_secret_key(raw);
  }

  @protected
  BdkMnemonic dco_decode_box_autoadd_bdk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_mnemonic(raw);
  }

  @protected
  BdkPolicy dco_decode_box_autoadd_bdk_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_policy(raw);
  }

  @protected
  BdkPsbt dco_decode_box_autoadd_bdk_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_psbt(raw);
  }

  @protected
  BdkScriptBuf dco_decode_box_autoadd_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_script_buf(raw);
  }

  @protected
  BdkTransaction dco_decode_box_autoadd_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_transaction(raw);
  }

  @protected
  BdkWallet dco_decode_box_autoadd_bdk_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_wallet(raw);
  }

  @protected
  BlockTime dco_decode_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_time(raw);
  }

  @protected
  BlockchainConfig dco_decode_box_autoadd_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_blockchain_config(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Condition dco_decode_box_autoadd_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_condition(raw);
  }

  @protected
  ConsensusError dco_decode_box_autoadd_consensus_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_consensus_error(raw);
  }

  @protected
  DatabaseConfig dco_decode_box_autoadd_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_database_config(raw);
  }

  @protected
  DescriptorError dco_decode_box_autoadd_descriptor_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_descriptor_error(raw);
  }

  @protected
  ElectrumConfig dco_decode_box_autoadd_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_electrum_config(raw);
  }

  @protected
  EsploraConfig dco_decode_box_autoadd_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_config(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FeeRate dco_decode_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fee_rate(raw);
  }

  @protected
  HexError dco_decode_box_autoadd_hex_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_hex_error(raw);
  }

  @protected
  LocalUtxo dco_decode_box_autoadd_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_local_utxo(raw);
  }

  @protected
  LockTime dco_decode_box_autoadd_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lock_time(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PkOrF dco_decode_box_autoadd_pk_or_f(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pk_or_f(raw);
  }

  @protected
  PsbtSigHashType dco_decode_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  (OutPoint, Input, BigInt) dco_decode_box_autoadd_record_out_point_input_usize(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (OutPoint, Input, BigInt);
  }

  @protected
  RpcConfig dco_decode_box_autoadd_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_config(raw);
  }

  @protected
  RpcSyncParams dco_decode_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_sync_params(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  SledDbConfiguration dco_decode_box_autoadd_sled_db_configuration(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sled_db_configuration(raw);
  }

  @protected
  SqliteDbConfiguration dco_decode_box_autoadd_sqlite_db_configuration(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sqlite_db_configuration(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  Condition dco_decode_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Condition(
      csv: dco_decode_opt_box_autoadd_u_32(arr[0]),
      timelock: dco_decode_opt_box_autoadd_lock_time(arr[1]),
    );
  }

  @protected
  ConsensusError dco_decode_consensus_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ConsensusError_Io(dco_decode_String(raw[1]));
      case 1:
        return ConsensusError_OversizedVectorAllocation(
          requested: dco_decode_usize(raw[1]),
          max: dco_decode_usize(raw[2]),
        );
      case 2:
        return ConsensusError_InvalidChecksum(
          expected: dco_decode_u_8_array_4(raw[1]),
          actual: dco_decode_u_8_array_4(raw[2]),
        );
      case 3:
        return ConsensusError_NonMinimalVarInt();
      case 4:
        return ConsensusError_ParseFailed(dco_decode_String(raw[1]));
      case 5:
        return ConsensusError_UnsupportedSegwitFlag(dco_decode_u_8(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DatabaseConfig dco_decode_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        return DatabaseConfig_Sqlite(
          config: dco_decode_box_autoadd_sqlite_db_configuration(raw[1]),
        );
      case 2:
        return DatabaseConfig_Sled(
          config: dco_decode_box_autoadd_sled_db_configuration(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DescriptorError dco_decode_descriptor_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_InvalidDescriptorChecksum();
      case 2:
        return DescriptorError_HardenedDerivationXpub();
      case 3:
        return DescriptorError_MultiPath();
      case 4:
        return DescriptorError_Key(dco_decode_String(raw[1]));
      case 5:
        return DescriptorError_Policy(dco_decode_String(raw[1]));
      case 6:
        return DescriptorError_InvalidDescriptorCharacter(
          dco_decode_u_8(raw[1]),
        );
      case 7:
        return DescriptorError_Bip32(dco_decode_String(raw[1]));
      case 8:
        return DescriptorError_Base58(dco_decode_String(raw[1]));
      case 9:
        return DescriptorError_Pk(dco_decode_String(raw[1]));
      case 10:
        return DescriptorError_Miniscript(dco_decode_String(raw[1]));
      case 11:
        return DescriptorError_Hex(dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ElectrumConfig dco_decode_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ElectrumConfig(
      url: dco_decode_String(arr[0]),
      socks5: dco_decode_opt_String(arr[1]),
      retry: dco_decode_u_8(arr[2]),
      timeout: dco_decode_opt_box_autoadd_u_8(arr[3]),
      stopGap: dco_decode_u_64(arr[4]),
      validateDomain: dco_decode_bool(arr[5]),
    );
  }

  @protected
  EsploraConfig dco_decode_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return EsploraConfig(
      baseUrl: dco_decode_String(arr[0]),
      proxy: dco_decode_opt_String(arr[1]),
      concurrency: dco_decode_opt_box_autoadd_u_8(arr[2]),
      stopGap: dco_decode_u_64(arr[3]),
      timeout: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FeeRate dco_decode_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FeeRate(satPerVb: dco_decode_f_32(arr[0]));
  }

  @protected
  HexError dco_decode_hex_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return HexError_InvalidChar(dco_decode_u_8(raw[1]));
      case 1:
        return HexError_OddLengthString(dco_decode_usize(raw[1]));
      case 2:
        return HexError_InvalidLength(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Input dco_decode_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Input(s: dco_decode_String(arr[0]));
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  List<BdkPolicy> dco_decode_list_bdk_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bdk_policy).toList();
  }

  @protected
  List<BdkTransactionDetails> dco_decode_list_bdk_transaction_details(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_bdk_transaction_details)
        .toList();
  }

  @protected
  List<BdkTxIn> dco_decode_list_bdk_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bdk_tx_in).toList();
  }

  @protected
  List<BdkTxOut> dco_decode_list_bdk_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bdk_tx_out).toList();
  }

  @protected
  List<Condition> dco_decode_list_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_condition).toList();
  }

  @protected
  List<Uint8List> dco_decode_list_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_prim_u_8_strict).toList();
  }

  @protected
  List<LocalUtxo> dco_decode_list_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_utxo).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<PkOrF> dco_decode_list_pk_or_f(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_pk_or_f).toList();
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  Uint64List dco_decode_list_prim_u_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeUint64List(raw);
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(Uint32List, List<Condition>)>
  dco_decode_list_record_list_prim_u_32_strict_list_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_list_prim_u_32_strict_list_condition)
        .toList();
  }

  @protected
  List<(String, Uint32List)>
  dco_decode_list_record_string_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_list_prim_u_32_strict)
        .toList();
  }

  @protected
  List<(int, List<Condition>)> dco_decode_list_record_u_32_list_condition(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_u_32_list_condition)
        .toList();
  }

  @protected
  List<ScriptAmount> dco_decode_list_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_script_amount).toList();
  }

  @protected
  LocalUtxo dco_decode_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_bdk_tx_out(arr[1]),
      keychain: dco_decode_keychain_kind(arr[2]),
      isSpent: dco_decode_bool(arr[3]),
    );
  }

  @protected
  LockTime dco_decode_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LockTime_Blocks(dco_decode_u_32(raw[1]));
      case 1:
        return LockTime_Seconds(dco_decode_u_32(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  Map<String, Uint32List>? dco_decode_opt_Map_String_list_prim_u_32_strict_None(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_Map_String_list_prim_u_32_strict_None(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BdkAddress? dco_decode_opt_box_autoadd_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_address(raw);
  }

  @protected
  BdkDescriptor? dco_decode_opt_box_autoadd_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_descriptor(raw);
  }

  @protected
  BdkPolicy? dco_decode_opt_box_autoadd_bdk_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_policy(raw);
  }

  @protected
  BdkScriptBuf? dco_decode_opt_box_autoadd_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_script_buf(raw);
  }

  @protected
  BdkTransaction? dco_decode_opt_box_autoadd_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_transaction(raw);
  }

  @protected
  BlockTime? dco_decode_opt_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_time(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  FeeRate? dco_decode_opt_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_fee_rate(raw);
  }

  @protected
  LockTime? dco_decode_opt_box_autoadd_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_lock_time(raw);
  }

  @protected
  PsbtSigHashType? dco_decode_opt_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  (OutPoint, Input, BigInt)?
  dco_decode_opt_box_autoadd_record_out_point_input_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_out_point_input_usize(raw);
  }

  @protected
  RpcSyncParams? dco_decode_opt_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_sync_params(raw);
  }

  @protected
  SignOptions? dco_decode_opt_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sign_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Payload dco_decode_payload(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Payload_PubkeyHash(pubkeyHash: dco_decode_String(raw[1]));
      case 1:
        return Payload_ScriptHash(scriptHash: dco_decode_String(raw[1]));
      case 2:
        return Payload_WitnessProgram(
          version: dco_decode_witness_version(raw[1]),
          program: dco_decode_list_prim_u_8_strict(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PkOrF dco_decode_pk_or_f(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PkOrF_Pubkey(value: dco_decode_String(raw[1]));
      case 1:
        return PkOrF_XOnlyPubkey(value: dco_decode_String(raw[1]));
      case 2:
        return PkOrF_Fingerprint(value: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PsbtSigHashType dco_decode_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PsbtSigHashType(inner: dco_decode_u_32(arr[0]));
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(dco_decode_u_32(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (BdkAddress, int) dco_decode_record_bdk_address_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_bdk_address(arr[0]), dco_decode_u_32(arr[1]));
  }

  @protected
  (BdkPsbt, BdkTransactionDetails)
  dco_decode_record_bdk_psbt_bdk_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_bdk_psbt(arr[0]),
      dco_decode_bdk_transaction_details(arr[1]),
    );
  }

  @protected
  (Uint32List, List<Condition>)
  dco_decode_record_list_prim_u_32_strict_list_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_list_prim_u_32_strict(arr[0]),
      dco_decode_list_condition(arr[1]),
    );
  }

  @protected
  (OutPoint, Input, BigInt) dco_decode_record_out_point_input_usize(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_out_point(arr[0]),
      dco_decode_input(arr[1]),
      dco_decode_usize(arr[2]),
    );
  }

  @protected
  (String, Uint32List) dco_decode_record_string_list_prim_u_32_strict(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_list_prim_u_32_strict(arr[1]),
    );
  }

  @protected
  (int, List<Condition>) dco_decode_record_u_32_list_condition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_u_32(arr[0]), dco_decode_list_condition(arr[1]));
  }

  @protected
  RpcConfig dco_decode_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RpcConfig(
      url: dco_decode_String(arr[0]),
      auth: dco_decode_auth(arr[1]),
      network: dco_decode_network(arr[2]),
      walletName: dco_decode_String(arr[3]),
      syncParams: dco_decode_opt_box_autoadd_rpc_sync_params(arr[4]),
    );
  }

  @protected
  RpcSyncParams dco_decode_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RpcSyncParams(
      startScriptCount: dco_decode_u_64(arr[0]),
      startTime: dco_decode_u_64(arr[1]),
      forceStartTime: dco_decode_bool(arr[2]),
      pollRateSec: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  Satisfaction dco_decode_satisfaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Satisfaction_Partial(
          n: dco_decode_u_64(raw[1]),
          m: dco_decode_u_64(raw[2]),
          items: dco_decode_list_prim_u_64_strict(raw[3]),
          sorted: dco_decode_opt_box_autoadd_bool(raw[4]),
          conditions: dco_decode_Map_u_32_list_condition_None(raw[5]),
        );
      case 1:
        return Satisfaction_PartialComplete(
          n: dco_decode_u_64(raw[1]),
          m: dco_decode_u_64(raw[2]),
          items: dco_decode_list_prim_u_64_strict(raw[3]),
          sorted: dco_decode_opt_box_autoadd_bool(raw[4]),
          conditions: dco_decode_Map_list_prim_u_32_strict_list_condition_None(
            raw[5],
          ),
        );
      case 2:
        return Satisfaction_Complete(
          condition: dco_decode_box_autoadd_condition(raw[1]),
        );
      case 3:
        return Satisfaction_None(msg: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SatisfiableItem dco_decode_satisfiable_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SatisfiableItem_EcdsaSignature(
          key: dco_decode_box_autoadd_pk_or_f(raw[1]),
        );
      case 1:
        return SatisfiableItem_SchnorrSignature(
          key: dco_decode_box_autoadd_pk_or_f(raw[1]),
        );
      case 2:
        return SatisfiableItem_Sha256Preimage(hash: dco_decode_String(raw[1]));
      case 3:
        return SatisfiableItem_Hash256Preimage(hash: dco_decode_String(raw[1]));
      case 4:
        return SatisfiableItem_Ripemd160Preimage(
          hash: dco_decode_String(raw[1]),
        );
      case 5:
        return SatisfiableItem_Hash160Preimage(hash: dco_decode_String(raw[1]));
      case 6:
        return SatisfiableItem_AbsoluteTimelock(
          value: dco_decode_box_autoadd_lock_time(raw[1]),
        );
      case 7:
        return SatisfiableItem_RelativeTimelock(value: dco_decode_u_32(raw[1]));
      case 8:
        return SatisfiableItem_Multisig(
          keys: dco_decode_list_pk_or_f(raw[1]),
          threshold: dco_decode_u_64(raw[2]),
        );
      case 9:
        return SatisfiableItem_Thresh(
          items: dco_decode_list_bdk_policy(raw[1]),
          threshold: dco_decode_u_64(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ScriptAmount dco_decode_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScriptAmount(
      script: dco_decode_bdk_script_buf(arr[0]),
      amount: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return SignOptions(
      trustWitnessUtxo: dco_decode_bool(arr[0]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[1]),
      allowAllSighashes: dco_decode_bool(arr[2]),
      removePartialSigs: dco_decode_bool(arr[3]),
      tryFinalize: dco_decode_bool(arr[4]),
      signWithTapInternalKey: dco_decode_bool(arr[5]),
      allowGrinding: dco_decode_bool(arr[6]),
    );
  }

  @protected
  SledDbConfiguration dco_decode_sled_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SledDbConfiguration(
      path: dco_decode_String(arr[0]),
      treeName: dco_decode_String(arr[1]),
    );
  }

  @protected
  SqliteDbConfiguration dco_decode_sqlite_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SqliteDbConfiguration(path: dco_decode_String(arr[0]));
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  Variant dco_decode_variant(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Variant.values[raw as int];
  }

  @protected
  WitnessVersion dco_decode_witness_version(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WitnessVersion.values[raw as int];
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  Map<String, Uint32List> sse_decode_Map_String_list_prim_u_32_strict_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_list_prim_u_32_strict(
      deserializer,
    );
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<Uint32List, List<Condition>>
  sse_decode_Map_list_prim_u_32_strict_list_condition_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_list_prim_u_32_strict_list_condition(
      deserializer,
    );
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<int, List<Condition>> sse_decode_Map_u_32_list_condition_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_u_32_list_condition(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Address sse_decode_RustOpaque_bdkbitcoinAddress(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  DerivationPath sse_decode_RustOpaque_bdkbitcoinbip32DerivationPath(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DerivationPathImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  AnyBlockchain sse_decode_RustOpaque_bdkblockchainAnyBlockchain(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnyBlockchainImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  ExtendedDescriptor sse_decode_RustOpaque_bdkdescriptorExtendedDescriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedDescriptorImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Policy sse_decode_RustOpaque_bdkdescriptorPolicy(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PolicyImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  DescriptorPublicKey sse_decode_RustOpaque_bdkkeysDescriptorPublicKey(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DescriptorPublicKeyImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  DescriptorSecretKey sse_decode_RustOpaque_bdkkeysDescriptorSecretKey(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DescriptorSecretKeyImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  KeyMap sse_decode_RustOpaque_bdkkeysKeyMap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeyMapImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Mnemonic sse_decode_RustOpaque_bdkkeysbip39Mnemonic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MnemonicImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  MutexWalletAnyDatabase
  sse_decode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexWalletAnyDatabaseImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  MutexPartiallySignedTransaction
  sse_decode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexPartiallySignedTransactionImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressError sse_decode_address_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_Base58(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_Bech32(var_field0);
      case 2:
        return AddressError_EmptyBech32Payload();
      case 3:
        var var_expected = sse_decode_variant(deserializer);
        var var_found = sse_decode_variant(deserializer);
        return AddressError_InvalidBech32Variant(
          expected: var_expected,
          found: var_found,
        );
      case 4:
        var var_field0 = sse_decode_u_8(deserializer);
        return AddressError_InvalidWitnessVersion(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_UnparsableWitnessVersion(var_field0);
      case 6:
        return AddressError_MalformedWitnessVersion();
      case 7:
        var var_field0 = sse_decode_usize(deserializer);
        return AddressError_InvalidWitnessProgramLength(var_field0);
      case 8:
        var var_field0 = sse_decode_usize(deserializer);
        return AddressError_InvalidSegwitV0ProgramLength(var_field0);
      case 9:
        return AddressError_UncompressedPubkey();
      case 10:
        return AddressError_ExcessiveScriptSize();
      case 11:
        return AddressError_UnrecognizedScript();
      case 12:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_UnknownAddressType(var_field0);
      case 13:
        var var_networkRequired = sse_decode_network(deserializer);
        var var_networkFound = sse_decode_network(deserializer);
        var var_address = sse_decode_String(deserializer);
        return AddressError_NetworkValidation(
          networkRequired: var_networkRequired,
          networkFound: var_networkFound,
          address: var_address,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressIndex sse_decode_address_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressIndex_Increase();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Peek(index: var_index);
      case 3:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Reset(index: var_index);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Auth sse_decode_auth(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Auth_None();
      case 1:
        var var_username = sse_decode_String(deserializer);
        var var_password = sse_decode_String(deserializer);
        return Auth_UserPass(username: var_username, password: var_password);
      case 2:
        var var_file = sse_decode_String(deserializer);
        return Auth_Cookie(file: var_file);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
      immature: var_immature,
      trustedPending: var_trustedPending,
      untrustedPending: var_untrustedPending,
      confirmed: var_confirmed,
      spendable: var_spendable,
      total: var_total,
    );
  }

  @protected
  BdkAddress sse_decode_bdk_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkbitcoinAddress(deserializer);
    return BdkAddress(ptr: var_ptr);
  }

  @protected
  BdkBlockchain sse_decode_bdk_blockchain(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkblockchainAnyBlockchain(
      deserializer,
    );
    return BdkBlockchain(ptr: var_ptr);
  }

  @protected
  BdkDerivationPath sse_decode_bdk_derivation_path(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkbitcoinbip32DerivationPath(
      deserializer,
    );
    return BdkDerivationPath(ptr: var_ptr);
  }

  @protected
  BdkDescriptor sse_decode_bdk_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_extendedDescriptor =
        sse_decode_RustOpaque_bdkdescriptorExtendedDescriptor(deserializer);
    var var_keyMap = sse_decode_RustOpaque_bdkkeysKeyMap(deserializer);
    return BdkDescriptor(
      extendedDescriptor: var_extendedDescriptor,
      keyMap: var_keyMap,
    );
  }

  @protected
  BdkDescriptorPublicKey sse_decode_bdk_descriptor_public_key(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkkeysDescriptorPublicKey(
      deserializer,
    );
    return BdkDescriptorPublicKey(ptr: var_ptr);
  }

  @protected
  BdkDescriptorSecretKey sse_decode_bdk_descriptor_secret_key(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkkeysDescriptorSecretKey(
      deserializer,
    );
    return BdkDescriptorSecretKey(ptr: var_ptr);
  }

  @protected
  BdkError sse_decode_bdk_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_hex_error(deserializer);
        return BdkError_Hex(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_consensus_error(deserializer);
        return BdkError_Consensus(var_field0);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_VerifyTransaction(var_field0);
      case 3:
        var var_field0 = sse_decode_box_autoadd_address_error(deserializer);
        return BdkError_Address(var_field0);
      case 4:
        var var_field0 = sse_decode_box_autoadd_descriptor_error(deserializer);
        return BdkError_Descriptor(var_field0);
      case 5:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return BdkError_InvalidU32Bytes(var_field0);
      case 6:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Generic(var_field0);
      case 7:
        return BdkError_ScriptDoesntHaveAddressForm();
      case 8:
        return BdkError_NoRecipients();
      case 9:
        return BdkError_NoUtxosSelected();
      case 10:
        var var_field0 = sse_decode_usize(deserializer);
        return BdkError_OutputBelowDustLimit(var_field0);
      case 11:
        var var_needed = sse_decode_u_64(deserializer);
        var var_available = sse_decode_u_64(deserializer);
        return BdkError_InsufficientFunds(
          needed: var_needed,
          available: var_available,
        );
      case 12:
        return BdkError_BnBTotalTriesExceeded();
      case 13:
        return BdkError_BnBNoExactMatch();
      case 14:
        return BdkError_UnknownUtxo();
      case 15:
        return BdkError_TransactionNotFound();
      case 16:
        return BdkError_TransactionConfirmed();
      case 17:
        return BdkError_IrreplaceableTransaction();
      case 18:
        var var_needed = sse_decode_f_32(deserializer);
        return BdkError_FeeRateTooLow(needed: var_needed);
      case 19:
        var var_needed = sse_decode_u_64(deserializer);
        return BdkError_FeeTooLow(needed: var_needed);
      case 20:
        return BdkError_FeeRateUnavailable();
      case 21:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_MissingKeyOrigin(var_field0);
      case 22:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Key(var_field0);
      case 23:
        return BdkError_ChecksumMismatch();
      case 24:
        var var_field0 = sse_decode_keychain_kind(deserializer);
        return BdkError_SpendingPolicyRequired(var_field0);
      case 25:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidPolicyPathError(var_field0);
      case 26:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Signer(var_field0);
      case 27:
        var var_requested = sse_decode_network(deserializer);
        var var_found = sse_decode_network(deserializer);
        return BdkError_InvalidNetwork(
          requested: var_requested,
          found: var_found,
        );
      case 28:
        var var_field0 = sse_decode_box_autoadd_out_point(deserializer);
        return BdkError_InvalidOutpoint(var_field0);
      case 29:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Encode(var_field0);
      case 30:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Miniscript(var_field0);
      case 31:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_MiniscriptPsbt(var_field0);
      case 32:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Bip32(var_field0);
      case 33:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Bip39(var_field0);
      case 34:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Secp256k1(var_field0);
      case 35:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Json(var_field0);
      case 36:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Psbt(var_field0);
      case 37:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_PsbtParse(var_field0);
      case 38:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return BdkError_MissingCachedScripts(var_field0, var_field1);
      case 39:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Electrum(var_field0);
      case 40:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Esplora(var_field0);
      case 41:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Sled(var_field0);
      case 42:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Rpc(var_field0);
      case 43:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Rusqlite(var_field0);
      case 44:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidInput(var_field0);
      case 45:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidLockTime(var_field0);
      case 46:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidTransaction(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BdkMnemonic sse_decode_bdk_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkkeysbip39Mnemonic(deserializer);
    return BdkMnemonic(ptr: var_ptr);
  }

  @protected
  BdkPolicy sse_decode_bdk_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkdescriptorPolicy(deserializer);
    return BdkPolicy(ptr: var_ptr);
  }

  @protected
  BdkPsbt sse_decode_bdk_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
          deserializer,
        );
    return BdkPsbt(ptr: var_ptr);
  }

  @protected
  BdkScriptBuf sse_decode_bdk_script_buf(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bytes = sse_decode_list_prim_u_8_strict(deserializer);
    return BdkScriptBuf(bytes: var_bytes);
  }

  @protected
  BdkTransaction sse_decode_bdk_transaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return BdkTransaction(s: var_s);
  }

  @protected
  BdkTransactionDetails sse_decode_bdk_transaction_details(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transaction = sse_decode_opt_box_autoadd_bdk_transaction(
      deserializer,
    );
    var var_txid = sse_decode_String(deserializer);
    var var_received = sse_decode_u_64(deserializer);
    var var_sent = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_confirmationTime = sse_decode_opt_box_autoadd_block_time(
      deserializer,
    );
    return BdkTransactionDetails(
      transaction: var_transaction,
      txid: var_txid,
      received: var_received,
      sent: var_sent,
      fee: var_fee,
      confirmationTime: var_confirmationTime,
    );
  }

  @protected
  BdkTxIn sse_decode_bdk_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_opt_box_autoadd_bdk_script_buf(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_list_prim_u_8_strict(deserializer);
    return BdkTxIn(
      previousOutput: var_previousOutput,
      scriptSig: var_scriptSig,
      sequence: var_sequence,
      witness: var_witness,
    );
  }

  @protected
  BdkTxOut sse_decode_bdk_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_bdk_script_buf(deserializer);
    return BdkTxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  BdkWallet sse_decode_bdk_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
          deserializer,
        );
    return BdkWallet(ptr: var_ptr);
  }

  @protected
  BlockTime sse_decode_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    return BlockTime(height: var_height, timestamp: var_timestamp);
  }

  @protected
  BlockchainConfig sse_decode_blockchain_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_config = sse_decode_box_autoadd_electrum_config(deserializer);
        return BlockchainConfig_Electrum(config: var_config);
      case 1:
        var var_config = sse_decode_box_autoadd_esplora_config(deserializer);
        return BlockchainConfig_Esplora(config: var_config);
      case 2:
        var var_config = sse_decode_box_autoadd_rpc_config(deserializer);
        return BlockchainConfig_Rpc(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddressError sse_decode_box_autoadd_address_error(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_error(deserializer));
  }

  @protected
  AddressIndex sse_decode_box_autoadd_address_index(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_index(deserializer));
  }

  @protected
  BdkAddress sse_decode_box_autoadd_bdk_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_address(deserializer));
  }

  @protected
  BdkBlockchain sse_decode_box_autoadd_bdk_blockchain(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_blockchain(deserializer));
  }

  @protected
  BdkDerivationPath sse_decode_box_autoadd_bdk_derivation_path(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_derivation_path(deserializer));
  }

  @protected
  BdkDescriptor sse_decode_box_autoadd_bdk_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor(deserializer));
  }

  @protected
  BdkDescriptorPublicKey sse_decode_box_autoadd_bdk_descriptor_public_key(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor_public_key(deserializer));
  }

  @protected
  BdkDescriptorSecretKey sse_decode_box_autoadd_bdk_descriptor_secret_key(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor_secret_key(deserializer));
  }

  @protected
  BdkMnemonic sse_decode_box_autoadd_bdk_mnemonic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_mnemonic(deserializer));
  }

  @protected
  BdkPolicy sse_decode_box_autoadd_bdk_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_policy(deserializer));
  }

  @protected
  BdkPsbt sse_decode_box_autoadd_bdk_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_psbt(deserializer));
  }

  @protected
  BdkScriptBuf sse_decode_box_autoadd_bdk_script_buf(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_script_buf(deserializer));
  }

  @protected
  BdkTransaction sse_decode_box_autoadd_bdk_transaction(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_transaction(deserializer));
  }

  @protected
  BdkWallet sse_decode_box_autoadd_bdk_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_wallet(deserializer));
  }

  @protected
  BlockTime sse_decode_box_autoadd_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_time(deserializer));
  }

  @protected
  BlockchainConfig sse_decode_box_autoadd_blockchain_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_blockchain_config(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  Condition sse_decode_box_autoadd_condition(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_condition(deserializer));
  }

  @protected
  ConsensusError sse_decode_box_autoadd_consensus_error(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_consensus_error(deserializer));
  }

  @protected
  DatabaseConfig sse_decode_box_autoadd_database_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_database_config(deserializer));
  }

  @protected
  DescriptorError sse_decode_box_autoadd_descriptor_error(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_descriptor_error(deserializer));
  }

  @protected
  ElectrumConfig sse_decode_box_autoadd_electrum_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_electrum_config(deserializer));
  }

  @protected
  EsploraConfig sse_decode_box_autoadd_esplora_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_config(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  FeeRate sse_decode_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fee_rate(deserializer));
  }

  @protected
  HexError sse_decode_box_autoadd_hex_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_hex_error(deserializer));
  }

  @protected
  LocalUtxo sse_decode_box_autoadd_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_local_utxo(deserializer));
  }

  @protected
  LockTime sse_decode_box_autoadd_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lock_time(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PkOrF sse_decode_box_autoadd_pk_or_f(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pk_or_f(deserializer));
  }

  @protected
  PsbtSigHashType sse_decode_box_autoadd_psbt_sig_hash_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_psbt_sig_hash_type(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  (OutPoint, Input, BigInt) sse_decode_box_autoadd_record_out_point_input_usize(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_out_point_input_usize(deserializer));
  }

  @protected
  RpcConfig sse_decode_box_autoadd_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_config(deserializer));
  }

  @protected
  RpcSyncParams sse_decode_box_autoadd_rpc_sync_params(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_sync_params(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  SledDbConfiguration sse_decode_box_autoadd_sled_db_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sled_db_configuration(deserializer));
  }

  @protected
  SqliteDbConfiguration sse_decode_box_autoadd_sqlite_db_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sqlite_db_configuration(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  Condition sse_decode_condition(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_csv = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_timelock = sse_decode_opt_box_autoadd_lock_time(deserializer);
    return Condition(csv: var_csv, timelock: var_timelock);
  }

  @protected
  ConsensusError sse_decode_consensus_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ConsensusError_Io(var_field0);
      case 1:
        var var_requested = sse_decode_usize(deserializer);
        var var_max = sse_decode_usize(deserializer);
        return ConsensusError_OversizedVectorAllocation(
          requested: var_requested,
          max: var_max,
        );
      case 2:
        var var_expected = sse_decode_u_8_array_4(deserializer);
        var var_actual = sse_decode_u_8_array_4(deserializer);
        return ConsensusError_InvalidChecksum(
          expected: var_expected,
          actual: var_actual,
        );
      case 3:
        return ConsensusError_NonMinimalVarInt();
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return ConsensusError_ParseFailed(var_field0);
      case 5:
        var var_field0 = sse_decode_u_8(deserializer);
        return ConsensusError_UnsupportedSegwitFlag(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DatabaseConfig sse_decode_database_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        var var_config = sse_decode_box_autoadd_sqlite_db_configuration(
          deserializer,
        );
        return DatabaseConfig_Sqlite(config: var_config);
      case 2:
        var var_config = sse_decode_box_autoadd_sled_db_configuration(
          deserializer,
        );
        return DatabaseConfig_Sled(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DescriptorError sse_decode_descriptor_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_InvalidDescriptorChecksum();
      case 2:
        return DescriptorError_HardenedDerivationXpub();
      case 3:
        return DescriptorError_MultiPath();
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Key(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Policy(var_field0);
      case 6:
        var var_field0 = sse_decode_u_8(deserializer);
        return DescriptorError_InvalidDescriptorCharacter(var_field0);
      case 7:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Bip32(var_field0);
      case 8:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Base58(var_field0);
      case 9:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Pk(var_field0);
      case 10:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Miniscript(var_field0);
      case 11:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Hex(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ElectrumConfig sse_decode_electrum_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_socks5 = sse_decode_opt_String(deserializer);
    var var_retry = sse_decode_u_8(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_validateDomain = sse_decode_bool(deserializer);
    return ElectrumConfig(
      url: var_url,
      socks5: var_socks5,
      retry: var_retry,
      timeout: var_timeout,
      stopGap: var_stopGap,
      validateDomain: var_validateDomain,
    );
  }

  @protected
  EsploraConfig sse_decode_esplora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_proxy = sse_decode_opt_String(deserializer);
    var var_concurrency = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_64(deserializer);
    return EsploraConfig(
      baseUrl: var_baseUrl,
      proxy: var_proxy,
      concurrency: var_concurrency,
      stopGap: var_stopGap,
      timeout: var_timeout,
    );
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  FeeRate sse_decode_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_satPerVb = sse_decode_f_32(deserializer);
    return FeeRate(satPerVb: var_satPerVb);
  }

  @protected
  HexError sse_decode_hex_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_8(deserializer);
        return HexError_InvalidChar(var_field0);
      case 1:
        var var_field0 = sse_decode_usize(deserializer);
        return HexError_OddLengthString(var_field0);
      case 2:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return HexError_InvalidLength(var_field0, var_field1);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  Input sse_decode_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Input(s: var_s);
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  List<BdkPolicy> sse_decode_list_bdk_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BdkPolicy>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bdk_policy(deserializer));
    }
    return ans_;
  }

  @protected
  List<BdkTransactionDetails> sse_decode_list_bdk_transaction_details(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BdkTransactionDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bdk_transaction_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<BdkTxIn> sse_decode_list_bdk_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BdkTxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bdk_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<BdkTxOut> sse_decode_list_bdk_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BdkTxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bdk_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  List<Condition> sse_decode_list_condition(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Condition>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_condition(deserializer));
    }
    return ans_;
  }

  @protected
  List<Uint8List> sse_decode_list_list_prim_u_8_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Uint8List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_u_8_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalUtxo> sse_decode_list_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<PkOrF> sse_decode_list_pk_or_f(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PkOrF>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pk_or_f(deserializer));
    }
    return ans_;
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(Uint32List, List<Condition>)>
  sse_decode_list_record_list_prim_u_32_strict_list_condition(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(Uint32List, List<Condition>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_record_list_prim_u_32_strict_list_condition(deserializer),
      );
    }
    return ans_;
  }

  @protected
  List<(String, Uint32List)>
  sse_decode_list_record_string_list_prim_u_32_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, Uint32List)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_list_prim_u_32_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<(int, List<Condition>)> sse_decode_list_record_u_32_list_condition(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(int, List<Condition>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_u_32_list_condition(deserializer));
    }
    return ans_;
  }

  @protected
  List<ScriptAmount> sse_decode_list_script_amount(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScriptAmount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_script_amount(deserializer));
    }
    return ans_;
  }

  @protected
  LocalUtxo sse_decode_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_bdk_tx_out(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    return LocalUtxo(
      outpoint: var_outpoint,
      txout: var_txout,
      keychain: var_keychain,
      isSpent: var_isSpent,
    );
  }

  @protected
  LockTime sse_decode_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Blocks(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Seconds(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  Map<String, Uint32List>? sse_decode_opt_Map_String_list_prim_u_32_strict_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Map_String_list_prim_u_32_strict_None(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkAddress? sse_decode_opt_box_autoadd_bdk_address(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkDescriptor? sse_decode_opt_box_autoadd_bdk_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_descriptor(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkPolicy? sse_decode_opt_box_autoadd_bdk_policy(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_policy(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkScriptBuf? sse_decode_opt_box_autoadd_bdk_script_buf(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_script_buf(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkTransaction? sse_decode_opt_box_autoadd_bdk_transaction(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_transaction(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockTime? sse_decode_opt_box_autoadd_block_time(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FeeRate? sse_decode_opt_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fee_rate(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LockTime? sse_decode_opt_box_autoadd_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_lock_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsbtSigHashType? sse_decode_opt_box_autoadd_psbt_sig_hash_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_psbt_sig_hash_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (OutPoint, Input, BigInt)?
  sse_decode_opt_box_autoadd_record_out_point_input_usize(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_out_point_input_usize(
        deserializer,
      ));
    } else {
      return null;
    }
  }

  @protected
  RpcSyncParams? sse_decode_opt_box_autoadd_rpc_sync_params(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_sync_params(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SignOptions? sse_decode_opt_box_autoadd_sign_options(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sign_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  Payload sse_decode_payload(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_pubkeyHash = sse_decode_String(deserializer);
        return Payload_PubkeyHash(pubkeyHash: var_pubkeyHash);
      case 1:
        var var_scriptHash = sse_decode_String(deserializer);
        return Payload_ScriptHash(scriptHash: var_scriptHash);
      case 2:
        var var_version = sse_decode_witness_version(deserializer);
        var var_program = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_WitnessProgram(
          version: var_version,
          program: var_program,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PkOrF sse_decode_pk_or_f(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_value = sse_decode_String(deserializer);
        return PkOrF_Pubkey(value: var_value);
      case 1:
        var var_value = sse_decode_String(deserializer);
        return PkOrF_XOnlyPubkey(value: var_value);
      case 2:
        var var_value = sse_decode_String(deserializer);
        return PkOrF_Fingerprint(value: var_value);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PsbtSigHashType sse_decode_psbt_sig_hash_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inner = sse_decode_u_32(deserializer);
    return PsbtSigHashType(inner: var_inner);
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (BdkAddress, int) sse_decode_record_bdk_address_u_32(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_bdk_address(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (BdkPsbt, BdkTransactionDetails)
  sse_decode_record_bdk_psbt_bdk_transaction_details(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_bdk_psbt(deserializer);
    var var_field1 = sse_decode_bdk_transaction_details(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (Uint32List, List<Condition>)
  sse_decode_record_list_prim_u_32_strict_list_condition(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_list_prim_u_32_strict(deserializer);
    var var_field1 = sse_decode_list_condition(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (OutPoint, Input, BigInt) sse_decode_record_out_point_input_usize(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_out_point(deserializer);
    var var_field1 = sse_decode_input(deserializer);
    var var_field2 = sse_decode_usize(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  (String, Uint32List) sse_decode_record_string_list_prim_u_32_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_list_prim_u_32_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (int, List<Condition>) sse_decode_record_u_32_list_condition(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_list_condition(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RpcConfig sse_decode_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_auth = sse_decode_auth(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_syncParams = sse_decode_opt_box_autoadd_rpc_sync_params(
      deserializer,
    );
    return RpcConfig(
      url: var_url,
      auth: var_auth,
      network: var_network,
      walletName: var_walletName,
      syncParams: var_syncParams,
    );
  }

  @protected
  RpcSyncParams sse_decode_rpc_sync_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startScriptCount = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_forceStartTime = sse_decode_bool(deserializer);
    var var_pollRateSec = sse_decode_u_64(deserializer);
    return RpcSyncParams(
      startScriptCount: var_startScriptCount,
      startTime: var_startTime,
      forceStartTime: var_forceStartTime,
      pollRateSec: var_pollRateSec,
    );
  }

  @protected
  Satisfaction sse_decode_satisfaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_n = sse_decode_u_64(deserializer);
        var var_m = sse_decode_u_64(deserializer);
        var var_items = sse_decode_list_prim_u_64_strict(deserializer);
        var var_sorted = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_conditions = sse_decode_Map_u_32_list_condition_None(
          deserializer,
        );
        return Satisfaction_Partial(
          n: var_n,
          m: var_m,
          items: var_items,
          sorted: var_sorted,
          conditions: var_conditions,
        );
      case 1:
        var var_n = sse_decode_u_64(deserializer);
        var var_m = sse_decode_u_64(deserializer);
        var var_items = sse_decode_list_prim_u_64_strict(deserializer);
        var var_sorted = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_conditions =
            sse_decode_Map_list_prim_u_32_strict_list_condition_None(
              deserializer,
            );
        return Satisfaction_PartialComplete(
          n: var_n,
          m: var_m,
          items: var_items,
          sorted: var_sorted,
          conditions: var_conditions,
        );
      case 2:
        var var_condition = sse_decode_box_autoadd_condition(deserializer);
        return Satisfaction_Complete(condition: var_condition);
      case 3:
        var var_msg = sse_decode_String(deserializer);
        return Satisfaction_None(msg: var_msg);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SatisfiableItem sse_decode_satisfiable_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_key = sse_decode_box_autoadd_pk_or_f(deserializer);
        return SatisfiableItem_EcdsaSignature(key: var_key);
      case 1:
        var var_key = sse_decode_box_autoadd_pk_or_f(deserializer);
        return SatisfiableItem_SchnorrSignature(key: var_key);
      case 2:
        var var_hash = sse_decode_String(deserializer);
        return SatisfiableItem_Sha256Preimage(hash: var_hash);
      case 3:
        var var_hash = sse_decode_String(deserializer);
        return SatisfiableItem_Hash256Preimage(hash: var_hash);
      case 4:
        var var_hash = sse_decode_String(deserializer);
        return SatisfiableItem_Ripemd160Preimage(hash: var_hash);
      case 5:
        var var_hash = sse_decode_String(deserializer);
        return SatisfiableItem_Hash160Preimage(hash: var_hash);
      case 6:
        var var_value = sse_decode_box_autoadd_lock_time(deserializer);
        return SatisfiableItem_AbsoluteTimelock(value: var_value);
      case 7:
        var var_value = sse_decode_u_32(deserializer);
        return SatisfiableItem_RelativeTimelock(value: var_value);
      case 8:
        var var_keys = sse_decode_list_pk_or_f(deserializer);
        var var_threshold = sse_decode_u_64(deserializer);
        return SatisfiableItem_Multisig(
          keys: var_keys,
          threshold: var_threshold,
        );
      case 9:
        var var_items = sse_decode_list_bdk_policy(deserializer);
        var var_threshold = sse_decode_u_64(deserializer);
        return SatisfiableItem_Thresh(
          items: var_items,
          threshold: var_threshold,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ScriptAmount sse_decode_script_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_script = sse_decode_bdk_script_buf(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    return ScriptAmount(script: var_script, amount: var_amount);
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
      trustWitnessUtxo: var_trustWitnessUtxo,
      assumeHeight: var_assumeHeight,
      allowAllSighashes: var_allowAllSighashes,
      removePartialSigs: var_removePartialSigs,
      tryFinalize: var_tryFinalize,
      signWithTapInternalKey: var_signWithTapInternalKey,
      allowGrinding: var_allowGrinding,
    );
  }

  @protected
  SledDbConfiguration sse_decode_sled_db_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_treeName = sse_decode_String(deserializer);
    return SledDbConfiguration(path: var_path, treeName: var_treeName);
  }

  @protected
  SqliteDbConfiguration sse_decode_sqlite_db_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    return SqliteDbConfiguration(path: var_path);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  Variant sse_decode_variant(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Variant.values[inner];
  }

  @protected
  WitnessVersion sse_decode_witness_version(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WitnessVersion.values[inner];
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  int cst_encode_RustOpaque_bdkbitcoinAddress(Address raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as AddressImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkbitcoinbip32DerivationPath(DerivationPath raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as DerivationPathImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkblockchainAnyBlockchain(AnyBlockchain raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as AnyBlockchainImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkdescriptorExtendedDescriptor(
    ExtendedDescriptor raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as ExtendedDescriptorImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkdescriptorPolicy(Policy raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as PolicyImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkkeysDescriptorPublicKey(
    DescriptorPublicKey raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as DescriptorPublicKeyImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkkeysDescriptorSecretKey(
    DescriptorSecretKey raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as DescriptorSecretKeyImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkkeysKeyMap(KeyMap raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as KeyMapImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkkeysbip39Mnemonic(Mnemonic raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as MnemonicImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
    MutexWalletAnyDatabase raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as MutexWalletAnyDatabaseImpl).frbInternalCstEncode();
  }

  @protected
  int
  cst_encode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
    MutexPartiallySignedTransaction raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as MutexPartiallySignedTransactionImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_change_spend_policy(ChangeSpendPolicy raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_keychain_kind(KeychainKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_variant(Variant raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_witness_version(WitnessVersion raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_word_count(WordCount raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  void sse_encode_Map_String_list_prim_u_32_strict_None(
    Map<String, Uint32List> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_list_prim_u_32_strict(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void sse_encode_Map_list_prim_u_32_strict_list_condition_None(
    Map<Uint32List, List<Condition>> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_list_prim_u_32_strict_list_condition(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void sse_encode_Map_u_32_list_condition_None(
    Map<int, List<Condition>> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_u_32_list_condition(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkbitcoinAddress(
    Address self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as AddressImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkbitcoinbip32DerivationPath(
    DerivationPath self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DerivationPathImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkblockchainAnyBlockchain(
    AnyBlockchain self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as AnyBlockchainImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkdescriptorExtendedDescriptor(
    ExtendedDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ExtendedDescriptorImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkdescriptorPolicy(
    Policy self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PolicyImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkkeysDescriptorPublicKey(
    DescriptorPublicKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DescriptorPublicKeyImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkkeysDescriptorSecretKey(
    DescriptorSecretKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DescriptorSecretKeyImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkkeysKeyMap(
    KeyMap self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as KeyMapImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_bdkkeysbip39Mnemonic(
    Mnemonic self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MnemonicImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
    MutexWalletAnyDatabase self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MutexWalletAnyDatabaseImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
    MutexPartiallySignedTransaction self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MutexPartiallySignedTransactionImpl).frbInternalSseEncode(
        move: null,
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_error(AddressError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressError_Base58(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_Bech32(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_EmptyBech32Payload():
        sse_encode_i_32(2, serializer);
      case AddressError_InvalidBech32Variant(
        expected: final expected,
        found: final found,
      ):
        sse_encode_i_32(3, serializer);
        sse_encode_variant(expected, serializer);
        sse_encode_variant(found, serializer);
      case AddressError_InvalidWitnessVersion(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_u_8(field0, serializer);
      case AddressError_UnparsableWitnessVersion(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_MalformedWitnessVersion():
        sse_encode_i_32(6, serializer);
      case AddressError_InvalidWitnessProgramLength(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_usize(field0, serializer);
      case AddressError_InvalidSegwitV0ProgramLength(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_usize(field0, serializer);
      case AddressError_UncompressedPubkey():
        sse_encode_i_32(9, serializer);
      case AddressError_ExcessiveScriptSize():
        sse_encode_i_32(10, serializer);
      case AddressError_UnrecognizedScript():
        sse_encode_i_32(11, serializer);
      case AddressError_UnknownAddressType(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_NetworkValidation(
        networkRequired: final networkRequired,
        networkFound: final networkFound,
        address: final address,
      ):
        sse_encode_i_32(13, serializer);
        sse_encode_network(networkRequired, serializer);
        sse_encode_network(networkFound, serializer);
        sse_encode_String(address, serializer);
    }
  }

  @protected
  void sse_encode_address_index(AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressIndex_Increase():
        sse_encode_i_32(0, serializer);
      case AddressIndex_LastUnused():
        sse_encode_i_32(1, serializer);
      case AddressIndex_Peek(index: final index):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(index, serializer);
      case AddressIndex_Reset(index: final index):
        sse_encode_i_32(3, serializer);
        sse_encode_u_32(index, serializer);
    }
  }

  @protected
  void sse_encode_auth(Auth self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Auth_None():
        sse_encode_i_32(0, serializer);
      case Auth_UserPass(username: final username, password: final password):
        sse_encode_i_32(1, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
      case Auth_Cookie(file: final file):
        sse_encode_i_32(2, serializer);
        sse_encode_String(file, serializer);
    }
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_bdk_address(BdkAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkbitcoinAddress(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_blockchain(BdkBlockchain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkblockchainAnyBlockchain(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_derivation_path(
    BdkDerivationPath self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkbitcoinbip32DerivationPath(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor(BdkDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkdescriptorExtendedDescriptor(
      self.extendedDescriptor,
      serializer,
    );
    sse_encode_RustOpaque_bdkkeysKeyMap(self.keyMap, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor_public_key(
    BdkDescriptorPublicKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkkeysDescriptorPublicKey(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor_secret_key(
    BdkDescriptorSecretKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkkeysDescriptorSecretKey(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_error(BdkError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BdkError_Hex(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_hex_error(field0, serializer);
      case BdkError_Consensus(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_consensus_error(field0, serializer);
      case BdkError_VerifyTransaction(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Address(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_address_error(field0, serializer);
      case BdkError_Descriptor(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_descriptor_error(field0, serializer);
      case BdkError_InvalidU32Bytes(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
      case BdkError_Generic(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_ScriptDoesntHaveAddressForm():
        sse_encode_i_32(7, serializer);
      case BdkError_NoRecipients():
        sse_encode_i_32(8, serializer);
      case BdkError_NoUtxosSelected():
        sse_encode_i_32(9, serializer);
      case BdkError_OutputBelowDustLimit(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_usize(field0, serializer);
      case BdkError_InsufficientFunds(
        needed: final needed,
        available: final available,
      ):
        sse_encode_i_32(11, serializer);
        sse_encode_u_64(needed, serializer);
        sse_encode_u_64(available, serializer);
      case BdkError_BnBTotalTriesExceeded():
        sse_encode_i_32(12, serializer);
      case BdkError_BnBNoExactMatch():
        sse_encode_i_32(13, serializer);
      case BdkError_UnknownUtxo():
        sse_encode_i_32(14, serializer);
      case BdkError_TransactionNotFound():
        sse_encode_i_32(15, serializer);
      case BdkError_TransactionConfirmed():
        sse_encode_i_32(16, serializer);
      case BdkError_IrreplaceableTransaction():
        sse_encode_i_32(17, serializer);
      case BdkError_FeeRateTooLow(needed: final needed):
        sse_encode_i_32(18, serializer);
        sse_encode_f_32(needed, serializer);
      case BdkError_FeeTooLow(needed: final needed):
        sse_encode_i_32(19, serializer);
        sse_encode_u_64(needed, serializer);
      case BdkError_FeeRateUnavailable():
        sse_encode_i_32(20, serializer);
      case BdkError_MissingKeyOrigin(field0: final field0):
        sse_encode_i_32(21, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Key(field0: final field0):
        sse_encode_i_32(22, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_ChecksumMismatch():
        sse_encode_i_32(23, serializer);
      case BdkError_SpendingPolicyRequired(field0: final field0):
        sse_encode_i_32(24, serializer);
        sse_encode_keychain_kind(field0, serializer);
      case BdkError_InvalidPolicyPathError(field0: final field0):
        sse_encode_i_32(25, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Signer(field0: final field0):
        sse_encode_i_32(26, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidNetwork(
        requested: final requested,
        found: final found,
      ):
        sse_encode_i_32(27, serializer);
        sse_encode_network(requested, serializer);
        sse_encode_network(found, serializer);
      case BdkError_InvalidOutpoint(field0: final field0):
        sse_encode_i_32(28, serializer);
        sse_encode_box_autoadd_out_point(field0, serializer);
      case BdkError_Encode(field0: final field0):
        sse_encode_i_32(29, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Miniscript(field0: final field0):
        sse_encode_i_32(30, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_MiniscriptPsbt(field0: final field0):
        sse_encode_i_32(31, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Bip32(field0: final field0):
        sse_encode_i_32(32, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Bip39(field0: final field0):
        sse_encode_i_32(33, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Secp256k1(field0: final field0):
        sse_encode_i_32(34, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Json(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Psbt(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_PsbtParse(field0: final field0):
        sse_encode_i_32(37, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_MissingCachedScripts(
        field0: final field0,
        field1: final field1,
      ):
        sse_encode_i_32(38, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
      case BdkError_Electrum(field0: final field0):
        sse_encode_i_32(39, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Esplora(field0: final field0):
        sse_encode_i_32(40, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Sled(field0: final field0):
        sse_encode_i_32(41, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Rpc(field0: final field0):
        sse_encode_i_32(42, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Rusqlite(field0: final field0):
        sse_encode_i_32(43, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidInput(field0: final field0):
        sse_encode_i_32(44, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidLockTime(field0: final field0):
        sse_encode_i_32(45, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidTransaction(field0: final field0):
        sse_encode_i_32(46, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_bdk_mnemonic(BdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkkeysbip39Mnemonic(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_policy(BdkPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkdescriptorPolicy(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_psbt(BdkPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexbdkbitcoinpsbtPartiallySignedTransaction(
      self.ptr,
      serializer,
    );
  }

  @protected
  void sse_encode_bdk_script_buf(BdkScriptBuf self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.bytes, serializer);
  }

  @protected
  void sse_encode_bdk_transaction(
    BdkTransaction self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_bdk_transaction_details(
    BdkTransactionDetails self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bdk_transaction(self.transaction, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.received, serializer);
    sse_encode_u_64(self.sent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_block_time(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_bdk_tx_in(BdkTxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_opt_box_autoadd_bdk_script_buf(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_list_prim_u_8_strict(self.witness, serializer);
  }

  @protected
  void sse_encode_bdk_tx_out(BdkTxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_bdk_script_buf(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_bdk_wallet(BdkWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexbdkWalletbdkdatabaseAnyDatabase(
      self.ptr,
      serializer,
    );
  }

  @protected
  void sse_encode_block_time(BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_blockchain_config(
    BlockchainConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BlockchainConfig_Electrum(config: final config):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_electrum_config(config, serializer);
      case BlockchainConfig_Esplora(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_esplora_config(config, serializer);
      case BlockchainConfig_Rpc(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_rpc_config(config, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address_error(
    AddressError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_address_index(
    AddressIndex self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_index(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_address(
    BdkAddress self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_blockchain(
    BdkBlockchain self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_blockchain(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_derivation_path(
    BdkDerivationPath self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_derivation_path(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor(
    BdkDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor_public_key(
    BdkDescriptorPublicKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor_secret_key(
    BdkDescriptorSecretKey self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor_secret_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_mnemonic(
    BdkMnemonic self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_policy(
    BdkPolicy self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_policy(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_psbt(BdkPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_psbt(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_script_buf(
    BdkScriptBuf self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_script_buf(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_transaction(
    BdkTransaction self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_transaction(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_wallet(
    BdkWallet self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_wallet(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_block_time(
    BlockTime self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_blockchain_config(
    BlockchainConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_blockchain_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_condition(
    Condition self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_condition(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_consensus_error(
    ConsensusError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_consensus_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_database_config(
    DatabaseConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_database_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_descriptor_error(
    DescriptorError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_descriptor_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_electrum_config(
    ElectrumConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_electrum_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_config(
    EsploraConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fee_rate(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_hex_error(
    HexError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_hex_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_local_utxo(
    LocalUtxo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_local_utxo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lock_time(
    LockTime self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lock_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
    OutPoint self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pk_or_f(PkOrF self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pk_or_f(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_psbt_sig_hash_type(
    PsbtSigHashType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_psbt_sig_hash_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
    RbfValue self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_record_out_point_input_usize(
    (OutPoint, Input, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_out_point_input_usize(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_config(
    RpcConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_sync_params(
    RpcSyncParams self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_sync_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
    SignOptions self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sled_db_configuration(
    SledDbConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sled_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sqlite_db_configuration(
    SqliteDbConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sqlite_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_change_spend_policy(
    ChangeSpendPolicy self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_condition(Condition self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_32(self.csv, serializer);
    sse_encode_opt_box_autoadd_lock_time(self.timelock, serializer);
  }

  @protected
  void sse_encode_consensus_error(
    ConsensusError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ConsensusError_Io(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case ConsensusError_OversizedVectorAllocation(
        requested: final requested,
        max: final max,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_usize(requested, serializer);
        sse_encode_usize(max, serializer);
      case ConsensusError_InvalidChecksum(
        expected: final expected,
        actual: final actual,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_4(expected, serializer);
        sse_encode_u_8_array_4(actual, serializer);
      case ConsensusError_NonMinimalVarInt():
        sse_encode_i_32(3, serializer);
      case ConsensusError_ParseFailed(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case ConsensusError_UnsupportedSegwitFlag(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_u_8(field0, serializer);
    }
  }

  @protected
  void sse_encode_database_config(
    DatabaseConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DatabaseConfig_Memory():
        sse_encode_i_32(0, serializer);
      case DatabaseConfig_Sqlite(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_sqlite_db_configuration(config, serializer);
      case DatabaseConfig_Sled(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_sled_db_configuration(config, serializer);
    }
  }

  @protected
  void sse_encode_descriptor_error(
    DescriptorError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DescriptorError_InvalidHdKeyPath():
        sse_encode_i_32(0, serializer);
      case DescriptorError_InvalidDescriptorChecksum():
        sse_encode_i_32(1, serializer);
      case DescriptorError_HardenedDerivationXpub():
        sse_encode_i_32(2, serializer);
      case DescriptorError_MultiPath():
        sse_encode_i_32(3, serializer);
      case DescriptorError_Key(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Policy(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_InvalidDescriptorCharacter(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_u_8(field0, serializer);
      case DescriptorError_Bip32(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Base58(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Pk(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Miniscript(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Hex(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_electrum_config(
    ElectrumConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.socks5, serializer);
    sse_encode_u_8(self.retry, serializer);
    sse_encode_opt_box_autoadd_u_8(self.timeout, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_bool(self.validateDomain, serializer);
  }

  @protected
  void sse_encode_esplora_config(EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.proxy, serializer);
    sse_encode_opt_box_autoadd_u_8(self.concurrency, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_opt_box_autoadd_u_64(self.timeout, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.satPerVb, serializer);
  }

  @protected
  void sse_encode_hex_error(HexError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case HexError_InvalidChar(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8(field0, serializer);
      case HexError_OddLengthString(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_usize(field0, serializer);
      case HexError_InvalidLength(field0: final field0, field1: final field1):
        sse_encode_i_32(2, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_input(Input self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_bdk_policy(
    List<BdkPolicy> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bdk_policy(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bdk_transaction_details(
    List<BdkTransactionDetails> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bdk_transaction_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bdk_tx_in(List<BdkTxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bdk_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bdk_tx_out(
    List<BdkTxOut> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bdk_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_list_condition(
    List<Condition> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_condition(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_prim_u_8_strict(
    List<Uint8List> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_u_8_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_utxo(
    List<LocalUtxo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
    List<OutPoint> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pk_or_f(List<PkOrF> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pk_or_f(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
    Uint32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_64_strict(
    Uint64List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_list_prim_u_32_strict_list_condition(
    List<(Uint32List, List<Condition>)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_list_prim_u_32_strict_list_condition(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_list_prim_u_32_strict(
    List<(String, Uint32List)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_list_prim_u_32_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_u_32_list_condition(
    List<(int, List<Condition>)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_u_32_list_condition(item, serializer);
    }
  }

  @protected
  void sse_encode_list_script_amount(
    List<ScriptAmount> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_script_amount(item, serializer);
    }
  }

  @protected
  void sse_encode_local_utxo(LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_bdk_tx_out(self.txout, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
    sse_encode_bool(self.isSpent, serializer);
  }

  @protected
  void sse_encode_lock_time(LockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LockTime_Blocks(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(field0, serializer);
      case LockTime_Seconds(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_Map_String_list_prim_u_32_strict_None(
    Map<String, Uint32List>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Map_String_list_prim_u_32_strict_None(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_address(
    BdkAddress? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_address(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_descriptor(
    BdkDescriptor? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_descriptor(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_policy(
    BdkPolicy? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_policy(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_script_buf(
    BdkScriptBuf? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_script_buf(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_transaction(
    BdkTransaction? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_transaction(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_time(
    BlockTime? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fee_rate(
    FeeRate? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fee_rate(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_lock_time(
    LockTime? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_lock_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_psbt_sig_hash_type(
    PsbtSigHashType? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_psbt_sig_hash_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
    RbfValue? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_record_out_point_input_usize(
    (OutPoint, Input, BigInt)? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_out_point_input_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_sync_params(
    RpcSyncParams? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_sync_params(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sign_options(
    SignOptions? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sign_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payload(Payload self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Payload_PubkeyHash(pubkeyHash: final pubkeyHash):
        sse_encode_i_32(0, serializer);
        sse_encode_String(pubkeyHash, serializer);
      case Payload_ScriptHash(scriptHash: final scriptHash):
        sse_encode_i_32(1, serializer);
        sse_encode_String(scriptHash, serializer);
      case Payload_WitnessProgram(
        version: final version,
        program: final program,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_witness_version(version, serializer);
        sse_encode_list_prim_u_8_strict(program, serializer);
    }
  }

  @protected
  void sse_encode_pk_or_f(PkOrF self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PkOrF_Pubkey(value: final value):
        sse_encode_i_32(0, serializer);
        sse_encode_String(value, serializer);
      case PkOrF_XOnlyPubkey(value: final value):
        sse_encode_i_32(1, serializer);
        sse_encode_String(value, serializer);
      case PkOrF_Fingerprint(value: final value):
        sse_encode_i_32(2, serializer);
        sse_encode_String(value, serializer);
    }
  }

  @protected
  void sse_encode_psbt_sig_hash_type(
    PsbtSigHashType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.inner, serializer);
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_record_bdk_address_u_32(
    (BdkAddress, int) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_address(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
  }

  @protected
  void sse_encode_record_bdk_psbt_bdk_transaction_details(
    (BdkPsbt, BdkTransactionDetails) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_psbt(self.$1, serializer);
    sse_encode_bdk_transaction_details(self.$2, serializer);
  }

  @protected
  void sse_encode_record_list_prim_u_32_strict_list_condition(
    (Uint32List, List<Condition>) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_32_strict(self.$1, serializer);
    sse_encode_list_condition(self.$2, serializer);
  }

  @protected
  void sse_encode_record_out_point_input_usize(
    (OutPoint, Input, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.$1, serializer);
    sse_encode_input(self.$2, serializer);
    sse_encode_usize(self.$3, serializer);
  }

  @protected
  void sse_encode_record_string_list_prim_u_32_strict(
    (String, Uint32List) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_list_prim_u_32_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_32_list_condition(
    (int, List<Condition>) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_list_condition(self.$2, serializer);
  }

  @protected
  void sse_encode_rpc_config(RpcConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_auth(self.auth, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_opt_box_autoadd_rpc_sync_params(self.syncParams, serializer);
  }

  @protected
  void sse_encode_rpc_sync_params(
    RpcSyncParams self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.startScriptCount, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_bool(self.forceStartTime, serializer);
    sse_encode_u_64(self.pollRateSec, serializer);
  }

  @protected
  void sse_encode_satisfaction(Satisfaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Satisfaction_Partial(
        n: final n,
        m: final m,
        items: final items,
        sorted: final sorted,
        conditions: final conditions,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(n, serializer);
        sse_encode_u_64(m, serializer);
        sse_encode_list_prim_u_64_strict(items, serializer);
        sse_encode_opt_box_autoadd_bool(sorted, serializer);
        sse_encode_Map_u_32_list_condition_None(conditions, serializer);
      case Satisfaction_PartialComplete(
        n: final n,
        m: final m,
        items: final items,
        sorted: final sorted,
        conditions: final conditions,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(n, serializer);
        sse_encode_u_64(m, serializer);
        sse_encode_list_prim_u_64_strict(items, serializer);
        sse_encode_opt_box_autoadd_bool(sorted, serializer);
        sse_encode_Map_list_prim_u_32_strict_list_condition_None(
          conditions,
          serializer,
        );
      case Satisfaction_Complete(condition: final condition):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_condition(condition, serializer);
      case Satisfaction_None(msg: final msg):
        sse_encode_i_32(3, serializer);
        sse_encode_String(msg, serializer);
    }
  }

  @protected
  void sse_encode_satisfiable_item(
    SatisfiableItem self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SatisfiableItem_EcdsaSignature(key: final key):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_pk_or_f(key, serializer);
      case SatisfiableItem_SchnorrSignature(key: final key):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_pk_or_f(key, serializer);
      case SatisfiableItem_Sha256Preimage(hash: final hash):
        sse_encode_i_32(2, serializer);
        sse_encode_String(hash, serializer);
      case SatisfiableItem_Hash256Preimage(hash: final hash):
        sse_encode_i_32(3, serializer);
        sse_encode_String(hash, serializer);
      case SatisfiableItem_Ripemd160Preimage(hash: final hash):
        sse_encode_i_32(4, serializer);
        sse_encode_String(hash, serializer);
      case SatisfiableItem_Hash160Preimage(hash: final hash):
        sse_encode_i_32(5, serializer);
        sse_encode_String(hash, serializer);
      case SatisfiableItem_AbsoluteTimelock(value: final value):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_lock_time(value, serializer);
      case SatisfiableItem_RelativeTimelock(value: final value):
        sse_encode_i_32(7, serializer);
        sse_encode_u_32(value, serializer);
      case SatisfiableItem_Multisig(
        keys: final keys,
        threshold: final threshold,
      ):
        sse_encode_i_32(8, serializer);
        sse_encode_list_pk_or_f(keys, serializer);
        sse_encode_u_64(threshold, serializer);
      case SatisfiableItem_Thresh(
        items: final items,
        threshold: final threshold,
      ):
        sse_encode_i_32(9, serializer);
        sse_encode_list_bdk_policy(items, serializer);
        sse_encode_u_64(threshold, serializer);
    }
  }

  @protected
  void sse_encode_script_amount(ScriptAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_script_buf(self.script, serializer);
    sse_encode_u_64(self.amount, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_sled_db_configuration(
    SledDbConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.treeName, serializer);
  }

  @protected
  void sse_encode_sqlite_db_configuration(
    SqliteDbConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_variant(Variant self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_witness_version(
    WitnessVersion self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}

@sealed
class AddressImpl extends RustOpaque implements Address {
  // Not to be used by end users
  AddressImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AddressImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Address,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Address,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_AddressPtr,
  );
}

@sealed
class AnyBlockchainImpl extends RustOpaque implements AnyBlockchain {
  // Not to be used by end users
  AnyBlockchainImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AnyBlockchainImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_AnyBlockchain,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_AnyBlockchain,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_AnyBlockchainPtr,
  );
}

@sealed
class DerivationPathImpl extends RustOpaque implements DerivationPath {
  // Not to be used by end users
  DerivationPathImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DerivationPathImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DerivationPath,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DerivationPath,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_DerivationPathPtr,
  );
}

@sealed
class DescriptorPublicKeyImpl extends RustOpaque
    implements DescriptorPublicKey {
  // Not to be used by end users
  DescriptorPublicKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DescriptorPublicKeyImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DescriptorPublicKey,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DescriptorPublicKey,
    rustArcDecrementStrongCountPtr:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_DescriptorPublicKeyPtr,
  );
}

@sealed
class DescriptorSecretKeyImpl extends RustOpaque
    implements DescriptorSecretKey {
  // Not to be used by end users
  DescriptorSecretKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DescriptorSecretKeyImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DescriptorSecretKey,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DescriptorSecretKey,
    rustArcDecrementStrongCountPtr:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_DescriptorSecretKeyPtr,
  );
}

@sealed
class ExtendedDescriptorImpl extends RustOpaque implements ExtendedDescriptor {
  // Not to be used by end users
  ExtendedDescriptorImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtendedDescriptorImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_ExtendedDescriptor,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_ExtendedDescriptor,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_ExtendedDescriptorPtr,
  );
}

@sealed
class KeyMapImpl extends RustOpaque implements KeyMap {
  // Not to be used by end users
  KeyMapImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  KeyMapImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_KeyMap,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_KeyMap,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_KeyMapPtr,
  );
}

@sealed
class MnemonicImpl extends RustOpaque implements Mnemonic {
  // Not to be used by end users
  MnemonicImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MnemonicImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Mnemonic,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Mnemonic,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_MnemonicPtr,
  );
}

@sealed
class MutexPartiallySignedTransactionImpl extends RustOpaque
    implements MutexPartiallySignedTransaction {
  // Not to be used by end users
  MutexPartiallySignedTransactionImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexPartiallySignedTransactionImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core
            .instance
            .api
            .rust_arc_increment_strong_count_MutexPartiallySignedTransaction,
    rustArcDecrementStrongCount:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_MutexPartiallySignedTransaction,
    rustArcDecrementStrongCountPtr:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_MutexPartiallySignedTransactionPtr,
  );
}

@sealed
class MutexWalletAnyDatabaseImpl extends RustOpaque
    implements MutexWalletAnyDatabase {
  // Not to be used by end users
  MutexWalletAnyDatabaseImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexWalletAnyDatabaseImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core
            .instance
            .api
            .rust_arc_increment_strong_count_MutexWalletAnyDatabase,
    rustArcDecrementStrongCount:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_MutexWalletAnyDatabase,
    rustArcDecrementStrongCountPtr:
        core
            .instance
            .api
            .rust_arc_decrement_strong_count_MutexWalletAnyDatabasePtr,
  );
}

@sealed
class PolicyImpl extends RustOpaque implements Policy {
  // Not to be used by end users
  PolicyImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PolicyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Policy,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Policy,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_PolicyPtr,
  );
}
