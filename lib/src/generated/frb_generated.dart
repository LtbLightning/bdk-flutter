// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bitcoin.dart';
import 'api/descriptor.dart';
import 'api/electrum.dart';
import 'api/error.dart';
import 'api/esplora.dart';
import 'api/key.dart';
import 'api/store.dart';
import 'api/tx_builder.dart';
import 'api/types.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class core extends BaseEntrypoint<coreApi, coreApiImpl, coreWire> {
  @internal
  static final instance = core._();

  core._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    coreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required coreApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<coreApiImpl, coreWire> get apiImplConstructor =>
      coreApiImpl.new;

  @override
  WireConstructor<coreWire> get wireConstructor => coreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.4.0';

  @override
  int get rustContentHash => -1125178077;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'bdk_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class coreApi extends BaseApi {
  String crateApiBitcoinFfiAddressAsString({required FfiAddress that});

  Future<FfiAddress> crateApiBitcoinFfiAddressFromScript(
      {required FfiScriptBuf script, required Network network});

  Future<FfiAddress> crateApiBitcoinFfiAddressFromString(
      {required String address, required Network network});

  bool crateApiBitcoinFfiAddressIsValidForNetwork(
      {required FfiAddress that, required Network network});

  FfiScriptBuf crateApiBitcoinFfiAddressScript({required FfiAddress opaque});

  String crateApiBitcoinFfiAddressToQrUri({required FfiAddress that});

  String crateApiBitcoinFfiPsbtAsString({required FfiPsbt that});

  Future<FfiPsbt> crateApiBitcoinFfiPsbtCombine(
      {required FfiPsbt opaque, required FfiPsbt other});

  FfiTransaction crateApiBitcoinFfiPsbtExtractTx({required FfiPsbt opaque});

  BigInt? crateApiBitcoinFfiPsbtFeeAmount({required FfiPsbt that});

  Future<FfiPsbt> crateApiBitcoinFfiPsbtFromStr({required String psbtBase64});

  String crateApiBitcoinFfiPsbtJsonSerialize({required FfiPsbt that});

  Uint8List crateApiBitcoinFfiPsbtSerialize({required FfiPsbt that});

  String crateApiBitcoinFfiScriptBufAsString({required FfiScriptBuf that});

  FfiScriptBuf crateApiBitcoinFfiScriptBufEmpty();

  Future<FfiScriptBuf> crateApiBitcoinFfiScriptBufWithCapacity(
      {required BigInt capacity});

  Future<String> crateApiBitcoinFfiTransactionComputeTxid(
      {required FfiTransaction that});

  Future<FfiTransaction> crateApiBitcoinFfiTransactionFromBytes(
      {required List<int> transactionBytes});

  Future<List<TxIn>> crateApiBitcoinFfiTransactionInput(
      {required FfiTransaction that});

  Future<bool> crateApiBitcoinFfiTransactionIsCoinbase(
      {required FfiTransaction that});

  Future<bool> crateApiBitcoinFfiTransactionIsExplicitlyRbf(
      {required FfiTransaction that});

  Future<bool> crateApiBitcoinFfiTransactionIsLockTimeEnabled(
      {required FfiTransaction that});

  Future<LockTime> crateApiBitcoinFfiTransactionLockTime(
      {required FfiTransaction that});

  Future<FfiTransaction> crateApiBitcoinFfiTransactionNew(
      {required int version,
      required LockTime lockTime,
      required List<TxIn> input,
      required List<TxOut> output});

  Future<List<TxOut>> crateApiBitcoinFfiTransactionOutput(
      {required FfiTransaction that});

  Future<Uint8List> crateApiBitcoinFfiTransactionSerialize(
      {required FfiTransaction that});

  Future<int> crateApiBitcoinFfiTransactionVersion(
      {required FfiTransaction that});

  Future<BigInt> crateApiBitcoinFfiTransactionVsize(
      {required FfiTransaction that});

  Future<BigInt> crateApiBitcoinFfiTransactionWeight(
      {required FfiTransaction that});

  String crateApiDescriptorFfiDescriptorAsString({required FfiDescriptor that});

  BigInt crateApiDescriptorFfiDescriptorMaxSatisfactionWeight(
      {required FfiDescriptor that});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNew(
      {required String descriptor, required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip44(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip44Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip49(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip49Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip84(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip84Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip86(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network});

  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip86Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network});

  String crateApiDescriptorFfiDescriptorToStringWithSecret(
      {required FfiDescriptor that});

  Future<String> crateApiElectrumFfiElectrumClientBroadcast(
      {required FfiElectrumClient that, required FfiTransaction transaction});

  Future<FfiUpdate> crateApiElectrumFfiElectrumClientFullScan(
      {required FfiElectrumClient that,
      required FfiFullScanRequest request,
      required BigInt stopGap,
      required BigInt batchSize,
      required bool fetchPrevTxouts});

  Future<FfiElectrumClient> crateApiElectrumFfiElectrumClientNew(
      {required String url});

  Future<FfiUpdate> crateApiElectrumFfiElectrumClientSync(
      {required FfiElectrumClient that,
      required FfiSyncRequest request,
      required BigInt batchSize,
      required bool fetchPrevTxouts});

  Future<void> crateApiEsploraFfiEsploraClientBroadcast(
      {required FfiEsploraClient that, required FfiTransaction transaction});

  Future<FfiUpdate> crateApiEsploraFfiEsploraClientFullScan(
      {required FfiEsploraClient that,
      required FfiFullScanRequest request,
      required BigInt stopGap,
      required BigInt parallelRequests});

  Future<FfiEsploraClient> crateApiEsploraFfiEsploraClientNew(
      {required String url});

  Future<FfiUpdate> crateApiEsploraFfiEsploraClientSync(
      {required FfiEsploraClient that,
      required FfiSyncRequest request,
      required BigInt parallelRequests});

  String crateApiKeyFfiDerivationPathAsString(
      {required FfiDerivationPath that});

  Future<FfiDerivationPath> crateApiKeyFfiDerivationPathFromString(
      {required String path});

  String crateApiKeyFfiDescriptorPublicKeyAsString(
      {required FfiDescriptorPublicKey that});

  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyDerive(
      {required FfiDescriptorPublicKey opaque,
      required FfiDerivationPath path});

  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyExtend(
      {required FfiDescriptorPublicKey opaque,
      required FfiDerivationPath path});

  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyFromString(
      {required String publicKey});

  FfiDescriptorPublicKey crateApiKeyFfiDescriptorSecretKeyAsPublic(
      {required FfiDescriptorSecretKey opaque});

  String crateApiKeyFfiDescriptorSecretKeyAsString(
      {required FfiDescriptorSecretKey that});

  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyCreate(
      {required Network network,
      required FfiMnemonic mnemonic,
      String? password});

  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyDerive(
      {required FfiDescriptorSecretKey opaque,
      required FfiDerivationPath path});

  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyExtend(
      {required FfiDescriptorSecretKey opaque,
      required FfiDerivationPath path});

  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyFromString(
      {required String secretKey});

  Uint8List crateApiKeyFfiDescriptorSecretKeySecretBytes(
      {required FfiDescriptorSecretKey that});

  String crateApiKeyFfiMnemonicAsString({required FfiMnemonic that});

  Future<FfiMnemonic> crateApiKeyFfiMnemonicFromEntropy(
      {required List<int> entropy});

  Future<FfiMnemonic> crateApiKeyFfiMnemonicFromString(
      {required String mnemonic});

  Future<FfiMnemonic> crateApiKeyFfiMnemonicNew({required WordCount wordCount});

  Future<FfiConnection> crateApiStoreFfiConnectionNew({required String path});

  Future<FfiConnection> crateApiStoreFfiConnectionNewInMemory();

  Future<FfiPsbt> crateApiTxBuilderFinishBumpFeeTxBuilder(
      {required String txid,
      required FeeRate feeRate,
      required FfiWallet wallet,
      required bool enableRbf,
      int? nSequence});

  Future<FfiPsbt> crateApiTxBuilderTxBuilderFinish(
      {required FfiWallet wallet,
      required List<(FfiScriptBuf, BigInt)> recipients,
      required List<OutPoint> utxos,
      required List<OutPoint> unSpendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      FeeRate? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      FfiScriptBuf? drainTo,
      RbfValue? rbf,
      required List<int> data});

  Future<ChangeSpendPolicy> crateApiTypesChangeSpendPolicyDefault();

  Future<FfiFullScanRequest> crateApiTypesFfiFullScanRequestBuilderBuild(
      {required FfiFullScanRequestBuilder that});

  Future<FfiFullScanRequestBuilder>
      crateApiTypesFfiFullScanRequestBuilderInspectSpksForAllKeychains(
          {required FfiFullScanRequestBuilder that,
          required FutureOr<void> Function(KeychainKind, int, FfiScriptBuf)
              inspector});

  Future<FfiSyncRequest> crateApiTypesFfiSyncRequestBuilderBuild(
      {required FfiSyncRequestBuilder that});

  Future<FfiSyncRequestBuilder> crateApiTypesFfiSyncRequestBuilderInspectSpks(
      {required FfiSyncRequestBuilder that,
      required FutureOr<void> Function(FfiScriptBuf, BigInt) inspector});

  Future<Network> crateApiTypesNetworkDefault();

  Future<SignOptions> crateApiTypesSignOptionsDefault();

  Future<void> crateApiWalletFfiWalletApplyUpdate(
      {required FfiWallet that, required FfiUpdate update});

  Future<BigInt> crateApiWalletFfiWalletCalculateFee(
      {required FfiWallet that, required FfiTransaction tx});

  Future<FeeRate> crateApiWalletFfiWalletCalculateFeeRate(
      {required FfiWallet that, required FfiTransaction tx});

  Balance crateApiWalletFfiWalletGetBalance({required FfiWallet that});

  Future<FfiCanonicalTx?> crateApiWalletFfiWalletGetTx(
      {required FfiWallet that, required String txid});

  bool crateApiWalletFfiWalletIsMine(
      {required FfiWallet that, required FfiScriptBuf script});

  Future<List<LocalOutput>> crateApiWalletFfiWalletListOutput(
      {required FfiWallet that});

  List<LocalOutput> crateApiWalletFfiWalletListUnspent(
      {required FfiWallet that});

  Future<FfiWallet> crateApiWalletFfiWalletLoad(
      {required FfiDescriptor descriptor,
      required FfiDescriptor changeDescriptor,
      required FfiConnection connection});

  Network crateApiWalletFfiWalletNetwork({required FfiWallet that});

  Future<FfiWallet> crateApiWalletFfiWalletNew(
      {required FfiDescriptor descriptor,
      required FfiDescriptor changeDescriptor,
      required Network network,
      required FfiConnection connection});

  Future<bool> crateApiWalletFfiWalletPersist(
      {required FfiWallet that, required FfiConnection connection});

  AddressInfo crateApiWalletFfiWalletRevealNextAddress(
      {required FfiWallet opaque, required KeychainKind keychainKind});

  Future<bool> crateApiWalletFfiWalletSign(
      {required FfiWallet that,
      required FfiPsbt psbt,
      required SignOptions signOptions});

  Future<FfiFullScanRequestBuilder> crateApiWalletFfiWalletStartFullScan(
      {required FfiWallet that});

  Future<FfiSyncRequestBuilder>
      crateApiWalletFfiWalletStartSyncWithRevealedSpks(
          {required FfiWallet that});

  List<FfiCanonicalTx> crateApiWalletFfiWalletTransactions(
      {required FfiWallet that});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Address;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Address;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AddressPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Transaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Transaction;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TransactionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkElectrumClientClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkElectrumClientClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BdkElectrumClientClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlockingClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlockingClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BlockingClientPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Update;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Update;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UpdatePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DerivationPath;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DerivationPath;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DerivationPathPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedDescriptor;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtendedDescriptorPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DescriptorPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DescriptorPublicKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DescriptorPublicKeyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DescriptorSecretKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DescriptorSecretKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DescriptorSecretKeyPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_KeyMap;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_KeyMap;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_KeyMapPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Mnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Mnemonic;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionFullScanRequestBuilderKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestBuilderKeychainKind;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestBuilderKeychainKindPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionFullScanRequestKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestKeychainKind;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestKeychainKindPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionSyncRequestKeychainKindU32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestKeychainKindU32;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestKeychainKindU32Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPsbt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPsbt;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MutexPsbtPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPersistedWalletConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPersistedWalletConnection;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexPersistedWalletConnectionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexConnection;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexConnectionPtr;
}

class coreApiImpl extends coreApiImplPlatform implements coreApi {
  coreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  String crateApiBitcoinFfiAddressAsString({required FfiAddress that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_address(that);
        return wire.wire__crate__api__bitcoin__ffi_address_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiAddressAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiAddress> crateApiBitcoinFfiAddressFromScript(
      {required FfiScriptBuf script, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_script_buf(script);
        var arg1 = cst_encode_network(network);
        return wire.wire__crate__api__bitcoin__ffi_address_from_script(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_address,
        decodeErrorData: dco_decode_from_script_error,
      ),
      constMeta: kCrateApiBitcoinFfiAddressFromScriptConstMeta,
      argValues: [script, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressFromScriptConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_from_script",
        argNames: ["script", "network"],
      );

  @override
  Future<FfiAddress> crateApiBitcoinFfiAddressFromString(
      {required String address, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(address);
        var arg1 = cst_encode_network(network);
        return wire.wire__crate__api__bitcoin__ffi_address_from_string(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_address,
        decodeErrorData: dco_decode_address_parse_error,
      ),
      constMeta: kCrateApiBitcoinFfiAddressFromStringConstMeta,
      argValues: [address, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_from_string",
        argNames: ["address", "network"],
      );

  @override
  bool crateApiBitcoinFfiAddressIsValidForNetwork(
      {required FfiAddress that, required Network network}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_address(that);
        var arg1 = cst_encode_network(network);
        return wire.wire__crate__api__bitcoin__ffi_address_is_valid_for_network(
            arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiAddressIsValidForNetworkConstMeta,
      argValues: [that, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressIsValidForNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_is_valid_for_network",
        argNames: ["that", "network"],
      );

  @override
  FfiScriptBuf crateApiBitcoinFfiAddressScript({required FfiAddress opaque}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_address(opaque);
        return wire.wire__crate__api__bitcoin__ffi_address_script(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiAddressScriptConstMeta,
      argValues: [opaque],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressScriptConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_script",
        argNames: ["opaque"],
      );

  @override
  String crateApiBitcoinFfiAddressToQrUri({required FfiAddress that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_address(that);
        return wire.wire__crate__api__bitcoin__ffi_address_to_qr_uri(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiAddressToQrUriConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiAddressToQrUriConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_address_to_qr_uri",
        argNames: ["that"],
      );

  @override
  String crateApiBitcoinFfiPsbtAsString({required FfiPsbt that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(that);
        return wire.wire__crate__api__bitcoin__ffi_psbt_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiPsbt> crateApiBitcoinFfiPsbtCombine(
      {required FfiPsbt opaque, required FfiPsbt other}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(opaque);
        var arg1 = cst_encode_box_autoadd_ffi_psbt(other);
        return wire.wire__crate__api__bitcoin__ffi_psbt_combine(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_psbt,
        decodeErrorData: dco_decode_psbt_error,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtCombineConstMeta,
      argValues: [opaque, other],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtCombineConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_combine",
        argNames: ["opaque", "other"],
      );

  @override
  FfiTransaction crateApiBitcoinFfiPsbtExtractTx({required FfiPsbt opaque}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(opaque);
        return wire.wire__crate__api__bitcoin__ffi_psbt_extract_tx(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_transaction,
        decodeErrorData: dco_decode_extract_tx_error,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtExtractTxConstMeta,
      argValues: [opaque],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtExtractTxConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_extract_tx",
        argNames: ["opaque"],
      );

  @override
  BigInt? crateApiBitcoinFfiPsbtFeeAmount({required FfiPsbt that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(that);
        return wire.wire__crate__api__bitcoin__ffi_psbt_fee_amount(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtFeeAmountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtFeeAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_fee_amount",
        argNames: ["that"],
      );

  @override
  Future<FfiPsbt> crateApiBitcoinFfiPsbtFromStr({required String psbtBase64}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(psbtBase64);
        return wire.wire__crate__api__bitcoin__ffi_psbt_from_str(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_psbt,
        decodeErrorData: dco_decode_psbt_parse_error,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtFromStrConstMeta,
      argValues: [psbtBase64],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtFromStrConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_from_str",
        argNames: ["psbtBase64"],
      );

  @override
  String crateApiBitcoinFfiPsbtJsonSerialize({required FfiPsbt that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(that);
        return wire.wire__crate__api__bitcoin__ffi_psbt_json_serialize(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_psbt_error,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtJsonSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtJsonSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_json_serialize",
        argNames: ["that"],
      );

  @override
  Uint8List crateApiBitcoinFfiPsbtSerialize({required FfiPsbt that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_psbt(that);
        return wire.wire__crate__api__bitcoin__ffi_psbt_serialize(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiPsbtSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiPsbtSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_psbt_serialize",
        argNames: ["that"],
      );

  @override
  String crateApiBitcoinFfiScriptBufAsString({required FfiScriptBuf that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_script_buf(that);
        return wire.wire__crate__api__bitcoin__ffi_script_buf_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiScriptBufAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiScriptBufAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_script_buf_as_string",
        argNames: ["that"],
      );

  @override
  FfiScriptBuf crateApiBitcoinFfiScriptBufEmpty() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        return wire.wire__crate__api__bitcoin__ffi_script_buf_empty();
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiScriptBufEmptyConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiScriptBufEmptyConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_script_buf_empty",
        argNames: [],
      );

  @override
  Future<FfiScriptBuf> crateApiBitcoinFfiScriptBufWithCapacity(
      {required BigInt capacity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_usize(capacity);
        return wire.wire__crate__api__bitcoin__ffi_script_buf_with_capacity(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiScriptBufWithCapacityConstMeta,
      argValues: [capacity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiScriptBufWithCapacityConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_script_buf_with_capacity",
        argNames: ["capacity"],
      );

  @override
  Future<String> crateApiBitcoinFfiTransactionComputeTxid(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_compute_txid(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionComputeTxidConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionComputeTxidConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_compute_txid",
        argNames: ["that"],
      );

  @override
  Future<FfiTransaction> crateApiBitcoinFfiTransactionFromBytes(
      {required List<int> transactionBytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_list_prim_u_8_loose(transactionBytes);
        return wire.wire__crate__api__bitcoin__ffi_transaction_from_bytes(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_transaction,
        decodeErrorData: dco_decode_transaction_error,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionFromBytesConstMeta,
      argValues: [transactionBytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_from_bytes",
        argNames: ["transactionBytes"],
      );

  @override
  Future<List<TxIn>> crateApiBitcoinFfiTransactionInput(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_input(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_tx_in,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionInputConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionInputConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_input",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiBitcoinFfiTransactionIsCoinbase(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_is_coinbase(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionIsCoinbaseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionIsCoinbaseConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_is_coinbase",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiBitcoinFfiTransactionIsExplicitlyRbf(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire
            .wire__crate__api__bitcoin__ffi_transaction_is_explicitly_rbf(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionIsExplicitlyRbfConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionIsExplicitlyRbfConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_is_explicitly_rbf",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiBitcoinFfiTransactionIsLockTimeEnabled(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire
            .wire__crate__api__bitcoin__ffi_transaction_is_lock_time_enabled(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionIsLockTimeEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionIsLockTimeEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_is_lock_time_enabled",
        argNames: ["that"],
      );

  @override
  Future<LockTime> crateApiBitcoinFfiTransactionLockTime(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_lock_time(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lock_time,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionLockTimeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionLockTimeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_lock_time",
        argNames: ["that"],
      );

  @override
  Future<FfiTransaction> crateApiBitcoinFfiTransactionNew(
      {required int version,
      required LockTime lockTime,
      required List<TxIn> input,
      required List<TxOut> output}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_i_32(version);
        var arg1 = cst_encode_box_autoadd_lock_time(lockTime);
        var arg2 = cst_encode_list_tx_in(input);
        var arg3 = cst_encode_list_tx_out(output);
        return wire.wire__crate__api__bitcoin__ffi_transaction_new(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_transaction,
        decodeErrorData: dco_decode_transaction_error,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionNewConstMeta,
      argValues: [version, lockTime, input, output],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_new",
        argNames: ["version", "lockTime", "input", "output"],
      );

  @override
  Future<List<TxOut>> crateApiBitcoinFfiTransactionOutput(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_output(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_tx_out,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionOutputConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionOutputConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_output",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateApiBitcoinFfiTransactionSerialize(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_serialize(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_serialize",
        argNames: ["that"],
      );

  @override
  Future<int> crateApiBitcoinFfiTransactionVersion(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_version(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionVersionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionVersionConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_version",
        argNames: ["that"],
      );

  @override
  Future<BigInt> crateApiBitcoinFfiTransactionVsize(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_vsize(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionVsizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionVsizeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_vsize",
        argNames: ["that"],
      );

  @override
  Future<BigInt> crateApiBitcoinFfiTransactionWeight(
      {required FfiTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_transaction(that);
        return wire.wire__crate__api__bitcoin__ffi_transaction_weight(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBitcoinFfiTransactionWeightConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBitcoinFfiTransactionWeightConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_transaction_weight",
        argNames: ["that"],
      );

  @override
  String crateApiDescriptorFfiDescriptorAsString(
      {required FfiDescriptor that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor(that);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_as_string",
        argNames: ["that"],
      );

  @override
  BigInt crateApiDescriptorFfiDescriptorMaxSatisfactionWeight(
      {required FfiDescriptor that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor(that);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_max_satisfaction_weight(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorMaxSatisfactionWeightConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDescriptorFfiDescriptorMaxSatisfactionWeightConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_descriptor_max_satisfaction_weight",
            argNames: ["that"],
          );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNew(
      {required String descriptor, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(descriptor);
        var arg1 = cst_encode_network(network);
        return wire.wire__crate__api__descriptor__ffi_descriptor_new(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip44(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire__crate__api__descriptor__ffi_descriptor_new_bip44(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip44ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip44ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip44",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip44Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_new_bip44_public(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip44PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip44PublicConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip44_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip49(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire__crate__api__descriptor__ffi_descriptor_new_bip49(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip49ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip49ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip49",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip49Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_new_bip49_public(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip49PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip49PublicConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip49_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip84(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire__crate__api__descriptor__ffi_descriptor_new_bip84(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip84ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip84ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip84",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip84Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_new_bip84_public(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip84PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip84PublicConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip84_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip86(
      {required FfiDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire__crate__api__descriptor__ffi_descriptor_new_bip86(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip86ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip86ConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip86",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<FfiDescriptor> crateApiDescriptorFfiDescriptorNewBip86Public(
      {required FfiDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_new_bip86_public(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorNewBip86PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDescriptorFfiDescriptorNewBip86PublicConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_new_bip86_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  String crateApiDescriptorFfiDescriptorToStringWithSecret(
      {required FfiDescriptor that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor(that);
        return wire
            .wire__crate__api__descriptor__ffi_descriptor_to_string_with_secret(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDescriptorFfiDescriptorToStringWithSecretConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDescriptorFfiDescriptorToStringWithSecretConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_descriptor_to_string_with_secret",
            argNames: ["that"],
          );

  @override
  Future<String> crateApiElectrumFfiElectrumClientBroadcast(
      {required FfiElectrumClient that, required FfiTransaction transaction}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_electrum_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_transaction(transaction);
        return wire.wire__crate__api__electrum__ffi_electrum_client_broadcast(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_electrum_error,
      ),
      constMeta: kCrateApiElectrumFfiElectrumClientBroadcastConstMeta,
      argValues: [that, transaction],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiElectrumFfiElectrumClientBroadcastConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_electrum_client_broadcast",
        argNames: ["that", "transaction"],
      );

  @override
  Future<FfiUpdate> crateApiElectrumFfiElectrumClientFullScan(
      {required FfiElectrumClient that,
      required FfiFullScanRequest request,
      required BigInt stopGap,
      required BigInt batchSize,
      required bool fetchPrevTxouts}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_electrum_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_full_scan_request(request);
        var arg2 = cst_encode_u_64(stopGap);
        var arg3 = cst_encode_u_64(batchSize);
        var arg4 = cst_encode_bool(fetchPrevTxouts);
        return wire.wire__crate__api__electrum__ffi_electrum_client_full_scan(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_update,
        decodeErrorData: dco_decode_electrum_error,
      ),
      constMeta: kCrateApiElectrumFfiElectrumClientFullScanConstMeta,
      argValues: [that, request, stopGap, batchSize, fetchPrevTxouts],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiElectrumFfiElectrumClientFullScanConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_electrum_client_full_scan",
        argNames: [
          "that",
          "request",
          "stopGap",
          "batchSize",
          "fetchPrevTxouts"
        ],
      );

  @override
  Future<FfiElectrumClient> crateApiElectrumFfiElectrumClientNew(
      {required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(url);
        return wire.wire__crate__api__electrum__ffi_electrum_client_new(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_electrum_client,
        decodeErrorData: dco_decode_electrum_error,
      ),
      constMeta: kCrateApiElectrumFfiElectrumClientNewConstMeta,
      argValues: [url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiElectrumFfiElectrumClientNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_electrum_client_new",
        argNames: ["url"],
      );

  @override
  Future<FfiUpdate> crateApiElectrumFfiElectrumClientSync(
      {required FfiElectrumClient that,
      required FfiSyncRequest request,
      required BigInt batchSize,
      required bool fetchPrevTxouts}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_electrum_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_sync_request(request);
        var arg2 = cst_encode_u_64(batchSize);
        var arg3 = cst_encode_bool(fetchPrevTxouts);
        return wire.wire__crate__api__electrum__ffi_electrum_client_sync(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_update,
        decodeErrorData: dco_decode_electrum_error,
      ),
      constMeta: kCrateApiElectrumFfiElectrumClientSyncConstMeta,
      argValues: [that, request, batchSize, fetchPrevTxouts],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiElectrumFfiElectrumClientSyncConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_electrum_client_sync",
        argNames: ["that", "request", "batchSize", "fetchPrevTxouts"],
      );

  @override
  Future<void> crateApiEsploraFfiEsploraClientBroadcast(
      {required FfiEsploraClient that, required FfiTransaction transaction}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_esplora_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_transaction(transaction);
        return wire.wire__crate__api__esplora__ffi_esplora_client_broadcast(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_esplora_error,
      ),
      constMeta: kCrateApiEsploraFfiEsploraClientBroadcastConstMeta,
      argValues: [that, transaction],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEsploraFfiEsploraClientBroadcastConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_esplora_client_broadcast",
        argNames: ["that", "transaction"],
      );

  @override
  Future<FfiUpdate> crateApiEsploraFfiEsploraClientFullScan(
      {required FfiEsploraClient that,
      required FfiFullScanRequest request,
      required BigInt stopGap,
      required BigInt parallelRequests}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_esplora_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_full_scan_request(request);
        var arg2 = cst_encode_u_64(stopGap);
        var arg3 = cst_encode_u_64(parallelRequests);
        return wire.wire__crate__api__esplora__ffi_esplora_client_full_scan(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_update,
        decodeErrorData: dco_decode_esplora_error,
      ),
      constMeta: kCrateApiEsploraFfiEsploraClientFullScanConstMeta,
      argValues: [that, request, stopGap, parallelRequests],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEsploraFfiEsploraClientFullScanConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_esplora_client_full_scan",
        argNames: ["that", "request", "stopGap", "parallelRequests"],
      );

  @override
  Future<FfiEsploraClient> crateApiEsploraFfiEsploraClientNew(
      {required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(url);
        return wire.wire__crate__api__esplora__ffi_esplora_client_new(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_esplora_client,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEsploraFfiEsploraClientNewConstMeta,
      argValues: [url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEsploraFfiEsploraClientNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_esplora_client_new",
        argNames: ["url"],
      );

  @override
  Future<FfiUpdate> crateApiEsploraFfiEsploraClientSync(
      {required FfiEsploraClient that,
      required FfiSyncRequest request,
      required BigInt parallelRequests}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_esplora_client(that);
        var arg1 = cst_encode_box_autoadd_ffi_sync_request(request);
        var arg2 = cst_encode_u_64(parallelRequests);
        return wire.wire__crate__api__esplora__ffi_esplora_client_sync(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_update,
        decodeErrorData: dco_decode_esplora_error,
      ),
      constMeta: kCrateApiEsploraFfiEsploraClientSyncConstMeta,
      argValues: [that, request, parallelRequests],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEsploraFfiEsploraClientSyncConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_esplora_client_sync",
        argNames: ["that", "request", "parallelRequests"],
      );

  @override
  String crateApiKeyFfiDerivationPathAsString(
      {required FfiDerivationPath that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_derivation_path(that);
        return wire.wire__crate__api__key__ffi_derivation_path_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiKeyFfiDerivationPathAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDerivationPathAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_derivation_path_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiDerivationPath> crateApiKeyFfiDerivationPathFromString(
      {required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        return wire.wire__crate__api__key__ffi_derivation_path_from_string(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_derivation_path,
        decodeErrorData: dco_decode_bip_32_error,
      ),
      constMeta: kCrateApiKeyFfiDerivationPathFromStringConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDerivationPathFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_derivation_path_from_string",
        argNames: ["path"],
      );

  @override
  String crateApiKeyFfiDescriptorPublicKeyAsString(
      {required FfiDescriptorPublicKey that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(that);
        return wire
            .wire__crate__api__key__ffi_descriptor_public_key_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiKeyFfiDescriptorPublicKeyAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorPublicKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_public_key_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyDerive(
      {required FfiDescriptorPublicKey opaque,
      required FfiDerivationPath path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(opaque);
        var arg1 = cst_encode_box_autoadd_ffi_derivation_path(path);
        return wire.wire__crate__api__key__ffi_descriptor_public_key_derive(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_public_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorPublicKeyDeriveConstMeta,
      argValues: [opaque, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorPublicKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_public_key_derive",
        argNames: ["opaque", "path"],
      );

  @override
  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyExtend(
      {required FfiDescriptorPublicKey opaque,
      required FfiDerivationPath path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_public_key(opaque);
        var arg1 = cst_encode_box_autoadd_ffi_derivation_path(path);
        return wire.wire__crate__api__key__ffi_descriptor_public_key_extend(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_public_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorPublicKeyExtendConstMeta,
      argValues: [opaque, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorPublicKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_public_key_extend",
        argNames: ["opaque", "path"],
      );

  @override
  Future<FfiDescriptorPublicKey> crateApiKeyFfiDescriptorPublicKeyFromString(
      {required String publicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(publicKey);
        return wire
            .wire__crate__api__key__ffi_descriptor_public_key_from_string(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_public_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorPublicKeyFromStringConstMeta,
      argValues: [publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorPublicKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_public_key_from_string",
        argNames: ["publicKey"],
      );

  @override
  FfiDescriptorPublicKey crateApiKeyFfiDescriptorSecretKeyAsPublic(
      {required FfiDescriptorSecretKey opaque}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(opaque);
        return wire
            .wire__crate__api__key__ffi_descriptor_secret_key_as_public(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_public_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyAsPublicConstMeta,
      argValues: [opaque],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyAsPublicConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_as_public",
        argNames: ["opaque"],
      );

  @override
  String crateApiKeyFfiDescriptorSecretKeyAsString(
      {required FfiDescriptorSecretKey that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(that);
        return wire
            .wire__crate__api__key__ffi_descriptor_secret_key_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyCreate(
      {required Network network,
      required FfiMnemonic mnemonic,
      String? password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_network(network);
        var arg1 = cst_encode_box_autoadd_ffi_mnemonic(mnemonic);
        var arg2 = cst_encode_opt_String(password);
        return wire.wire__crate__api__key__ffi_descriptor_secret_key_create(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_secret_key,
        decodeErrorData: dco_decode_descriptor_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyCreateConstMeta,
      argValues: [network, mnemonic, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyCreateConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_create",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyDerive(
      {required FfiDescriptorSecretKey opaque,
      required FfiDerivationPath path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(opaque);
        var arg1 = cst_encode_box_autoadd_ffi_derivation_path(path);
        return wire.wire__crate__api__key__ffi_descriptor_secret_key_derive(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_secret_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyDeriveConstMeta,
      argValues: [opaque, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_derive",
        argNames: ["opaque", "path"],
      );

  @override
  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyExtend(
      {required FfiDescriptorSecretKey opaque,
      required FfiDerivationPath path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(opaque);
        var arg1 = cst_encode_box_autoadd_ffi_derivation_path(path);
        return wire.wire__crate__api__key__ffi_descriptor_secret_key_extend(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_secret_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyExtendConstMeta,
      argValues: [opaque, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_extend",
        argNames: ["opaque", "path"],
      );

  @override
  Future<FfiDescriptorSecretKey> crateApiKeyFfiDescriptorSecretKeyFromString(
      {required String secretKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(secretKey);
        return wire
            .wire__crate__api__key__ffi_descriptor_secret_key_from_string(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_descriptor_secret_key,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeyFromStringConstMeta,
      argValues: [secretKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_from_string",
        argNames: ["secretKey"],
      );

  @override
  Uint8List crateApiKeyFfiDescriptorSecretKeySecretBytes(
      {required FfiDescriptorSecretKey that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor_secret_key(that);
        return wire
            .wire__crate__api__key__ffi_descriptor_secret_key_secret_bytes(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_descriptor_key_error,
      ),
      constMeta: kCrateApiKeyFfiDescriptorSecretKeySecretBytesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiDescriptorSecretKeySecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_descriptor_secret_key_secret_bytes",
        argNames: ["that"],
      );

  @override
  String crateApiKeyFfiMnemonicAsString({required FfiMnemonic that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_mnemonic(that);
        return wire.wire__crate__api__key__ffi_mnemonic_as_string(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiKeyFfiMnemonicAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiMnemonicAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_mnemonic_as_string",
        argNames: ["that"],
      );

  @override
  Future<FfiMnemonic> crateApiKeyFfiMnemonicFromEntropy(
      {required List<int> entropy}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_list_prim_u_8_loose(entropy);
        return wire.wire__crate__api__key__ffi_mnemonic_from_entropy(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_mnemonic,
        decodeErrorData: dco_decode_bip_39_error,
      ),
      constMeta: kCrateApiKeyFfiMnemonicFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiMnemonicFromEntropyConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_mnemonic_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<FfiMnemonic> crateApiKeyFfiMnemonicFromString(
      {required String mnemonic}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        return wire.wire__crate__api__key__ffi_mnemonic_from_string(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_mnemonic,
        decodeErrorData: dco_decode_bip_39_error,
      ),
      constMeta: kCrateApiKeyFfiMnemonicFromStringConstMeta,
      argValues: [mnemonic],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiMnemonicFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_mnemonic_from_string",
        argNames: ["mnemonic"],
      );

  @override
  Future<FfiMnemonic> crateApiKeyFfiMnemonicNew(
      {required WordCount wordCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_word_count(wordCount);
        return wire.wire__crate__api__key__ffi_mnemonic_new(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_mnemonic,
        decodeErrorData: dco_decode_bip_39_error,
      ),
      constMeta: kCrateApiKeyFfiMnemonicNewConstMeta,
      argValues: [wordCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiKeyFfiMnemonicNewConstMeta => const TaskConstMeta(
        debugName: "ffi_mnemonic_new",
        argNames: ["wordCount"],
      );

  @override
  Future<FfiConnection> crateApiStoreFfiConnectionNew({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        return wire.wire__crate__api__store__ffi_connection_new(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_connection,
        decodeErrorData: dco_decode_sqlite_error,
      ),
      constMeta: kCrateApiStoreFfiConnectionNewConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiStoreFfiConnectionNewConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_connection_new",
        argNames: ["path"],
      );

  @override
  Future<FfiConnection> crateApiStoreFfiConnectionNewInMemory() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__crate__api__store__ffi_connection_new_in_memory(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_connection,
        decodeErrorData: dco_decode_sqlite_error,
      ),
      constMeta: kCrateApiStoreFfiConnectionNewInMemoryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiStoreFfiConnectionNewInMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_connection_new_in_memory",
        argNames: [],
      );

  @override
  Future<FfiPsbt> crateApiTxBuilderFinishBumpFeeTxBuilder(
      {required String txid,
      required FeeRate feeRate,
      required FfiWallet wallet,
      required bool enableRbf,
      int? nSequence}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(txid);
        var arg1 = cst_encode_box_autoadd_fee_rate(feeRate);
        var arg2 = cst_encode_box_autoadd_ffi_wallet(wallet);
        var arg3 = cst_encode_bool(enableRbf);
        var arg4 = cst_encode_opt_box_autoadd_u_32(nSequence);
        return wire.wire__crate__api__tx_builder__finish_bump_fee_tx_builder(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_psbt,
        decodeErrorData: dco_decode_create_tx_error,
      ),
      constMeta: kCrateApiTxBuilderFinishBumpFeeTxBuilderConstMeta,
      argValues: [txid, feeRate, wallet, enableRbf, nSequence],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTxBuilderFinishBumpFeeTxBuilderConstMeta =>
      const TaskConstMeta(
        debugName: "finish_bump_fee_tx_builder",
        argNames: ["txid", "feeRate", "wallet", "enableRbf", "nSequence"],
      );

  @override
  Future<FfiPsbt> crateApiTxBuilderTxBuilderFinish(
      {required FfiWallet wallet,
      required List<(FfiScriptBuf, BigInt)> recipients,
      required List<OutPoint> utxos,
      required List<OutPoint> unSpendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      FeeRate? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      FfiScriptBuf? drainTo,
      RbfValue? rbf,
      required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(wallet);
        var arg1 = cst_encode_list_record_ffi_script_buf_u_64(recipients);
        var arg2 = cst_encode_list_out_point(utxos);
        var arg3 = cst_encode_list_out_point(unSpendable);
        var arg4 = cst_encode_change_spend_policy(changePolicy);
        var arg5 = cst_encode_bool(manuallySelectedOnly);
        var arg6 = cst_encode_opt_box_autoadd_fee_rate(feeRate);
        var arg7 = cst_encode_opt_box_autoadd_u_64(feeAbsolute);
        var arg8 = cst_encode_bool(drainWallet);
        var arg9 = cst_encode_opt_box_autoadd_ffi_script_buf(drainTo);
        var arg10 = cst_encode_opt_box_autoadd_rbf_value(rbf);
        var arg11 = cst_encode_list_prim_u_8_loose(data);
        return wire.wire__crate__api__tx_builder__tx_builder_finish(port_, arg0,
            arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_psbt,
        decodeErrorData: dco_decode_create_tx_error,
      ),
      constMeta: kCrateApiTxBuilderTxBuilderFinishConstMeta,
      argValues: [
        wallet,
        recipients,
        utxos,
        unSpendable,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTxBuilderTxBuilderFinishConstMeta =>
      const TaskConstMeta(
        debugName: "tx_builder_finish",
        argNames: [
          "wallet",
          "recipients",
          "utxos",
          "unSpendable",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data"
        ],
      );

  @override
  Future<ChangeSpendPolicy> crateApiTypesChangeSpendPolicyDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__types__change_spend_policy_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_change_spend_policy,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesChangeSpendPolicyDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesChangeSpendPolicyDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "change_spend_policy_default",
        argNames: [],
      );

  @override
  Future<FfiFullScanRequest> crateApiTypesFfiFullScanRequestBuilderBuild(
      {required FfiFullScanRequestBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_full_scan_request_builder(that);
        return wire
            .wire__crate__api__types__ffi_full_scan_request_builder_build(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_full_scan_request,
        decodeErrorData: dco_decode_request_builder_error,
      ),
      constMeta: kCrateApiTypesFfiFullScanRequestBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesFfiFullScanRequestBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_full_scan_request_builder_build",
        argNames: ["that"],
      );

  @override
  Future<FfiFullScanRequestBuilder>
      crateApiTypesFfiFullScanRequestBuilderInspectSpksForAllKeychains(
          {required FfiFullScanRequestBuilder that,
          required FutureOr<void> Function(KeychainKind, int, FfiScriptBuf)
              inspector}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_full_scan_request_builder(that);
        var arg1 =
            cst_encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
                inspector);
        return wire
            .wire__crate__api__types__ffi_full_scan_request_builder_inspect_spks_for_all_keychains(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_full_scan_request_builder,
        decodeErrorData: dco_decode_request_builder_error,
      ),
      constMeta:
          kCrateApiTypesFfiFullScanRequestBuilderInspectSpksForAllKeychainsConstMeta,
      argValues: [that, inspector],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiTypesFfiFullScanRequestBuilderInspectSpksForAllKeychainsConstMeta =>
          const TaskConstMeta(
            debugName:
                "ffi_full_scan_request_builder_inspect_spks_for_all_keychains",
            argNames: ["that", "inspector"],
          );

  @override
  Future<FfiSyncRequest> crateApiTypesFfiSyncRequestBuilderBuild(
      {required FfiSyncRequestBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_sync_request_builder(that);
        return wire.wire__crate__api__types__ffi_sync_request_builder_build(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_sync_request,
        decodeErrorData: dco_decode_request_builder_error,
      ),
      constMeta: kCrateApiTypesFfiSyncRequestBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesFfiSyncRequestBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_sync_request_builder_build",
        argNames: ["that"],
      );

  @override
  Future<FfiSyncRequestBuilder> crateApiTypesFfiSyncRequestBuilderInspectSpks(
      {required FfiSyncRequestBuilder that,
      required FutureOr<void> Function(FfiScriptBuf, BigInt) inspector}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_sync_request_builder(that);
        var arg1 =
            cst_encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
                inspector);
        return wire
            .wire__crate__api__types__ffi_sync_request_builder_inspect_spks(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_sync_request_builder,
        decodeErrorData: dco_decode_request_builder_error,
      ),
      constMeta: kCrateApiTypesFfiSyncRequestBuilderInspectSpksConstMeta,
      argValues: [that, inspector],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesFfiSyncRequestBuilderInspectSpksConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_sync_request_builder_inspect_spks",
        argNames: ["that", "inspector"],
      );

  @override
  Future<Network> crateApiTypesNetworkDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__types__network_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesNetworkDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesNetworkDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "network_default",
        argNames: [],
      );

  @override
  Future<SignOptions> crateApiTypesSignOptionsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__types__sign_options_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_sign_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesSignOptionsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesSignOptionsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "sign_options_default",
        argNames: [],
      );

  @override
  Future<void> crateApiWalletFfiWalletApplyUpdate(
      {required FfiWallet that, required FfiUpdate update}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_update(update);
        return wire.wire__crate__api__wallet__ffi_wallet_apply_update(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_cannot_connect_error,
      ),
      constMeta: kCrateApiWalletFfiWalletApplyUpdateConstMeta,
      argValues: [that, update],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletApplyUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_apply_update",
        argNames: ["that", "update"],
      );

  @override
  Future<BigInt> crateApiWalletFfiWalletCalculateFee(
      {required FfiWallet that, required FfiTransaction tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_transaction(tx);
        return wire.wire__crate__api__wallet__ffi_wallet_calculate_fee(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_calculate_fee_error,
      ),
      constMeta: kCrateApiWalletFfiWalletCalculateFeeConstMeta,
      argValues: [that, tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletCalculateFeeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_calculate_fee",
        argNames: ["that", "tx"],
      );

  @override
  Future<FeeRate> crateApiWalletFfiWalletCalculateFeeRate(
      {required FfiWallet that, required FfiTransaction tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_transaction(tx);
        return wire.wire__crate__api__wallet__ffi_wallet_calculate_fee_rate(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_fee_rate,
        decodeErrorData: dco_decode_calculate_fee_error,
      ),
      constMeta: kCrateApiWalletFfiWalletCalculateFeeRateConstMeta,
      argValues: [that, tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletCalculateFeeRateConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_calculate_fee_rate",
        argNames: ["that", "tx"],
      );

  @override
  Balance crateApiWalletFfiWalletGetBalance({required FfiWallet that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_get_balance(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_balance,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletGetBalanceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletGetBalanceConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_get_balance",
        argNames: ["that"],
      );

  @override
  Future<FfiCanonicalTx?> crateApiWalletFfiWalletGetTx(
      {required FfiWallet that, required String txid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_String(txid);
        return wire.wire__crate__api__wallet__ffi_wallet_get_tx(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_ffi_canonical_tx,
        decodeErrorData: dco_decode_txid_parse_error,
      ),
      constMeta: kCrateApiWalletFfiWalletGetTxConstMeta,
      argValues: [that, txid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletGetTxConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_get_tx",
        argNames: ["that", "txid"],
      );

  @override
  bool crateApiWalletFfiWalletIsMine(
      {required FfiWallet that, required FfiScriptBuf script}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_script_buf(script);
        return wire.wire__crate__api__wallet__ffi_wallet_is_mine(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletIsMineConstMeta,
      argValues: [that, script],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletIsMineConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_is_mine",
        argNames: ["that", "script"],
      );

  @override
  Future<List<LocalOutput>> crateApiWalletFfiWalletListOutput(
      {required FfiWallet that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_list_output(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_local_output,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletListOutputConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletListOutputConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_list_output",
        argNames: ["that"],
      );

  @override
  List<LocalOutput> crateApiWalletFfiWalletListUnspent(
      {required FfiWallet that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_list_unspent(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_local_output,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletListUnspentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletListUnspentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_list_unspent",
        argNames: ["that"],
      );

  @override
  Future<FfiWallet> crateApiWalletFfiWalletLoad(
      {required FfiDescriptor descriptor,
      required FfiDescriptor changeDescriptor,
      required FfiConnection connection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor(descriptor);
        var arg1 = cst_encode_box_autoadd_ffi_descriptor(changeDescriptor);
        var arg2 = cst_encode_box_autoadd_ffi_connection(connection);
        return wire.wire__crate__api__wallet__ffi_wallet_load(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_wallet,
        decodeErrorData: dco_decode_load_with_persist_error,
      ),
      constMeta: kCrateApiWalletFfiWalletLoadConstMeta,
      argValues: [descriptor, changeDescriptor, connection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletLoadConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_load",
        argNames: ["descriptor", "changeDescriptor", "connection"],
      );

  @override
  Network crateApiWalletFfiWalletNetwork({required FfiWallet that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_network(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_network",
        argNames: ["that"],
      );

  @override
  Future<FfiWallet> crateApiWalletFfiWalletNew(
      {required FfiDescriptor descriptor,
      required FfiDescriptor changeDescriptor,
      required Network network,
      required FfiConnection connection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_descriptor(descriptor);
        var arg1 = cst_encode_box_autoadd_ffi_descriptor(changeDescriptor);
        var arg2 = cst_encode_network(network);
        var arg3 = cst_encode_box_autoadd_ffi_connection(connection);
        return wire.wire__crate__api__wallet__ffi_wallet_new(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_wallet,
        decodeErrorData: dco_decode_create_with_persist_error,
      ),
      constMeta: kCrateApiWalletFfiWalletNewConstMeta,
      argValues: [descriptor, changeDescriptor, network, connection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletNewConstMeta => const TaskConstMeta(
        debugName: "ffi_wallet_new",
        argNames: ["descriptor", "changeDescriptor", "network", "connection"],
      );

  @override
  Future<bool> crateApiWalletFfiWalletPersist(
      {required FfiWallet that, required FfiConnection connection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_connection(connection);
        return wire.wire__crate__api__wallet__ffi_wallet_persist(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_sqlite_error,
      ),
      constMeta: kCrateApiWalletFfiWalletPersistConstMeta,
      argValues: [that, connection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletPersistConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_persist",
        argNames: ["that", "connection"],
      );

  @override
  AddressInfo crateApiWalletFfiWalletRevealNextAddress(
      {required FfiWallet opaque, required KeychainKind keychainKind}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(opaque);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        return wire.wire__crate__api__wallet__ffi_wallet_reveal_next_address(
            arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletRevealNextAddressConstMeta,
      argValues: [opaque, keychainKind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletRevealNextAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_reveal_next_address",
        argNames: ["opaque", "keychainKind"],
      );

  @override
  Future<bool> crateApiWalletFfiWalletSign(
      {required FfiWallet that,
      required FfiPsbt psbt,
      required SignOptions signOptions}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        var arg1 = cst_encode_box_autoadd_ffi_psbt(psbt);
        var arg2 = cst_encode_box_autoadd_sign_options(signOptions);
        return wire.wire__crate__api__wallet__ffi_wallet_sign(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_signer_error,
      ),
      constMeta: kCrateApiWalletFfiWalletSignConstMeta,
      argValues: [that, psbt, signOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletSignConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_sign",
        argNames: ["that", "psbt", "signOptions"],
      );

  @override
  Future<FfiFullScanRequestBuilder> crateApiWalletFfiWalletStartFullScan(
      {required FfiWallet that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_start_full_scan(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_full_scan_request_builder,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletStartFullScanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletStartFullScanConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_start_full_scan",
        argNames: ["that"],
      );

  @override
  Future<FfiSyncRequestBuilder>
      crateApiWalletFfiWalletStartSyncWithRevealedSpks(
          {required FfiWallet that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire
            .wire__crate__api__wallet__ffi_wallet_start_sync_with_revealed_spks(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_sync_request_builder,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletStartSyncWithRevealedSpksConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiWalletFfiWalletStartSyncWithRevealedSpksConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_wallet_start_sync_with_revealed_spks",
            argNames: ["that"],
          );

  @override
  List<FfiCanonicalTx> crateApiWalletFfiWalletTransactions(
      {required FfiWallet that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_ffi_wallet(that);
        return wire.wire__crate__api__wallet__ffi_wallet_transactions(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_ffi_canonical_tx,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWalletFfiWalletTransactionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletFfiWalletTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_wallet_transactions",
        argNames: ["that"],
      );

  Future<void> Function(int, dynamic, dynamic)
      encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
          FutureOr<void> Function(FfiScriptBuf, BigInt) raw) {
    return (callId, rawArg0, rawArg1) async {
      final arg0 = dco_decode_ffi_script_buf(rawArg0);
      final arg1 = dco_decode_u_64(rawArg1);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic, dynamic)
      encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
          FutureOr<void> Function(KeychainKind, int, FfiScriptBuf) raw) {
    return (callId, rawArg0, rawArg1, rawArg2) async {
      final arg0 = dco_decode_keychain_kind(rawArg0);
      final arg1 = dco_decode_u_32(rawArg1);
      final arg2 = dco_decode_ffi_script_buf(rawArg2);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1, arg2));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Address => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_corebitcoinAddress;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Address => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_corebitcoinAddress;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Transaction => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_corebitcoinTransaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Transaction => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_corebitcoinTransaction;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkElectrumClientClient => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkElectrumClientClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlockingClient => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlockingClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_esploraesplora_clientBlockingClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Update =>
          wire.rust_arc_increment_strong_count_RustOpaque_bdk_walletUpdate;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Update =>
          wire.rust_arc_decrement_strong_count_RustOpaque_bdk_walletUpdate;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DerivationPath => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DerivationPath => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_walletbitcoinbip32DerivationPath;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedDescriptor => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedDescriptor => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_walletdescriptorExtendedDescriptor;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DescriptorPublicKey => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DescriptorPublicKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorPublicKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DescriptorSecretKey => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DescriptorSecretKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysDescriptorSecretKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeyMap =>
          wire.rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysKeyMap;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeyMap =>
          wire.rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysKeyMap;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Mnemonic => wire
          .rust_arc_increment_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Mnemonic => wire
          .rust_arc_decrement_strong_count_RustOpaque_bdk_walletkeysbip39Mnemonic;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionFullScanRequestBuilderKeychainKind =>
          wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestBuilderKeychainKind =>
          wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionFullScanRequestKeychainKind =>
          wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionFullScanRequestKeychainKind =>
          wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32 =>
          wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32 =>
          wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexOptionSyncRequestKeychainKindU32 =>
          wire.rust_arc_increment_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexOptionSyncRequestKeychainKindU32 =>
          wire.rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPsbt => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPsbt => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPersistedWalletConnection => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPersistedWalletConnection => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexConnection => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexConnection => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  FutureOr<void> Function(FfiScriptBuf, BigInt)
      dco_decode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(KeychainKind, int, FfiScriptBuf)
      dco_decode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Address dco_decode_RustOpaque_bdk_corebitcoinAddress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Transaction dco_decode_RustOpaque_bdk_corebitcoinTransaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TransactionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkElectrumClientClient
      dco_decode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkElectrumClientClientImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  BlockingClient dco_decode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlockingClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Update dco_decode_RustOpaque_bdk_walletUpdate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UpdateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DerivationPath dco_decode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DerivationPathImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedDescriptor
      dco_decode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedDescriptorImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DescriptorPublicKey dco_decode_RustOpaque_bdk_walletkeysDescriptorPublicKey(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DescriptorPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DescriptorSecretKey dco_decode_RustOpaque_bdk_walletkeysDescriptorSecretKey(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DescriptorSecretKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  KeyMap dco_decode_RustOpaque_bdk_walletkeysKeyMap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeyMapImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Mnemonic dco_decode_RustOpaque_bdk_walletkeysbip39Mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexOptionFullScanRequestBuilderKeychainKind
      dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexOptionFullScanRequestBuilderKeychainKindImpl
        .frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexOptionFullScanRequestKeychainKind
      dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexOptionFullScanRequestKeychainKindImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MutexOptionSyncRequestBuilderKeychainKindU32
      dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexOptionSyncRequestBuilderKeychainKindU32Impl
        .frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexOptionSyncRequestKeychainKindU32
      dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexOptionSyncRequestKeychainKindU32Impl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MutexPsbt dco_decode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexPsbtImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexPersistedWalletConnection
      dco_decode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexPersistedWalletConnectionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MutexConnection
      dco_decode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexConnectionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AddressInfo(
      index: dco_decode_u_32(arr[0]),
      address: dco_decode_ffi_address(arr[1]),
      keychain: dco_decode_keychain_kind(arr[2]),
    );
  }

  @protected
  AddressParseError dco_decode_address_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressParseError_Base58();
      case 1:
        return AddressParseError_Bech32();
      case 2:
        return AddressParseError_WitnessVersion(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 3:
        return AddressParseError_WitnessProgram(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 4:
        return AddressParseError_UnknownHrp();
      case 5:
        return AddressParseError_LegacyAddressTooLong();
      case 6:
        return AddressParseError_InvalidBase58PayloadLength();
      case 7:
        return AddressParseError_InvalidLegacyPrefix();
      case 8:
        return AddressParseError_NetworkValidation();
      case 9:
        return AddressParseError_OtherAddressParseErr();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  Bip32Error dco_decode_bip_32_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Bip32Error_CannotDeriveFromHardenedKey();
      case 1:
        return Bip32Error_Secp256k1(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 2:
        return Bip32Error_InvalidChildNumber(
          childNumber: dco_decode_u_32(raw[1]),
        );
      case 3:
        return Bip32Error_InvalidChildNumberFormat();
      case 4:
        return Bip32Error_InvalidDerivationPathFormat();
      case 5:
        return Bip32Error_UnknownVersion(
          version: dco_decode_String(raw[1]),
        );
      case 6:
        return Bip32Error_WrongExtendedKeyLength(
          length: dco_decode_u_32(raw[1]),
        );
      case 7:
        return Bip32Error_Base58(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 8:
        return Bip32Error_Hex(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 9:
        return Bip32Error_InvalidPublicKeyHexLength(
          length: dco_decode_u_32(raw[1]),
        );
      case 10:
        return Bip32Error_UnknownError(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Bip39Error dco_decode_bip_39_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Bip39Error_BadWordCount(
          wordCount: dco_decode_u_64(raw[1]),
        );
      case 1:
        return Bip39Error_UnknownWord(
          index: dco_decode_u_64(raw[1]),
        );
      case 2:
        return Bip39Error_BadEntropyBitCount(
          bitCount: dco_decode_u_64(raw[1]),
        );
      case 3:
        return Bip39Error_InvalidChecksum();
      case 4:
        return Bip39Error_AmbiguousLanguages(
          languages: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BlockId dco_decode_block_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockId(
      height: dco_decode_u_32(arr[0]),
      hash: dco_decode_String(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ConfirmationBlockTime dco_decode_box_autoadd_confirmation_block_time(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_confirmation_block_time(raw);
  }

  @protected
  FeeRate dco_decode_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fee_rate(raw);
  }

  @protected
  FfiAddress dco_decode_box_autoadd_ffi_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_address(raw);
  }

  @protected
  FfiCanonicalTx dco_decode_box_autoadd_ffi_canonical_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_canonical_tx(raw);
  }

  @protected
  FfiConnection dco_decode_box_autoadd_ffi_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_connection(raw);
  }

  @protected
  FfiDerivationPath dco_decode_box_autoadd_ffi_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_derivation_path(raw);
  }

  @protected
  FfiDescriptor dco_decode_box_autoadd_ffi_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_descriptor(raw);
  }

  @protected
  FfiDescriptorPublicKey dco_decode_box_autoadd_ffi_descriptor_public_key(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_descriptor_public_key(raw);
  }

  @protected
  FfiDescriptorSecretKey dco_decode_box_autoadd_ffi_descriptor_secret_key(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_descriptor_secret_key(raw);
  }

  @protected
  FfiElectrumClient dco_decode_box_autoadd_ffi_electrum_client(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_electrum_client(raw);
  }

  @protected
  FfiEsploraClient dco_decode_box_autoadd_ffi_esplora_client(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_esplora_client(raw);
  }

  @protected
  FfiFullScanRequest dco_decode_box_autoadd_ffi_full_scan_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_full_scan_request(raw);
  }

  @protected
  FfiFullScanRequestBuilder
      dco_decode_box_autoadd_ffi_full_scan_request_builder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_full_scan_request_builder(raw);
  }

  @protected
  FfiMnemonic dco_decode_box_autoadd_ffi_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_mnemonic(raw);
  }

  @protected
  FfiPsbt dco_decode_box_autoadd_ffi_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_psbt(raw);
  }

  @protected
  FfiScriptBuf dco_decode_box_autoadd_ffi_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_script_buf(raw);
  }

  @protected
  FfiSyncRequest dco_decode_box_autoadd_ffi_sync_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_sync_request(raw);
  }

  @protected
  FfiSyncRequestBuilder dco_decode_box_autoadd_ffi_sync_request_builder(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_sync_request_builder(raw);
  }

  @protected
  FfiTransaction dco_decode_box_autoadd_ffi_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_transaction(raw);
  }

  @protected
  FfiUpdate dco_decode_box_autoadd_ffi_update(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_update(raw);
  }

  @protected
  FfiWallet dco_decode_box_autoadd_ffi_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_wallet(raw);
  }

  @protected
  LockTime dco_decode_box_autoadd_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lock_time(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  CalculateFeeError dco_decode_calculate_fee_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CalculateFeeError_Generic(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return CalculateFeeError_MissingTxOut(
          outPoints: dco_decode_list_out_point(raw[1]),
        );
      case 2:
        return CalculateFeeError_NegativeFee(
          amount: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  CannotConnectError dco_decode_cannot_connect_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CannotConnectError_Include(
          height: dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChainPosition dco_decode_chain_position(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ChainPosition_Confirmed(
          confirmationBlockTime:
              dco_decode_box_autoadd_confirmation_block_time(raw[1]),
        );
      case 1:
        return ChainPosition_Unconfirmed(
          timestamp: dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  ConfirmationBlockTime dco_decode_confirmation_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ConfirmationBlockTime(
      blockId: dco_decode_block_id(arr[0]),
      confirmationTime: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  CreateTxError dco_decode_create_tx_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CreateTxError_Generic(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return CreateTxError_Descriptor(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 2:
        return CreateTxError_Policy(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 3:
        return CreateTxError_SpendingPolicyRequired(
          kind: dco_decode_String(raw[1]),
        );
      case 4:
        return CreateTxError_Version0();
      case 5:
        return CreateTxError_Version1Csv();
      case 6:
        return CreateTxError_LockTime(
          requested: dco_decode_String(raw[1]),
          required_: dco_decode_String(raw[2]),
        );
      case 7:
        return CreateTxError_RbfSequence();
      case 8:
        return CreateTxError_RbfSequenceCsv(
          rbf: dco_decode_String(raw[1]),
          csv: dco_decode_String(raw[2]),
        );
      case 9:
        return CreateTxError_FeeTooLow(
          required_: dco_decode_String(raw[1]),
        );
      case 10:
        return CreateTxError_FeeRateTooLow(
          required_: dco_decode_String(raw[1]),
        );
      case 11:
        return CreateTxError_NoUtxosSelected();
      case 12:
        return CreateTxError_OutputBelowDustLimit(
          index: dco_decode_u_64(raw[1]),
        );
      case 13:
        return CreateTxError_ChangePolicyDescriptor();
      case 14:
        return CreateTxError_CoinSelection(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 15:
        return CreateTxError_InsufficientFunds(
          needed: dco_decode_u_64(raw[1]),
          available: dco_decode_u_64(raw[2]),
        );
      case 16:
        return CreateTxError_NoRecipients();
      case 17:
        return CreateTxError_Psbt(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 18:
        return CreateTxError_MissingKeyOrigin(
          key: dco_decode_String(raw[1]),
        );
      case 19:
        return CreateTxError_UnknownUtxo(
          outpoint: dco_decode_String(raw[1]),
        );
      case 20:
        return CreateTxError_MissingNonWitnessUtxo(
          outpoint: dco_decode_String(raw[1]),
        );
      case 21:
        return CreateTxError_MiniscriptPsbt(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  CreateWithPersistError dco_decode_create_with_persist_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CreateWithPersistError_Persist(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return CreateWithPersistError_DataAlreadyExists();
      case 2:
        return CreateWithPersistError_Descriptor(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DescriptorError dco_decode_descriptor_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_MissingPrivateData();
      case 2:
        return DescriptorError_InvalidDescriptorChecksum();
      case 3:
        return DescriptorError_HardenedDerivationXpub();
      case 4:
        return DescriptorError_MultiPath();
      case 5:
        return DescriptorError_Key(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 6:
        return DescriptorError_Generic(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 7:
        return DescriptorError_Policy(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 8:
        return DescriptorError_InvalidDescriptorCharacter(
          char: dco_decode_String(raw[1]),
        );
      case 9:
        return DescriptorError_Bip32(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 10:
        return DescriptorError_Base58(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 11:
        return DescriptorError_Pk(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 12:
        return DescriptorError_Miniscript(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 13:
        return DescriptorError_Hex(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 14:
        return DescriptorError_ExternalAndInternalAreTheSame();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DescriptorKeyError dco_decode_descriptor_key_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DescriptorKeyError_Parse(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return DescriptorKeyError_InvalidKeyType();
      case 2:
        return DescriptorKeyError_Bip32(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ElectrumError dco_decode_electrum_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ElectrumError_IOError(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return ElectrumError_Json(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 2:
        return ElectrumError_Hex(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 3:
        return ElectrumError_Protocol(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 4:
        return ElectrumError_Bitcoin(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 5:
        return ElectrumError_AlreadySubscribed();
      case 6:
        return ElectrumError_NotSubscribed();
      case 7:
        return ElectrumError_InvalidResponse(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 8:
        return ElectrumError_Message(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 9:
        return ElectrumError_InvalidDNSNameError(
          domain: dco_decode_String(raw[1]),
        );
      case 10:
        return ElectrumError_MissingDomain();
      case 11:
        return ElectrumError_AllAttemptsErrored();
      case 12:
        return ElectrumError_SharedIOError(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 13:
        return ElectrumError_CouldntLockReader();
      case 14:
        return ElectrumError_Mpsc();
      case 15:
        return ElectrumError_CouldNotCreateConnection(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 16:
        return ElectrumError_RequestAlreadyConsumed();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EsploraError dco_decode_esplora_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EsploraError_Minreq(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return EsploraError_HttpResponse(
          status: dco_decode_u_16(raw[1]),
          errorMessage: dco_decode_String(raw[2]),
        );
      case 2:
        return EsploraError_Parsing(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 3:
        return EsploraError_StatusCode(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 4:
        return EsploraError_BitcoinEncoding(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 5:
        return EsploraError_HexToArray(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 6:
        return EsploraError_HexToBytes(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 7:
        return EsploraError_TransactionNotFound();
      case 8:
        return EsploraError_HeaderHeightNotFound(
          height: dco_decode_u_32(raw[1]),
        );
      case 9:
        return EsploraError_HeaderHashNotFound();
      case 10:
        return EsploraError_InvalidHttpHeaderName(
          name: dco_decode_String(raw[1]),
        );
      case 11:
        return EsploraError_InvalidHttpHeaderValue(
          value: dco_decode_String(raw[1]),
        );
      case 12:
        return EsploraError_RequestAlreadyConsumed();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ExtractTxError dco_decode_extract_tx_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ExtractTxError_AbsurdFeeRate(
          feeRate: dco_decode_u_64(raw[1]),
        );
      case 1:
        return ExtractTxError_MissingInputValue();
      case 2:
        return ExtractTxError_SendingTooMuch();
      case 3:
        return ExtractTxError_OtherExtractTxErr();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FeeRate dco_decode_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FeeRate(
      satKwu: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  FfiAddress dco_decode_ffi_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiAddress(
      field0: dco_decode_RustOpaque_bdk_corebitcoinAddress(arr[0]),
    );
  }

  @protected
  FfiCanonicalTx dco_decode_ffi_canonical_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FfiCanonicalTx(
      transaction: dco_decode_ffi_transaction(arr[0]),
      chainPosition: dco_decode_chain_position(arr[1]),
    );
  }

  @protected
  FfiConnection dco_decode_ffi_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiConnection(
      field0: dco_decode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
          arr[0]),
    );
  }

  @protected
  FfiDerivationPath dco_decode_ffi_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiDerivationPath(
      opaque:
          dco_decode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(arr[0]),
    );
  }

  @protected
  FfiDescriptor dco_decode_ffi_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FfiDescriptor(
      extendedDescriptor:
          dco_decode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(arr[0]),
      keyMap: dco_decode_RustOpaque_bdk_walletkeysKeyMap(arr[1]),
    );
  }

  @protected
  FfiDescriptorPublicKey dco_decode_ffi_descriptor_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiDescriptorPublicKey(
      opaque: dco_decode_RustOpaque_bdk_walletkeysDescriptorPublicKey(arr[0]),
    );
  }

  @protected
  FfiDescriptorSecretKey dco_decode_ffi_descriptor_secret_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiDescriptorSecretKey(
      opaque: dco_decode_RustOpaque_bdk_walletkeysDescriptorSecretKey(arr[0]),
    );
  }

  @protected
  FfiElectrumClient dco_decode_ffi_electrum_client(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiElectrumClient(
      opaque:
          dco_decode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
              arr[0]),
    );
  }

  @protected
  FfiEsploraClient dco_decode_ffi_esplora_client(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiEsploraClient(
      opaque:
          dco_decode_RustOpaque_bdk_esploraesplora_clientBlockingClient(arr[0]),
    );
  }

  @protected
  FfiFullScanRequest dco_decode_ffi_full_scan_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiFullScanRequest(
      field0:
          dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
              arr[0]),
    );
  }

  @protected
  FfiFullScanRequestBuilder dco_decode_ffi_full_scan_request_builder(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiFullScanRequestBuilder(
      field0:
          dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
              arr[0]),
    );
  }

  @protected
  FfiMnemonic dco_decode_ffi_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiMnemonic(
      opaque: dco_decode_RustOpaque_bdk_walletkeysbip39Mnemonic(arr[0]),
    );
  }

  @protected
  FfiPsbt dco_decode_ffi_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiPsbt(
      opaque: dco_decode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(arr[0]),
    );
  }

  @protected
  FfiScriptBuf dco_decode_ffi_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiScriptBuf(
      bytes: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  FfiSyncRequest dco_decode_ffi_sync_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiSyncRequest(
      field0:
          dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
              arr[0]),
    );
  }

  @protected
  FfiSyncRequestBuilder dco_decode_ffi_sync_request_builder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiSyncRequestBuilder(
      field0:
          dco_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
              arr[0]),
    );
  }

  @protected
  FfiTransaction dco_decode_ffi_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiTransaction(
      opaque: dco_decode_RustOpaque_bdk_corebitcoinTransaction(arr[0]),
    );
  }

  @protected
  FfiUpdate dco_decode_ffi_update(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiUpdate(
      field0: dco_decode_RustOpaque_bdk_walletUpdate(arr[0]),
    );
  }

  @protected
  FfiWallet dco_decode_ffi_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiWallet(
      opaque:
          dco_decode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
              arr[0]),
    );
  }

  @protected
  FromScriptError dco_decode_from_script_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FromScriptError_UnrecognizedScript();
      case 1:
        return FromScriptError_WitnessProgram(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 2:
        return FromScriptError_WitnessVersion(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 3:
        return FromScriptError_OtherFromScriptErr();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  List<FfiCanonicalTx> dco_decode_list_ffi_canonical_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ffi_canonical_tx).toList();
  }

  @protected
  List<Uint8List> dco_decode_list_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_prim_u_8_strict).toList();
  }

  @protected
  List<LocalOutput> dco_decode_list_local_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_output).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(FfiScriptBuf, BigInt)> dco_decode_list_record_ffi_script_buf_u_64(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_ffi_script_buf_u_64)
        .toList();
  }

  @protected
  List<TxIn> dco_decode_list_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_in).toList();
  }

  @protected
  List<TxOut> dco_decode_list_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_out).toList();
  }

  @protected
  LoadWithPersistError dco_decode_load_with_persist_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LoadWithPersistError_Persist(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return LoadWithPersistError_InvalidChangeSet(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 2:
        return LoadWithPersistError_CouldNotLoad();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LocalOutput dco_decode_local_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalOutput(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out(arr[1]),
      keychain: dco_decode_keychain_kind(arr[2]),
      isSpent: dco_decode_bool(arr[3]),
    );
  }

  @protected
  LockTime dco_decode_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LockTime_Blocks(
          dco_decode_u_32(raw[1]),
        );
      case 1:
        return LockTime_Seconds(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  FeeRate? dco_decode_opt_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_fee_rate(raw);
  }

  @protected
  FfiCanonicalTx? dco_decode_opt_box_autoadd_ffi_canonical_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_canonical_tx(raw);
  }

  @protected
  FfiScriptBuf? dco_decode_opt_box_autoadd_ffi_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ffi_script_buf(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PsbtError dco_decode_psbt_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PsbtError_InvalidMagic();
      case 1:
        return PsbtError_MissingUtxo();
      case 2:
        return PsbtError_InvalidSeparator();
      case 3:
        return PsbtError_PsbtUtxoOutOfBounds();
      case 4:
        return PsbtError_InvalidKey(
          key: dco_decode_String(raw[1]),
        );
      case 5:
        return PsbtError_InvalidProprietaryKey();
      case 6:
        return PsbtError_DuplicateKey(
          key: dco_decode_String(raw[1]),
        );
      case 7:
        return PsbtError_UnsignedTxHasScriptSigs();
      case 8:
        return PsbtError_UnsignedTxHasScriptWitnesses();
      case 9:
        return PsbtError_MustHaveUnsignedTx();
      case 10:
        return PsbtError_NoMorePairs();
      case 11:
        return PsbtError_UnexpectedUnsignedTx();
      case 12:
        return PsbtError_NonStandardSighashType(
          sighash: dco_decode_u_32(raw[1]),
        );
      case 13:
        return PsbtError_InvalidHash(
          hash: dco_decode_String(raw[1]),
        );
      case 14:
        return PsbtError_InvalidPreimageHashPair();
      case 15:
        return PsbtError_CombineInconsistentKeySources(
          xpub: dco_decode_String(raw[1]),
        );
      case 16:
        return PsbtError_ConsensusEncoding(
          encodingError: dco_decode_String(raw[1]),
        );
      case 17:
        return PsbtError_NegativeFee();
      case 18:
        return PsbtError_FeeOverflow();
      case 19:
        return PsbtError_InvalidPublicKey(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 20:
        return PsbtError_InvalidSecp256k1PublicKey(
          secp256K1Error: dco_decode_String(raw[1]),
        );
      case 21:
        return PsbtError_InvalidXOnlyPublicKey();
      case 22:
        return PsbtError_InvalidEcdsaSignature(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 23:
        return PsbtError_InvalidTaprootSignature(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 24:
        return PsbtError_InvalidControlBlock();
      case 25:
        return PsbtError_InvalidLeafVersion();
      case 26:
        return PsbtError_Taproot();
      case 27:
        return PsbtError_TapTree(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 28:
        return PsbtError_XPubKey();
      case 29:
        return PsbtError_Version(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 30:
        return PsbtError_PartialDataConsumption();
      case 31:
        return PsbtError_Io(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 32:
        return PsbtError_OtherPsbtErr();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PsbtParseError dco_decode_psbt_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PsbtParseError_PsbtEncoding(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 1:
        return PsbtParseError_Base64Encoding(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (FfiScriptBuf, BigInt) dco_decode_record_ffi_script_buf_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_ffi_script_buf(arr[0]),
      dco_decode_u_64(arr[1]),
    );
  }

  @protected
  RequestBuilderError dco_decode_request_builder_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RequestBuilderError.values[raw as int];
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return SignOptions(
      trustWitnessUtxo: dco_decode_bool(arr[0]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[1]),
      allowAllSighashes: dco_decode_bool(arr[2]),
      removePartialSigs: dco_decode_bool(arr[3]),
      tryFinalize: dco_decode_bool(arr[4]),
      signWithTapInternalKey: dco_decode_bool(arr[5]),
      allowGrinding: dco_decode_bool(arr[6]),
    );
  }

  @protected
  SignerError dco_decode_signer_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SignerError_MissingKey();
      case 1:
        return SignerError_InvalidKey();
      case 2:
        return SignerError_UserCanceled();
      case 3:
        return SignerError_InputIndexOutOfRange();
      case 4:
        return SignerError_MissingNonWitnessUtxo();
      case 5:
        return SignerError_InvalidNonWitnessUtxo();
      case 6:
        return SignerError_MissingWitnessUtxo();
      case 7:
        return SignerError_MissingWitnessScript();
      case 8:
        return SignerError_MissingHdKeypath();
      case 9:
        return SignerError_NonStandardSighash();
      case 10:
        return SignerError_InvalidSighash();
      case 11:
        return SignerError_SighashP2wpkh(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 12:
        return SignerError_SighashTaproot(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 13:
        return SignerError_TxInputsIndexError(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 14:
        return SignerError_MiniscriptPsbt(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 15:
        return SignerError_External(
          errorMessage: dco_decode_String(raw[1]),
        );
      case 16:
        return SignerError_Psbt(
          errorMessage: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SqliteError dco_decode_sqlite_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SqliteError_Sqlite(
          rusqliteError: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TransactionError dco_decode_transaction_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TransactionError_Io();
      case 1:
        return TransactionError_OversizedVectorAllocation();
      case 2:
        return TransactionError_InvalidChecksum(
          expected: dco_decode_String(raw[1]),
          actual: dco_decode_String(raw[2]),
        );
      case 3:
        return TransactionError_NonMinimalVarInt();
      case 4:
        return TransactionError_ParseFailed();
      case 5:
        return TransactionError_UnsupportedSegwitFlag(
          flag: dco_decode_u_8(raw[1]),
        );
      case 6:
        return TransactionError_OtherTransactionErr();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TxIn dco_decode_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_ffi_script_buf(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  TxOut dco_decode_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_ffi_script_buf(arr[1]),
    );
  }

  @protected
  TxidParseError dco_decode_txid_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TxidParseError_InvalidTxid(
          txid: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Address sse_decode_RustOpaque_bdk_corebitcoinAddress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Transaction sse_decode_RustOpaque_bdk_corebitcoinTransaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TransactionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkElectrumClientClient
      sse_decode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkElectrumClientClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlockingClient sse_decode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlockingClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Update sse_decode_RustOpaque_bdk_walletUpdate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UpdateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DerivationPath sse_decode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DerivationPathImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedDescriptor
      sse_decode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedDescriptorImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DescriptorPublicKey sse_decode_RustOpaque_bdk_walletkeysDescriptorPublicKey(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DescriptorPublicKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DescriptorSecretKey sse_decode_RustOpaque_bdk_walletkeysDescriptorSecretKey(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DescriptorSecretKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  KeyMap sse_decode_RustOpaque_bdk_walletkeysKeyMap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeyMapImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Mnemonic sse_decode_RustOpaque_bdk_walletkeysbip39Mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MnemonicImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexOptionFullScanRequestBuilderKeychainKind
      sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexOptionFullScanRequestBuilderKeychainKindImpl
        .frbInternalSseDecode(
            sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexOptionFullScanRequestKeychainKind
      sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexOptionFullScanRequestKeychainKindImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexOptionSyncRequestBuilderKeychainKindU32
      sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexOptionSyncRequestBuilderKeychainKindU32Impl
        .frbInternalSseDecode(
            sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexOptionSyncRequestKeychainKindU32
      sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexOptionSyncRequestKeychainKindU32Impl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexPsbt sse_decode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexPsbtImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexPersistedWalletConnection
      sse_decode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexPersistedWalletConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexConnection
      sse_decode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_address = sse_decode_ffi_address(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    return AddressInfo(
        index: var_index, address: var_address, keychain: var_keychain);
  }

  @protected
  AddressParseError sse_decode_address_parse_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressParseError_Base58();
      case 1:
        return AddressParseError_Bech32();
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return AddressParseError_WitnessVersion(errorMessage: var_errorMessage);
      case 3:
        var var_errorMessage = sse_decode_String(deserializer);
        return AddressParseError_WitnessProgram(errorMessage: var_errorMessage);
      case 4:
        return AddressParseError_UnknownHrp();
      case 5:
        return AddressParseError_LegacyAddressTooLong();
      case 6:
        return AddressParseError_InvalidBase58PayloadLength();
      case 7:
        return AddressParseError_InvalidLegacyPrefix();
      case 8:
        return AddressParseError_NetworkValidation();
      case 9:
        return AddressParseError_OtherAddressParseErr();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
        immature: var_immature,
        trustedPending: var_trustedPending,
        untrustedPending: var_untrustedPending,
        confirmed: var_confirmed,
        spendable: var_spendable,
        total: var_total);
  }

  @protected
  Bip32Error sse_decode_bip_32_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Bip32Error_CannotDeriveFromHardenedKey();
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return Bip32Error_Secp256k1(errorMessage: var_errorMessage);
      case 2:
        var var_childNumber = sse_decode_u_32(deserializer);
        return Bip32Error_InvalidChildNumber(childNumber: var_childNumber);
      case 3:
        return Bip32Error_InvalidChildNumberFormat();
      case 4:
        return Bip32Error_InvalidDerivationPathFormat();
      case 5:
        var var_version = sse_decode_String(deserializer);
        return Bip32Error_UnknownVersion(version: var_version);
      case 6:
        var var_length = sse_decode_u_32(deserializer);
        return Bip32Error_WrongExtendedKeyLength(length: var_length);
      case 7:
        var var_errorMessage = sse_decode_String(deserializer);
        return Bip32Error_Base58(errorMessage: var_errorMessage);
      case 8:
        var var_errorMessage = sse_decode_String(deserializer);
        return Bip32Error_Hex(errorMessage: var_errorMessage);
      case 9:
        var var_length = sse_decode_u_32(deserializer);
        return Bip32Error_InvalidPublicKeyHexLength(length: var_length);
      case 10:
        var var_errorMessage = sse_decode_String(deserializer);
        return Bip32Error_UnknownError(errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Bip39Error sse_decode_bip_39_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_wordCount = sse_decode_u_64(deserializer);
        return Bip39Error_BadWordCount(wordCount: var_wordCount);
      case 1:
        var var_index = sse_decode_u_64(deserializer);
        return Bip39Error_UnknownWord(index: var_index);
      case 2:
        var var_bitCount = sse_decode_u_64(deserializer);
        return Bip39Error_BadEntropyBitCount(bitCount: var_bitCount);
      case 3:
        return Bip39Error_InvalidChecksum();
      case 4:
        var var_languages = sse_decode_String(deserializer);
        return Bip39Error_AmbiguousLanguages(languages: var_languages);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BlockId sse_decode_block_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_hash = sse_decode_String(deserializer);
    return BlockId(height: var_height, hash: var_hash);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  ConfirmationBlockTime sse_decode_box_autoadd_confirmation_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_confirmation_block_time(deserializer));
  }

  @protected
  FeeRate sse_decode_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fee_rate(deserializer));
  }

  @protected
  FfiAddress sse_decode_box_autoadd_ffi_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_address(deserializer));
  }

  @protected
  FfiCanonicalTx sse_decode_box_autoadd_ffi_canonical_tx(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_canonical_tx(deserializer));
  }

  @protected
  FfiConnection sse_decode_box_autoadd_ffi_connection(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_connection(deserializer));
  }

  @protected
  FfiDerivationPath sse_decode_box_autoadd_ffi_derivation_path(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_derivation_path(deserializer));
  }

  @protected
  FfiDescriptor sse_decode_box_autoadd_ffi_descriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_descriptor(deserializer));
  }

  @protected
  FfiDescriptorPublicKey sse_decode_box_autoadd_ffi_descriptor_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_descriptor_public_key(deserializer));
  }

  @protected
  FfiDescriptorSecretKey sse_decode_box_autoadd_ffi_descriptor_secret_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_descriptor_secret_key(deserializer));
  }

  @protected
  FfiElectrumClient sse_decode_box_autoadd_ffi_electrum_client(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_electrum_client(deserializer));
  }

  @protected
  FfiEsploraClient sse_decode_box_autoadd_ffi_esplora_client(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_esplora_client(deserializer));
  }

  @protected
  FfiFullScanRequest sse_decode_box_autoadd_ffi_full_scan_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_full_scan_request(deserializer));
  }

  @protected
  FfiFullScanRequestBuilder
      sse_decode_box_autoadd_ffi_full_scan_request_builder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_full_scan_request_builder(deserializer));
  }

  @protected
  FfiMnemonic sse_decode_box_autoadd_ffi_mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_mnemonic(deserializer));
  }

  @protected
  FfiPsbt sse_decode_box_autoadd_ffi_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_psbt(deserializer));
  }

  @protected
  FfiScriptBuf sse_decode_box_autoadd_ffi_script_buf(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_script_buf(deserializer));
  }

  @protected
  FfiSyncRequest sse_decode_box_autoadd_ffi_sync_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_sync_request(deserializer));
  }

  @protected
  FfiSyncRequestBuilder sse_decode_box_autoadd_ffi_sync_request_builder(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_sync_request_builder(deserializer));
  }

  @protected
  FfiTransaction sse_decode_box_autoadd_ffi_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_transaction(deserializer));
  }

  @protected
  FfiUpdate sse_decode_box_autoadd_ffi_update(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_update(deserializer));
  }

  @protected
  FfiWallet sse_decode_box_autoadd_ffi_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_wallet(deserializer));
  }

  @protected
  LockTime sse_decode_box_autoadd_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lock_time(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  CalculateFeeError sse_decode_calculate_fee_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return CalculateFeeError_Generic(errorMessage: var_errorMessage);
      case 1:
        var var_outPoints = sse_decode_list_out_point(deserializer);
        return CalculateFeeError_MissingTxOut(outPoints: var_outPoints);
      case 2:
        var var_amount = sse_decode_String(deserializer);
        return CalculateFeeError_NegativeFee(amount: var_amount);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  CannotConnectError sse_decode_cannot_connect_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_height = sse_decode_u_32(deserializer);
        return CannotConnectError_Include(height: var_height);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChainPosition sse_decode_chain_position(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_confirmationBlockTime =
            sse_decode_box_autoadd_confirmation_block_time(deserializer);
        return ChainPosition_Confirmed(
            confirmationBlockTime: var_confirmationBlockTime);
      case 1:
        var var_timestamp = sse_decode_u_64(deserializer);
        return ChainPosition_Unconfirmed(timestamp: var_timestamp);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  ConfirmationBlockTime sse_decode_confirmation_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockId = sse_decode_block_id(deserializer);
    var var_confirmationTime = sse_decode_u_64(deserializer);
    return ConfirmationBlockTime(
        blockId: var_blockId, confirmationTime: var_confirmationTime);
  }

  @protected
  CreateTxError sse_decode_create_tx_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_Generic(errorMessage: var_errorMessage);
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_Descriptor(errorMessage: var_errorMessage);
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_Policy(errorMessage: var_errorMessage);
      case 3:
        var var_kind = sse_decode_String(deserializer);
        return CreateTxError_SpendingPolicyRequired(kind: var_kind);
      case 4:
        return CreateTxError_Version0();
      case 5:
        return CreateTxError_Version1Csv();
      case 6:
        var var_requested = sse_decode_String(deserializer);
        var var_required_ = sse_decode_String(deserializer);
        return CreateTxError_LockTime(
            requested: var_requested, required_: var_required_);
      case 7:
        return CreateTxError_RbfSequence();
      case 8:
        var var_rbf = sse_decode_String(deserializer);
        var var_csv = sse_decode_String(deserializer);
        return CreateTxError_RbfSequenceCsv(rbf: var_rbf, csv: var_csv);
      case 9:
        var var_required_ = sse_decode_String(deserializer);
        return CreateTxError_FeeTooLow(required_: var_required_);
      case 10:
        var var_required_ = sse_decode_String(deserializer);
        return CreateTxError_FeeRateTooLow(required_: var_required_);
      case 11:
        return CreateTxError_NoUtxosSelected();
      case 12:
        var var_index = sse_decode_u_64(deserializer);
        return CreateTxError_OutputBelowDustLimit(index: var_index);
      case 13:
        return CreateTxError_ChangePolicyDescriptor();
      case 14:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_CoinSelection(errorMessage: var_errorMessage);
      case 15:
        var var_needed = sse_decode_u_64(deserializer);
        var var_available = sse_decode_u_64(deserializer);
        return CreateTxError_InsufficientFunds(
            needed: var_needed, available: var_available);
      case 16:
        return CreateTxError_NoRecipients();
      case 17:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_Psbt(errorMessage: var_errorMessage);
      case 18:
        var var_key = sse_decode_String(deserializer);
        return CreateTxError_MissingKeyOrigin(key: var_key);
      case 19:
        var var_outpoint = sse_decode_String(deserializer);
        return CreateTxError_UnknownUtxo(outpoint: var_outpoint);
      case 20:
        var var_outpoint = sse_decode_String(deserializer);
        return CreateTxError_MissingNonWitnessUtxo(outpoint: var_outpoint);
      case 21:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateTxError_MiniscriptPsbt(errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  CreateWithPersistError sse_decode_create_with_persist_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateWithPersistError_Persist(errorMessage: var_errorMessage);
      case 1:
        return CreateWithPersistError_DataAlreadyExists();
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return CreateWithPersistError_Descriptor(
            errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DescriptorError sse_decode_descriptor_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_MissingPrivateData();
      case 2:
        return DescriptorError_InvalidDescriptorChecksum();
      case 3:
        return DescriptorError_HardenedDerivationXpub();
      case 4:
        return DescriptorError_MultiPath();
      case 5:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Key(errorMessage: var_errorMessage);
      case 6:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Generic(errorMessage: var_errorMessage);
      case 7:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Policy(errorMessage: var_errorMessage);
      case 8:
        var var_char = sse_decode_String(deserializer);
        return DescriptorError_InvalidDescriptorCharacter(char: var_char);
      case 9:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Bip32(errorMessage: var_errorMessage);
      case 10:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Base58(errorMessage: var_errorMessage);
      case 11:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Pk(errorMessage: var_errorMessage);
      case 12:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Miniscript(errorMessage: var_errorMessage);
      case 13:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorError_Hex(errorMessage: var_errorMessage);
      case 14:
        return DescriptorError_ExternalAndInternalAreTheSame();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DescriptorKeyError sse_decode_descriptor_key_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorKeyError_Parse(errorMessage: var_errorMessage);
      case 1:
        return DescriptorKeyError_InvalidKeyType();
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return DescriptorKeyError_Bip32(errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ElectrumError sse_decode_electrum_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_IOError(errorMessage: var_errorMessage);
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_Json(errorMessage: var_errorMessage);
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_Hex(errorMessage: var_errorMessage);
      case 3:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_Protocol(errorMessage: var_errorMessage);
      case 4:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_Bitcoin(errorMessage: var_errorMessage);
      case 5:
        return ElectrumError_AlreadySubscribed();
      case 6:
        return ElectrumError_NotSubscribed();
      case 7:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_InvalidResponse(errorMessage: var_errorMessage);
      case 8:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_Message(errorMessage: var_errorMessage);
      case 9:
        var var_domain = sse_decode_String(deserializer);
        return ElectrumError_InvalidDNSNameError(domain: var_domain);
      case 10:
        return ElectrumError_MissingDomain();
      case 11:
        return ElectrumError_AllAttemptsErrored();
      case 12:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_SharedIOError(errorMessage: var_errorMessage);
      case 13:
        return ElectrumError_CouldntLockReader();
      case 14:
        return ElectrumError_Mpsc();
      case 15:
        var var_errorMessage = sse_decode_String(deserializer);
        return ElectrumError_CouldNotCreateConnection(
            errorMessage: var_errorMessage);
      case 16:
        return ElectrumError_RequestAlreadyConsumed();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EsploraError sse_decode_esplora_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_Minreq(errorMessage: var_errorMessage);
      case 1:
        var var_status = sse_decode_u_16(deserializer);
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_HttpResponse(
            status: var_status, errorMessage: var_errorMessage);
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_Parsing(errorMessage: var_errorMessage);
      case 3:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_StatusCode(errorMessage: var_errorMessage);
      case 4:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_BitcoinEncoding(errorMessage: var_errorMessage);
      case 5:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_HexToArray(errorMessage: var_errorMessage);
      case 6:
        var var_errorMessage = sse_decode_String(deserializer);
        return EsploraError_HexToBytes(errorMessage: var_errorMessage);
      case 7:
        return EsploraError_TransactionNotFound();
      case 8:
        var var_height = sse_decode_u_32(deserializer);
        return EsploraError_HeaderHeightNotFound(height: var_height);
      case 9:
        return EsploraError_HeaderHashNotFound();
      case 10:
        var var_name = sse_decode_String(deserializer);
        return EsploraError_InvalidHttpHeaderName(name: var_name);
      case 11:
        var var_value = sse_decode_String(deserializer);
        return EsploraError_InvalidHttpHeaderValue(value: var_value);
      case 12:
        return EsploraError_RequestAlreadyConsumed();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ExtractTxError sse_decode_extract_tx_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_feeRate = sse_decode_u_64(deserializer);
        return ExtractTxError_AbsurdFeeRate(feeRate: var_feeRate);
      case 1:
        return ExtractTxError_MissingInputValue();
      case 2:
        return ExtractTxError_SendingTooMuch();
      case 3:
        return ExtractTxError_OtherExtractTxErr();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FeeRate sse_decode_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_satKwu = sse_decode_u_64(deserializer);
    return FeeRate(satKwu: var_satKwu);
  }

  @protected
  FfiAddress sse_decode_ffi_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_RustOpaque_bdk_corebitcoinAddress(deserializer);
    return FfiAddress(field0: var_field0);
  }

  @protected
  FfiCanonicalTx sse_decode_ffi_canonical_tx(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transaction = sse_decode_ffi_transaction(deserializer);
    var var_chainPosition = sse_decode_chain_position(deserializer);
    return FfiCanonicalTx(
        transaction: var_transaction, chainPosition: var_chainPosition);
  }

  @protected
  FfiConnection sse_decode_ffi_connection(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
            deserializer);
    return FfiConnection(field0: var_field0);
  }

  @protected
  FfiDerivationPath sse_decode_ffi_derivation_path(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque = sse_decode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
        deserializer);
    return FfiDerivationPath(opaque: var_opaque);
  }

  @protected
  FfiDescriptor sse_decode_ffi_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_extendedDescriptor =
        sse_decode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
            deserializer);
    var var_keyMap = sse_decode_RustOpaque_bdk_walletkeysKeyMap(deserializer);
    return FfiDescriptor(
        extendedDescriptor: var_extendedDescriptor, keyMap: var_keyMap);
  }

  @protected
  FfiDescriptorPublicKey sse_decode_ffi_descriptor_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_walletkeysDescriptorPublicKey(deserializer);
    return FfiDescriptorPublicKey(opaque: var_opaque);
  }

  @protected
  FfiDescriptorSecretKey sse_decode_ffi_descriptor_secret_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_walletkeysDescriptorSecretKey(deserializer);
    return FfiDescriptorSecretKey(opaque: var_opaque);
  }

  @protected
  FfiElectrumClient sse_decode_ffi_electrum_client(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
            deserializer);
    return FfiElectrumClient(opaque: var_opaque);
  }

  @protected
  FfiEsploraClient sse_decode_ffi_esplora_client(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
            deserializer);
    return FfiEsploraClient(opaque: var_opaque);
  }

  @protected
  FfiFullScanRequest sse_decode_ffi_full_scan_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
            deserializer);
    return FfiFullScanRequest(field0: var_field0);
  }

  @protected
  FfiFullScanRequestBuilder sse_decode_ffi_full_scan_request_builder(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
            deserializer);
    return FfiFullScanRequestBuilder(field0: var_field0);
  }

  @protected
  FfiMnemonic sse_decode_ffi_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_walletkeysbip39Mnemonic(deserializer);
    return FfiMnemonic(opaque: var_opaque);
  }

  @protected
  FfiPsbt sse_decode_ffi_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(deserializer);
    return FfiPsbt(opaque: var_opaque);
  }

  @protected
  FfiScriptBuf sse_decode_ffi_script_buf(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bytes = sse_decode_list_prim_u_8_strict(deserializer);
    return FfiScriptBuf(bytes: var_bytes);
  }

  @protected
  FfiSyncRequest sse_decode_ffi_sync_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
            deserializer);
    return FfiSyncRequest(field0: var_field0);
  }

  @protected
  FfiSyncRequestBuilder sse_decode_ffi_sync_request_builder(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
            deserializer);
    return FfiSyncRequestBuilder(field0: var_field0);
  }

  @protected
  FfiTransaction sse_decode_ffi_transaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_bdk_corebitcoinTransaction(deserializer);
    return FfiTransaction(opaque: var_opaque);
  }

  @protected
  FfiUpdate sse_decode_ffi_update(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_RustOpaque_bdk_walletUpdate(deserializer);
    return FfiUpdate(field0: var_field0);
  }

  @protected
  FfiWallet sse_decode_ffi_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
            deserializer);
    return FfiWallet(opaque: var_opaque);
  }

  @protected
  FromScriptError sse_decode_from_script_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FromScriptError_UnrecognizedScript();
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return FromScriptError_WitnessProgram(errorMessage: var_errorMessage);
      case 2:
        var var_errorMessage = sse_decode_String(deserializer);
        return FromScriptError_WitnessVersion(errorMessage: var_errorMessage);
      case 3:
        return FromScriptError_OtherFromScriptErr();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  List<FfiCanonicalTx> sse_decode_list_ffi_canonical_tx(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FfiCanonicalTx>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ffi_canonical_tx(deserializer));
    }
    return ans_;
  }

  @protected
  List<Uint8List> sse_decode_list_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Uint8List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_u_8_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalOutput> sse_decode_list_local_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalOutput>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_output(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(FfiScriptBuf, BigInt)> sse_decode_list_record_ffi_script_buf_u_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(FfiScriptBuf, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_ffi_script_buf_u_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxIn> sse_decode_list_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOut> sse_decode_list_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  LoadWithPersistError sse_decode_load_with_persist_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return LoadWithPersistError_Persist(errorMessage: var_errorMessage);
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return LoadWithPersistError_InvalidChangeSet(
            errorMessage: var_errorMessage);
      case 2:
        return LoadWithPersistError_CouldNotLoad();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LocalOutput sse_decode_local_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    return LocalOutput(
        outpoint: var_outpoint,
        txout: var_txout,
        keychain: var_keychain,
        isSpent: var_isSpent);
  }

  @protected
  LockTime sse_decode_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Blocks(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Seconds(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FeeRate? sse_decode_opt_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fee_rate(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiCanonicalTx? sse_decode_opt_box_autoadd_ffi_canonical_tx(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_canonical_tx(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FfiScriptBuf? sse_decode_opt_box_autoadd_ffi_script_buf(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ffi_script_buf(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PsbtError sse_decode_psbt_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PsbtError_InvalidMagic();
      case 1:
        return PsbtError_MissingUtxo();
      case 2:
        return PsbtError_InvalidSeparator();
      case 3:
        return PsbtError_PsbtUtxoOutOfBounds();
      case 4:
        var var_key = sse_decode_String(deserializer);
        return PsbtError_InvalidKey(key: var_key);
      case 5:
        return PsbtError_InvalidProprietaryKey();
      case 6:
        var var_key = sse_decode_String(deserializer);
        return PsbtError_DuplicateKey(key: var_key);
      case 7:
        return PsbtError_UnsignedTxHasScriptSigs();
      case 8:
        return PsbtError_UnsignedTxHasScriptWitnesses();
      case 9:
        return PsbtError_MustHaveUnsignedTx();
      case 10:
        return PsbtError_NoMorePairs();
      case 11:
        return PsbtError_UnexpectedUnsignedTx();
      case 12:
        var var_sighash = sse_decode_u_32(deserializer);
        return PsbtError_NonStandardSighashType(sighash: var_sighash);
      case 13:
        var var_hash = sse_decode_String(deserializer);
        return PsbtError_InvalidHash(hash: var_hash);
      case 14:
        return PsbtError_InvalidPreimageHashPair();
      case 15:
        var var_xpub = sse_decode_String(deserializer);
        return PsbtError_CombineInconsistentKeySources(xpub: var_xpub);
      case 16:
        var var_encodingError = sse_decode_String(deserializer);
        return PsbtError_ConsensusEncoding(encodingError: var_encodingError);
      case 17:
        return PsbtError_NegativeFee();
      case 18:
        return PsbtError_FeeOverflow();
      case 19:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_InvalidPublicKey(errorMessage: var_errorMessage);
      case 20:
        var var_secp256K1Error = sse_decode_String(deserializer);
        return PsbtError_InvalidSecp256k1PublicKey(
            secp256K1Error: var_secp256K1Error);
      case 21:
        return PsbtError_InvalidXOnlyPublicKey();
      case 22:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_InvalidEcdsaSignature(errorMessage: var_errorMessage);
      case 23:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_InvalidTaprootSignature(
            errorMessage: var_errorMessage);
      case 24:
        return PsbtError_InvalidControlBlock();
      case 25:
        return PsbtError_InvalidLeafVersion();
      case 26:
        return PsbtError_Taproot();
      case 27:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_TapTree(errorMessage: var_errorMessage);
      case 28:
        return PsbtError_XPubKey();
      case 29:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_Version(errorMessage: var_errorMessage);
      case 30:
        return PsbtError_PartialDataConsumption();
      case 31:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtError_Io(errorMessage: var_errorMessage);
      case 32:
        return PsbtError_OtherPsbtErr();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PsbtParseError sse_decode_psbt_parse_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtParseError_PsbtEncoding(errorMessage: var_errorMessage);
      case 1:
        var var_errorMessage = sse_decode_String(deserializer);
        return PsbtParseError_Base64Encoding(errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (FfiScriptBuf, BigInt) sse_decode_record_ffi_script_buf_u_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_ffi_script_buf(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RequestBuilderError sse_decode_request_builder_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RequestBuilderError.values[inner];
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
        trustWitnessUtxo: var_trustWitnessUtxo,
        assumeHeight: var_assumeHeight,
        allowAllSighashes: var_allowAllSighashes,
        removePartialSigs: var_removePartialSigs,
        tryFinalize: var_tryFinalize,
        signWithTapInternalKey: var_signWithTapInternalKey,
        allowGrinding: var_allowGrinding);
  }

  @protected
  SignerError sse_decode_signer_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return SignerError_MissingKey();
      case 1:
        return SignerError_InvalidKey();
      case 2:
        return SignerError_UserCanceled();
      case 3:
        return SignerError_InputIndexOutOfRange();
      case 4:
        return SignerError_MissingNonWitnessUtxo();
      case 5:
        return SignerError_InvalidNonWitnessUtxo();
      case 6:
        return SignerError_MissingWitnessUtxo();
      case 7:
        return SignerError_MissingWitnessScript();
      case 8:
        return SignerError_MissingHdKeypath();
      case 9:
        return SignerError_NonStandardSighash();
      case 10:
        return SignerError_InvalidSighash();
      case 11:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_SighashP2wpkh(errorMessage: var_errorMessage);
      case 12:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_SighashTaproot(errorMessage: var_errorMessage);
      case 13:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_TxInputsIndexError(errorMessage: var_errorMessage);
      case 14:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_MiniscriptPsbt(errorMessage: var_errorMessage);
      case 15:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_External(errorMessage: var_errorMessage);
      case 16:
        var var_errorMessage = sse_decode_String(deserializer);
        return SignerError_Psbt(errorMessage: var_errorMessage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SqliteError sse_decode_sqlite_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_rusqliteError = sse_decode_String(deserializer);
        return SqliteError_Sqlite(rusqliteError: var_rusqliteError);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TransactionError sse_decode_transaction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TransactionError_Io();
      case 1:
        return TransactionError_OversizedVectorAllocation();
      case 2:
        var var_expected = sse_decode_String(deserializer);
        var var_actual = sse_decode_String(deserializer);
        return TransactionError_InvalidChecksum(
            expected: var_expected, actual: var_actual);
      case 3:
        return TransactionError_NonMinimalVarInt();
      case 4:
        return TransactionError_ParseFailed();
      case 5:
        var var_flag = sse_decode_u_8(deserializer);
        return TransactionError_UnsupportedSegwitFlag(flag: var_flag);
      case 6:
        return TransactionError_OtherTransactionErr();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TxIn sse_decode_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_ffi_script_buf(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_list_prim_u_8_strict(deserializer);
    return TxIn(
        previousOutput: var_previousOutput,
        scriptSig: var_scriptSig,
        sequence: var_sequence,
        witness: var_witness);
  }

  @protected
  TxOut sse_decode_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_ffi_script_buf(deserializer);
    return TxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  TxidParseError sse_decode_txid_parse_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_txid = sse_decode_String(deserializer);
        return TxidParseError_InvalidTxid(txid: var_txid);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  PlatformPointer
      cst_encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
          FutureOr<void> Function(FfiScriptBuf, BigInt) raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_DartOpaque(
        encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
            raw));
  }

  @protected
  PlatformPointer
      cst_encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
          FutureOr<void> Function(KeychainKind, int, FfiScriptBuf) raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_DartOpaque(
        encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
            raw));
  }

  @protected
  PlatformPointer cst_encode_DartOpaque(Object raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return encodeDartOpaque(
        raw, portManager.dartHandlerPort, generalizedFrbRustBinding);
  }

  @protected
  int cst_encode_RustOpaque_bdk_corebitcoinAddress(Address raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as AddressImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_corebitcoinTransaction(Transaction raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as TransactionImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
      BdkElectrumClientClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BdkElectrumClientClientImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
      BlockingClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BlockingClientImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletUpdate(Update raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as UpdateImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
      DerivationPath raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as DerivationPathImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
      ExtendedDescriptor raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ExtendedDescriptorImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletkeysDescriptorPublicKey(
      DescriptorPublicKey raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as DescriptorPublicKeyImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletkeysDescriptorSecretKey(
      DescriptorSecretKey raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as DescriptorSecretKeyImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletkeysKeyMap(KeyMap raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as KeyMapImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdk_walletkeysbip39Mnemonic(Mnemonic raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MnemonicImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
      MutexOptionFullScanRequestBuilderKeychainKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexOptionFullScanRequestBuilderKeychainKindImpl)
        .frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
      MutexOptionFullScanRequestKeychainKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexOptionFullScanRequestKeychainKindImpl)
        .frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
      MutexOptionSyncRequestBuilderKeychainKindU32 raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexOptionSyncRequestBuilderKeychainKindU32Impl)
        .frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
      MutexOptionSyncRequestKeychainKindU32 raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexOptionSyncRequestKeychainKindU32Impl)
        .frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(MutexPsbt raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexPsbtImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
      MutexPersistedWalletConnection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexPersistedWalletConnectionImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
      MutexConnection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as MutexConnectionImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_change_spend_policy(ChangeSpendPolicy raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_keychain_kind(KeychainKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_request_builder_error(RequestBuilderError raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_word_count(WordCount raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
      FutureOr<void> Function(FfiScriptBuf, BigInt) self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_ffi_script_buf_u_64_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
          FutureOr<void> Function(KeychainKind, int, FfiScriptBuf) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_keychain_kind_u_32_ffi_script_buf_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
        PlatformPointerUtil.ptrToPlatformInt64(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_corebitcoinAddress(
      Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as AddressImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_corebitcoinTransaction(
      Transaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as TransactionImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
          BdkElectrumClientClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BdkElectrumClientClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
      BlockingClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BlockingClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletUpdate(
      Update self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UpdateImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
      DerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DerivationPathImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
      ExtendedDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedDescriptorImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletkeysDescriptorPublicKey(
      DescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DescriptorPublicKeyImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletkeysDescriptorSecretKey(
      DescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DescriptorSecretKeyImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletkeysKeyMap(
      KeyMap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as KeyMapImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdk_walletkeysbip39Mnemonic(
      Mnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MnemonicImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
          MutexOptionFullScanRequestBuilderKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexOptionFullScanRequestBuilderKeychainKindImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
          MutexOptionFullScanRequestKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexOptionFullScanRequestKeychainKindImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
          MutexOptionSyncRequestBuilderKeychainKindU32 self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexOptionSyncRequestBuilderKeychainKindU32Impl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
          MutexOptionSyncRequestKeychainKindU32 self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexOptionSyncRequestKeychainKindU32Impl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
      MutexPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexPsbtImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
          MutexPersistedWalletConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexPersistedWalletConnectionImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
      MutexConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MutexConnectionImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_ffi_address(self.address, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
  }

  @protected
  void sse_encode_address_parse_error(
      AddressParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressParseError_Base58():
        sse_encode_i_32(0, serializer);
      case AddressParseError_Bech32():
        sse_encode_i_32(1, serializer);
      case AddressParseError_WitnessVersion(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      case AddressParseError_WitnessProgram(errorMessage: final errorMessage):
        sse_encode_i_32(3, serializer);
        sse_encode_String(errorMessage, serializer);
      case AddressParseError_UnknownHrp():
        sse_encode_i_32(4, serializer);
      case AddressParseError_LegacyAddressTooLong():
        sse_encode_i_32(5, serializer);
      case AddressParseError_InvalidBase58PayloadLength():
        sse_encode_i_32(6, serializer);
      case AddressParseError_InvalidLegacyPrefix():
        sse_encode_i_32(7, serializer);
      case AddressParseError_NetworkValidation():
        sse_encode_i_32(8, serializer);
      case AddressParseError_OtherAddressParseErr():
        sse_encode_i_32(9, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_bip_32_error(Bip32Error self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Bip32Error_CannotDeriveFromHardenedKey():
        sse_encode_i_32(0, serializer);
      case Bip32Error_Secp256k1(errorMessage: final errorMessage):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      case Bip32Error_InvalidChildNumber(childNumber: final childNumber):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(childNumber, serializer);
      case Bip32Error_InvalidChildNumberFormat():
        sse_encode_i_32(3, serializer);
      case Bip32Error_InvalidDerivationPathFormat():
        sse_encode_i_32(4, serializer);
      case Bip32Error_UnknownVersion(version: final version):
        sse_encode_i_32(5, serializer);
        sse_encode_String(version, serializer);
      case Bip32Error_WrongExtendedKeyLength(length: final length):
        sse_encode_i_32(6, serializer);
        sse_encode_u_32(length, serializer);
      case Bip32Error_Base58(errorMessage: final errorMessage):
        sse_encode_i_32(7, serializer);
        sse_encode_String(errorMessage, serializer);
      case Bip32Error_Hex(errorMessage: final errorMessage):
        sse_encode_i_32(8, serializer);
        sse_encode_String(errorMessage, serializer);
      case Bip32Error_InvalidPublicKeyHexLength(length: final length):
        sse_encode_i_32(9, serializer);
        sse_encode_u_32(length, serializer);
      case Bip32Error_UnknownError(errorMessage: final errorMessage):
        sse_encode_i_32(10, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_bip_39_error(Bip39Error self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Bip39Error_BadWordCount(wordCount: final wordCount):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(wordCount, serializer);
      case Bip39Error_UnknownWord(index: final index):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(index, serializer);
      case Bip39Error_BadEntropyBitCount(bitCount: final bitCount):
        sse_encode_i_32(2, serializer);
        sse_encode_u_64(bitCount, serializer);
      case Bip39Error_InvalidChecksum():
        sse_encode_i_32(3, serializer);
      case Bip39Error_AmbiguousLanguages(languages: final languages):
        sse_encode_i_32(4, serializer);
        sse_encode_String(languages, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_block_id(BlockId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_String(self.hash, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_confirmation_block_time(
      ConfirmationBlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_confirmation_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fee_rate(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_address(
      FfiAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_canonical_tx(
      FfiCanonicalTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_canonical_tx(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_connection(
      FfiConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_connection(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_derivation_path(
      FfiDerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_derivation_path(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_descriptor(
      FfiDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_descriptor(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_descriptor_public_key(
      FfiDescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_descriptor_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_descriptor_secret_key(
      FfiDescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_descriptor_secret_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_electrum_client(
      FfiElectrumClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_electrum_client(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_esplora_client(
      FfiEsploraClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_esplora_client(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_full_scan_request(
      FfiFullScanRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_full_scan_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_full_scan_request_builder(
      FfiFullScanRequestBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_full_scan_request_builder(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_mnemonic(
      FfiMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_psbt(FfiPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_psbt(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_script_buf(
      FfiScriptBuf self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_script_buf(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_sync_request(
      FfiSyncRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_sync_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_sync_request_builder(
      FfiSyncRequestBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_sync_request_builder(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_transaction(
      FfiTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_transaction(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_update(
      FfiUpdate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_update(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_wallet(
      FfiWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_wallet(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lock_time(
      LockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lock_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
      RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
      SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_calculate_fee_error(
      CalculateFeeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CalculateFeeError_Generic(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case CalculateFeeError_MissingTxOut(outPoints: final outPoints):
        sse_encode_i_32(1, serializer);
        sse_encode_list_out_point(outPoints, serializer);
      case CalculateFeeError_NegativeFee(amount: final amount):
        sse_encode_i_32(2, serializer);
        sse_encode_String(amount, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_cannot_connect_error(
      CannotConnectError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CannotConnectError_Include(height: final height):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(height, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_chain_position(ChainPosition self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ChainPosition_Confirmed(
          confirmationBlockTime: final confirmationBlockTime
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_confirmation_block_time(
            confirmationBlockTime, serializer);
      case ChainPosition_Unconfirmed(timestamp: final timestamp):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(timestamp, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_change_spend_policy(
      ChangeSpendPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_confirmation_block_time(
      ConfirmationBlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_id(self.blockId, serializer);
    sse_encode_u_64(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_create_tx_error(
      CreateTxError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CreateTxError_Generic(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateTxError_Descriptor(errorMessage: final errorMessage):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateTxError_Policy(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateTxError_SpendingPolicyRequired(kind: final kind):
        sse_encode_i_32(3, serializer);
        sse_encode_String(kind, serializer);
      case CreateTxError_Version0():
        sse_encode_i_32(4, serializer);
      case CreateTxError_Version1Csv():
        sse_encode_i_32(5, serializer);
      case CreateTxError_LockTime(
          requested: final requested,
          required_: final required_
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_String(requested, serializer);
        sse_encode_String(required_, serializer);
      case CreateTxError_RbfSequence():
        sse_encode_i_32(7, serializer);
      case CreateTxError_RbfSequenceCsv(rbf: final rbf, csv: final csv):
        sse_encode_i_32(8, serializer);
        sse_encode_String(rbf, serializer);
        sse_encode_String(csv, serializer);
      case CreateTxError_FeeTooLow(required_: final required_):
        sse_encode_i_32(9, serializer);
        sse_encode_String(required_, serializer);
      case CreateTxError_FeeRateTooLow(required_: final required_):
        sse_encode_i_32(10, serializer);
        sse_encode_String(required_, serializer);
      case CreateTxError_NoUtxosSelected():
        sse_encode_i_32(11, serializer);
      case CreateTxError_OutputBelowDustLimit(index: final index):
        sse_encode_i_32(12, serializer);
        sse_encode_u_64(index, serializer);
      case CreateTxError_ChangePolicyDescriptor():
        sse_encode_i_32(13, serializer);
      case CreateTxError_CoinSelection(errorMessage: final errorMessage):
        sse_encode_i_32(14, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateTxError_InsufficientFunds(
          needed: final needed,
          available: final available
        ):
        sse_encode_i_32(15, serializer);
        sse_encode_u_64(needed, serializer);
        sse_encode_u_64(available, serializer);
      case CreateTxError_NoRecipients():
        sse_encode_i_32(16, serializer);
      case CreateTxError_Psbt(errorMessage: final errorMessage):
        sse_encode_i_32(17, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateTxError_MissingKeyOrigin(key: final key):
        sse_encode_i_32(18, serializer);
        sse_encode_String(key, serializer);
      case CreateTxError_UnknownUtxo(outpoint: final outpoint):
        sse_encode_i_32(19, serializer);
        sse_encode_String(outpoint, serializer);
      case CreateTxError_MissingNonWitnessUtxo(outpoint: final outpoint):
        sse_encode_i_32(20, serializer);
        sse_encode_String(outpoint, serializer);
      case CreateTxError_MiniscriptPsbt(errorMessage: final errorMessage):
        sse_encode_i_32(21, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_create_with_persist_error(
      CreateWithPersistError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CreateWithPersistError_Persist(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case CreateWithPersistError_DataAlreadyExists():
        sse_encode_i_32(1, serializer);
      case CreateWithPersistError_Descriptor(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_descriptor_error(
      DescriptorError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DescriptorError_InvalidHdKeyPath():
        sse_encode_i_32(0, serializer);
      case DescriptorError_MissingPrivateData():
        sse_encode_i_32(1, serializer);
      case DescriptorError_InvalidDescriptorChecksum():
        sse_encode_i_32(2, serializer);
      case DescriptorError_HardenedDerivationXpub():
        sse_encode_i_32(3, serializer);
      case DescriptorError_MultiPath():
        sse_encode_i_32(4, serializer);
      case DescriptorError_Key(errorMessage: final errorMessage):
        sse_encode_i_32(5, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Generic(errorMessage: final errorMessage):
        sse_encode_i_32(6, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Policy(errorMessage: final errorMessage):
        sse_encode_i_32(7, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_InvalidDescriptorCharacter(char: final char):
        sse_encode_i_32(8, serializer);
        sse_encode_String(char, serializer);
      case DescriptorError_Bip32(errorMessage: final errorMessage):
        sse_encode_i_32(9, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Base58(errorMessage: final errorMessage):
        sse_encode_i_32(10, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Pk(errorMessage: final errorMessage):
        sse_encode_i_32(11, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Miniscript(errorMessage: final errorMessage):
        sse_encode_i_32(12, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_Hex(errorMessage: final errorMessage):
        sse_encode_i_32(13, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorError_ExternalAndInternalAreTheSame():
        sse_encode_i_32(14, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_descriptor_key_error(
      DescriptorKeyError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DescriptorKeyError_Parse(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case DescriptorKeyError_InvalidKeyType():
        sse_encode_i_32(1, serializer);
      case DescriptorKeyError_Bip32(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_electrum_error(ElectrumError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ElectrumError_IOError(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_Json(errorMessage: final errorMessage):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_Hex(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_Protocol(errorMessage: final errorMessage):
        sse_encode_i_32(3, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_Bitcoin(errorMessage: final errorMessage):
        sse_encode_i_32(4, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_AlreadySubscribed():
        sse_encode_i_32(5, serializer);
      case ElectrumError_NotSubscribed():
        sse_encode_i_32(6, serializer);
      case ElectrumError_InvalidResponse(errorMessage: final errorMessage):
        sse_encode_i_32(7, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_Message(errorMessage: final errorMessage):
        sse_encode_i_32(8, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_InvalidDNSNameError(domain: final domain):
        sse_encode_i_32(9, serializer);
        sse_encode_String(domain, serializer);
      case ElectrumError_MissingDomain():
        sse_encode_i_32(10, serializer);
      case ElectrumError_AllAttemptsErrored():
        sse_encode_i_32(11, serializer);
      case ElectrumError_SharedIOError(errorMessage: final errorMessage):
        sse_encode_i_32(12, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_CouldntLockReader():
        sse_encode_i_32(13, serializer);
      case ElectrumError_Mpsc():
        sse_encode_i_32(14, serializer);
      case ElectrumError_CouldNotCreateConnection(
          errorMessage: final errorMessage
        ):
        sse_encode_i_32(15, serializer);
        sse_encode_String(errorMessage, serializer);
      case ElectrumError_RequestAlreadyConsumed():
        sse_encode_i_32(16, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_esplora_error(EsploraError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EsploraError_Minreq(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_HttpResponse(
          status: final status,
          errorMessage: final errorMessage
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_u_16(status, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_Parsing(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_StatusCode(errorMessage: final errorMessage):
        sse_encode_i_32(3, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_BitcoinEncoding(errorMessage: final errorMessage):
        sse_encode_i_32(4, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_HexToArray(errorMessage: final errorMessage):
        sse_encode_i_32(5, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_HexToBytes(errorMessage: final errorMessage):
        sse_encode_i_32(6, serializer);
        sse_encode_String(errorMessage, serializer);
      case EsploraError_TransactionNotFound():
        sse_encode_i_32(7, serializer);
      case EsploraError_HeaderHeightNotFound(height: final height):
        sse_encode_i_32(8, serializer);
        sse_encode_u_32(height, serializer);
      case EsploraError_HeaderHashNotFound():
        sse_encode_i_32(9, serializer);
      case EsploraError_InvalidHttpHeaderName(name: final name):
        sse_encode_i_32(10, serializer);
        sse_encode_String(name, serializer);
      case EsploraError_InvalidHttpHeaderValue(value: final value):
        sse_encode_i_32(11, serializer);
        sse_encode_String(value, serializer);
      case EsploraError_RequestAlreadyConsumed():
        sse_encode_i_32(12, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_extract_tx_error(
      ExtractTxError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ExtractTxError_AbsurdFeeRate(feeRate: final feeRate):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(feeRate, serializer);
      case ExtractTxError_MissingInputValue():
        sse_encode_i_32(1, serializer);
      case ExtractTxError_SendingTooMuch():
        sse_encode_i_32(2, serializer);
      case ExtractTxError_OtherExtractTxErr():
        sse_encode_i_32(3, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.satKwu, serializer);
  }

  @protected
  void sse_encode_ffi_address(FfiAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_corebitcoinAddress(self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_canonical_tx(
      FfiCanonicalTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_transaction(self.transaction, serializer);
    sse_encode_chain_position(self.chainPosition, serializer);
  }

  @protected
  void sse_encode_ffi_connection(FfiConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexbdk_walletrusqliteConnection(
        self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_derivation_path(
      FfiDerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletbitcoinbip32DerivationPath(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_descriptor(FfiDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletdescriptorExtendedDescriptor(
        self.extendedDescriptor, serializer);
    sse_encode_RustOpaque_bdk_walletkeysKeyMap(self.keyMap, serializer);
  }

  @protected
  void sse_encode_ffi_descriptor_public_key(
      FfiDescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletkeysDescriptorPublicKey(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_descriptor_secret_key(
      FfiDescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletkeysDescriptorSecretKey(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_electrum_client(
      FfiElectrumClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_electrumBdkElectrumClientbdk_electrumelectrum_clientClient(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_esplora_client(
      FfiEsploraClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_esploraesplora_clientBlockingClient(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_full_scan_request(
      FfiFullScanRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestbdk_walletKeychainKind(
        self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_full_scan_request_builder(
      FfiFullScanRequestBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientFullScanRequestBuilderbdk_walletKeychainKind(
        self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_mnemonic(FfiMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletkeysbip39Mnemonic(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_psbt(FfiPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexbdk_corebitcoinpsbtPsbt(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_script_buf(FfiScriptBuf self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.bytes, serializer);
  }

  @protected
  void sse_encode_ffi_sync_request(
      FfiSyncRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestbdk_walletKeychainKindu32(
        self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_sync_request_builder(
      FfiSyncRequestBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexOptionbdk_corespk_clientSyncRequestBuilderbdk_walletKeychainKindu32(
        self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_transaction(
      FfiTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_corebitcoinTransaction(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_update(FfiUpdate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdk_walletUpdate(self.field0, serializer);
  }

  @protected
  void sse_encode_ffi_wallet(FfiWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_stdsyncMutexbdk_walletPersistedWalletbdk_walletrusqliteConnection(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_from_script_error(
      FromScriptError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FromScriptError_UnrecognizedScript():
        sse_encode_i_32(0, serializer);
      case FromScriptError_WitnessProgram(errorMessage: final errorMessage):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      case FromScriptError_WitnessVersion(errorMessage: final errorMessage):
        sse_encode_i_32(2, serializer);
        sse_encode_String(errorMessage, serializer);
      case FromScriptError_OtherFromScriptErr():
        sse_encode_i_32(3, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_ffi_canonical_tx(
      List<FfiCanonicalTx> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ffi_canonical_tx(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_prim_u_8_strict(
      List<Uint8List> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_u_8_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_output(
      List<LocalOutput> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_output(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
      List<OutPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_ffi_script_buf_u_64(
      List<(FfiScriptBuf, BigInt)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_ffi_script_buf_u_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_in(List<TxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_out(List<TxOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_load_with_persist_error(
      LoadWithPersistError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LoadWithPersistError_Persist(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case LoadWithPersistError_InvalidChangeSet(
          errorMessage: final errorMessage
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      case LoadWithPersistError_CouldNotLoad():
        sse_encode_i_32(2, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_local_output(LocalOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out(self.txout, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
    sse_encode_bool(self.isSpent, serializer);
  }

  @protected
  void sse_encode_lock_time(LockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LockTime_Blocks(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(field0, serializer);
      case LockTime_Seconds(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fee_rate(
      FeeRate? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fee_rate(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_canonical_tx(
      FfiCanonicalTx? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_canonical_tx(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ffi_script_buf(
      FfiScriptBuf? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ffi_script_buf(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
      RbfValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_psbt_error(PsbtError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PsbtError_InvalidMagic():
        sse_encode_i_32(0, serializer);
      case PsbtError_MissingUtxo():
        sse_encode_i_32(1, serializer);
      case PsbtError_InvalidSeparator():
        sse_encode_i_32(2, serializer);
      case PsbtError_PsbtUtxoOutOfBounds():
        sse_encode_i_32(3, serializer);
      case PsbtError_InvalidKey(key: final key):
        sse_encode_i_32(4, serializer);
        sse_encode_String(key, serializer);
      case PsbtError_InvalidProprietaryKey():
        sse_encode_i_32(5, serializer);
      case PsbtError_DuplicateKey(key: final key):
        sse_encode_i_32(6, serializer);
        sse_encode_String(key, serializer);
      case PsbtError_UnsignedTxHasScriptSigs():
        sse_encode_i_32(7, serializer);
      case PsbtError_UnsignedTxHasScriptWitnesses():
        sse_encode_i_32(8, serializer);
      case PsbtError_MustHaveUnsignedTx():
        sse_encode_i_32(9, serializer);
      case PsbtError_NoMorePairs():
        sse_encode_i_32(10, serializer);
      case PsbtError_UnexpectedUnsignedTx():
        sse_encode_i_32(11, serializer);
      case PsbtError_NonStandardSighashType(sighash: final sighash):
        sse_encode_i_32(12, serializer);
        sse_encode_u_32(sighash, serializer);
      case PsbtError_InvalidHash(hash: final hash):
        sse_encode_i_32(13, serializer);
        sse_encode_String(hash, serializer);
      case PsbtError_InvalidPreimageHashPair():
        sse_encode_i_32(14, serializer);
      case PsbtError_CombineInconsistentKeySources(xpub: final xpub):
        sse_encode_i_32(15, serializer);
        sse_encode_String(xpub, serializer);
      case PsbtError_ConsensusEncoding(encodingError: final encodingError):
        sse_encode_i_32(16, serializer);
        sse_encode_String(encodingError, serializer);
      case PsbtError_NegativeFee():
        sse_encode_i_32(17, serializer);
      case PsbtError_FeeOverflow():
        sse_encode_i_32(18, serializer);
      case PsbtError_InvalidPublicKey(errorMessage: final errorMessage):
        sse_encode_i_32(19, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_InvalidSecp256k1PublicKey(
          secp256K1Error: final secp256K1Error
        ):
        sse_encode_i_32(20, serializer);
        sse_encode_String(secp256K1Error, serializer);
      case PsbtError_InvalidXOnlyPublicKey():
        sse_encode_i_32(21, serializer);
      case PsbtError_InvalidEcdsaSignature(errorMessage: final errorMessage):
        sse_encode_i_32(22, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_InvalidTaprootSignature(errorMessage: final errorMessage):
        sse_encode_i_32(23, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_InvalidControlBlock():
        sse_encode_i_32(24, serializer);
      case PsbtError_InvalidLeafVersion():
        sse_encode_i_32(25, serializer);
      case PsbtError_Taproot():
        sse_encode_i_32(26, serializer);
      case PsbtError_TapTree(errorMessage: final errorMessage):
        sse_encode_i_32(27, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_XPubKey():
        sse_encode_i_32(28, serializer);
      case PsbtError_Version(errorMessage: final errorMessage):
        sse_encode_i_32(29, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_PartialDataConsumption():
        sse_encode_i_32(30, serializer);
      case PsbtError_Io(errorMessage: final errorMessage):
        sse_encode_i_32(31, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtError_OtherPsbtErr():
        sse_encode_i_32(32, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_psbt_parse_error(
      PsbtParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PsbtParseError_PsbtEncoding(errorMessage: final errorMessage):
        sse_encode_i_32(0, serializer);
        sse_encode_String(errorMessage, serializer);
      case PsbtParseError_Base64Encoding(errorMessage: final errorMessage):
        sse_encode_i_32(1, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_record_ffi_script_buf_u_64(
      (FfiScriptBuf, BigInt) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_script_buf(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
  }

  @protected
  void sse_encode_request_builder_error(
      RequestBuilderError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_signer_error(SignerError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SignerError_MissingKey():
        sse_encode_i_32(0, serializer);
      case SignerError_InvalidKey():
        sse_encode_i_32(1, serializer);
      case SignerError_UserCanceled():
        sse_encode_i_32(2, serializer);
      case SignerError_InputIndexOutOfRange():
        sse_encode_i_32(3, serializer);
      case SignerError_MissingNonWitnessUtxo():
        sse_encode_i_32(4, serializer);
      case SignerError_InvalidNonWitnessUtxo():
        sse_encode_i_32(5, serializer);
      case SignerError_MissingWitnessUtxo():
        sse_encode_i_32(6, serializer);
      case SignerError_MissingWitnessScript():
        sse_encode_i_32(7, serializer);
      case SignerError_MissingHdKeypath():
        sse_encode_i_32(8, serializer);
      case SignerError_NonStandardSighash():
        sse_encode_i_32(9, serializer);
      case SignerError_InvalidSighash():
        sse_encode_i_32(10, serializer);
      case SignerError_SighashP2wpkh(errorMessage: final errorMessage):
        sse_encode_i_32(11, serializer);
        sse_encode_String(errorMessage, serializer);
      case SignerError_SighashTaproot(errorMessage: final errorMessage):
        sse_encode_i_32(12, serializer);
        sse_encode_String(errorMessage, serializer);
      case SignerError_TxInputsIndexError(errorMessage: final errorMessage):
        sse_encode_i_32(13, serializer);
        sse_encode_String(errorMessage, serializer);
      case SignerError_MiniscriptPsbt(errorMessage: final errorMessage):
        sse_encode_i_32(14, serializer);
        sse_encode_String(errorMessage, serializer);
      case SignerError_External(errorMessage: final errorMessage):
        sse_encode_i_32(15, serializer);
        sse_encode_String(errorMessage, serializer);
      case SignerError_Psbt(errorMessage: final errorMessage):
        sse_encode_i_32(16, serializer);
        sse_encode_String(errorMessage, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_sqlite_error(SqliteError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SqliteError_Sqlite(rusqliteError: final rusqliteError):
        sse_encode_i_32(0, serializer);
        sse_encode_String(rusqliteError, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_transaction_error(
      TransactionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TransactionError_Io():
        sse_encode_i_32(0, serializer);
      case TransactionError_OversizedVectorAllocation():
        sse_encode_i_32(1, serializer);
      case TransactionError_InvalidChecksum(
          expected: final expected,
          actual: final actual
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_String(expected, serializer);
        sse_encode_String(actual, serializer);
      case TransactionError_NonMinimalVarInt():
        sse_encode_i_32(3, serializer);
      case TransactionError_ParseFailed():
        sse_encode_i_32(4, serializer);
      case TransactionError_UnsupportedSegwitFlag(flag: final flag):
        sse_encode_i_32(5, serializer);
        sse_encode_u_8(flag, serializer);
      case TransactionError_OtherTransactionErr():
        sse_encode_i_32(6, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_tx_in(TxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_ffi_script_buf(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_list_prim_u_8_strict(self.witness, serializer);
  }

  @protected
  void sse_encode_tx_out(TxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_ffi_script_buf(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_txid_parse_error(
      TxidParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TxidParseError_InvalidTxid(txid: final txid):
        sse_encode_i_32(0, serializer);
        sse_encode_String(txid, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}

@sealed
class AddressImpl extends RustOpaque implements Address {
  // Not to be used by end users
  AddressImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AddressImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Address,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Address,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_AddressPtr,
  );
}

@sealed
class BdkElectrumClientClientImpl extends RustOpaque
    implements BdkElectrumClientClient {
  // Not to be used by end users
  BdkElectrumClientClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BdkElectrumClientClientImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core
        .instance.api.rust_arc_increment_strong_count_BdkElectrumClientClient,
    rustArcDecrementStrongCount: core
        .instance.api.rust_arc_decrement_strong_count_BdkElectrumClientClient,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_BdkElectrumClientClientPtr,
  );
}

@sealed
class BlockingClientImpl extends RustOpaque implements BlockingClient {
  // Not to be used by end users
  BlockingClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BlockingClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_BlockingClient,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_BlockingClient,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_BlockingClientPtr,
  );
}

@sealed
class DerivationPathImpl extends RustOpaque implements DerivationPath {
  // Not to be used by end users
  DerivationPathImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DerivationPathImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DerivationPath,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DerivationPath,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_DerivationPathPtr,
  );
}

@sealed
class DescriptorPublicKeyImpl extends RustOpaque
    implements DescriptorPublicKey {
  // Not to be used by end users
  DescriptorPublicKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DescriptorPublicKeyImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DescriptorPublicKey,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DescriptorPublicKey,
    rustArcDecrementStrongCountPtr: core
        .instance.api.rust_arc_decrement_strong_count_DescriptorPublicKeyPtr,
  );
}

@sealed
class DescriptorSecretKeyImpl extends RustOpaque
    implements DescriptorSecretKey {
  // Not to be used by end users
  DescriptorSecretKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DescriptorSecretKeyImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_DescriptorSecretKey,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_DescriptorSecretKey,
    rustArcDecrementStrongCountPtr: core
        .instance.api.rust_arc_decrement_strong_count_DescriptorSecretKeyPtr,
  );
}

@sealed
class ExtendedDescriptorImpl extends RustOpaque implements ExtendedDescriptor {
  // Not to be used by end users
  ExtendedDescriptorImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtendedDescriptorImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_ExtendedDescriptor,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_ExtendedDescriptor,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_ExtendedDescriptorPtr,
  );
}

@sealed
class KeyMapImpl extends RustOpaque implements KeyMap {
  // Not to be used by end users
  KeyMapImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  KeyMapImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_KeyMap,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_KeyMap,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_KeyMapPtr,
  );
}

@sealed
class MnemonicImpl extends RustOpaque implements Mnemonic {
  // Not to be used by end users
  MnemonicImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MnemonicImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Mnemonic,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Mnemonic,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_MnemonicPtr,
  );
}

@sealed
class MutexConnectionImpl extends RustOpaque implements MutexConnection {
  // Not to be used by end users
  MutexConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexConnectionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_MutexConnection,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_MutexConnection,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_MutexConnectionPtr,
  );
}

@sealed
class MutexOptionFullScanRequestBuilderKeychainKindImpl extends RustOpaque
    implements MutexOptionFullScanRequestBuilderKeychainKind {
  // Not to be used by end users
  MutexOptionFullScanRequestBuilderKeychainKindImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexOptionFullScanRequestBuilderKeychainKindImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core.instance.api
        .rust_arc_increment_strong_count_MutexOptionFullScanRequestBuilderKeychainKind,
    rustArcDecrementStrongCount: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionFullScanRequestBuilderKeychainKind,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionFullScanRequestBuilderKeychainKindPtr,
  );
}

@sealed
class MutexOptionFullScanRequestKeychainKindImpl extends RustOpaque
    implements MutexOptionFullScanRequestKeychainKind {
  // Not to be used by end users
  MutexOptionFullScanRequestKeychainKindImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexOptionFullScanRequestKeychainKindImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core.instance.api
        .rust_arc_increment_strong_count_MutexOptionFullScanRequestKeychainKind,
    rustArcDecrementStrongCount: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionFullScanRequestKeychainKind,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionFullScanRequestKeychainKindPtr,
  );
}

@sealed
class MutexOptionSyncRequestBuilderKeychainKindU32Impl extends RustOpaque
    implements MutexOptionSyncRequestBuilderKeychainKindU32 {
  // Not to be used by end users
  MutexOptionSyncRequestBuilderKeychainKindU32Impl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexOptionSyncRequestBuilderKeychainKindU32Impl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core.instance.api
        .rust_arc_increment_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32,
    rustArcDecrementStrongCount: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionSyncRequestBuilderKeychainKindU32Ptr,
  );
}

@sealed
class MutexOptionSyncRequestKeychainKindU32Impl extends RustOpaque
    implements MutexOptionSyncRequestKeychainKindU32 {
  // Not to be used by end users
  MutexOptionSyncRequestKeychainKindU32Impl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexOptionSyncRequestKeychainKindU32Impl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core.instance.api
        .rust_arc_increment_strong_count_MutexOptionSyncRequestKeychainKindU32,
    rustArcDecrementStrongCount: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionSyncRequestKeychainKindU32,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_MutexOptionSyncRequestKeychainKindU32Ptr,
  );
}

@sealed
class MutexPersistedWalletConnectionImpl extends RustOpaque
    implements MutexPersistedWalletConnection {
  // Not to be used by end users
  MutexPersistedWalletConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexPersistedWalletConnectionImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: core.instance.api
        .rust_arc_increment_strong_count_MutexPersistedWalletConnection,
    rustArcDecrementStrongCount: core.instance.api
        .rust_arc_decrement_strong_count_MutexPersistedWalletConnection,
    rustArcDecrementStrongCountPtr: core.instance.api
        .rust_arc_decrement_strong_count_MutexPersistedWalletConnectionPtr,
  );
}

@sealed
class MutexPsbtImpl extends RustOpaque implements MutexPsbt {
  // Not to be used by end users
  MutexPsbtImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MutexPsbtImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_MutexPsbt,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_MutexPsbt,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_MutexPsbtPtr,
  );
}

@sealed
class TransactionImpl extends RustOpaque implements Transaction {
  // Not to be used by end users
  TransactionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TransactionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Transaction,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Transaction,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_TransactionPtr,
  );
}

@sealed
class UpdateImpl extends RustOpaque implements Update {
  // Not to be used by end users
  UpdateImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UpdateImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Update,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Update,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_UpdatePtr,
  );
}
