// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.30.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/blockchain.dart';
import 'api/descriptor.dart';
import 'api/error.dart';
import 'api/key.dart';
import 'api/psbt.dart';
import 'api/types.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class BdkCore extends BaseEntrypoint<BdkCoreApi, BdkCoreApiImpl, BdkCoreWire> {
  @internal
  static final instance = BdkCore._();

  BdkCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    BdkCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<BdkCoreApiImpl, BdkCoreWire> get apiImplConstructor =>
      BdkCoreApiImpl.new;

  @override
  WireConstructor<BdkCoreWire> get wireConstructor =>
      BdkCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.30';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'bdk_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class BdkCoreApi extends BaseApi {
  Future<String> bdkBlockchainBroadcast(
      {required BdkBlockchain that,
      required BdkTransaction transaction,
      dynamic hint});

  Future<FeeRate> bdkBlockchainEstimateFee(
      {required BdkBlockchain that, required int target, dynamic hint});

  Future<String> bdkBlockchainGetBlockHash(
      {required BdkBlockchain that, required int height, dynamic hint});

  Future<int> bdkBlockchainGetHeight(
      {required BdkBlockchain that, dynamic hint});

  Future<BdkBlockchain> bdkBlockchainNew(
      {required BlockchainConfig blockchainConfig, dynamic hint});

  Future<String> bdkDescriptorAsString(
      {required BdkDescriptor that, dynamic hint});

  Future<String> bdkDescriptorAsStringPrivate(
      {required BdkDescriptor that, dynamic hint});

  Future<int> bdkDescriptorMaxSatisfactionWeight(
      {required BdkDescriptor that, dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNew(
      {required String descriptor, required Network network, dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip44(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip44Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip49(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip49Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip84(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip84Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip86(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDescriptor> bdkDescriptorNewBip86Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint});

  Future<BdkDerivationPath> bdkDerivationPathFromString(
      {required String path, dynamic hint});

  Future<String> bdkDescriptorPublicKeyAsString(
      {required BdkDescriptorPublicKey that, dynamic hint});

  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyDerive(
      {required BdkDescriptorPublicKey ptr,
      required BdkDerivationPath path,
      dynamic hint});

  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyExtend(
      {required BdkDescriptorPublicKey ptr,
      required BdkDerivationPath path,
      dynamic hint});

  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyFromString(
      {required String publicKey, dynamic hint});

  Future<BdkDescriptorPublicKey> bdkDescriptorSecretKeyAsPublic(
      {required BdkDescriptorSecretKey ptr, dynamic hint});

  Future<String> bdkDescriptorSecretKeyAsString(
      {required BdkDescriptorSecretKey that, dynamic hint});

  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyCreate(
      {required Network network,
      required BdkMnemonic mnemonic,
      String? password,
      dynamic hint});

  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyDerive(
      {required BdkDescriptorSecretKey ptr,
      required BdkDerivationPath path,
      dynamic hint});

  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyExtend(
      {required BdkDescriptorSecretKey ptr,
      required BdkDerivationPath path,
      dynamic hint});

  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyFromString(
      {required String secretKey, dynamic hint});

  Future<Uint8List> bdkDescriptorSecretKeySecretBytes(
      {required BdkDescriptorSecretKey that, dynamic hint});

  Future<String> bdkMnemonicAsString({required BdkMnemonic that, dynamic hint});

  Future<BdkMnemonic> bdkMnemonicFromEntropy(
      {required List<int> entropy, dynamic hint});

  Future<BdkMnemonic> bdkMnemonicFromString(
      {required String mnemonic, dynamic hint});

  Future<BdkMnemonic> bdkMnemonicNew(
      {required WordCount wordCount, dynamic hint});

  Future<BdkPsbt> bdkPsbtCombine(
      {required BdkPsbt ptr, required BdkPsbt other, dynamic hint});

  Future<BdkTransaction> bdkPsbtExtractTx({required BdkPsbt ptr, dynamic hint});

  Future<int?> bdkPsbtFeeAmount({required BdkPsbt that, dynamic hint});

  Future<FeeRate?> bdkPsbtFeeRate({required BdkPsbt that, dynamic hint});

  Future<BdkPsbt> bdkPsbtFromStr({required String psbtBase64, dynamic hint});

  Future<BdkPsbt> bdkPsbtFromUnsignedTx(
      {required BdkTransaction tx, dynamic hint});

  Future<String> bdkPsbtJsonSerialize({required BdkPsbt that, dynamic hint});

  Future<String> bdkPsbtSerialize({required BdkPsbt that, dynamic hint});

  Future<String> bdkPsbtTxid({required BdkPsbt that, dynamic hint});

  Future<BdkPsbt> bdkPsbtUpdateInput(
      {required BdkPsbt that, required Input input, dynamic hint});

  Future<String> bdkAddressAsString({required BdkAddress that, dynamic hint});

  Future<BdkAddress> bdkAddressFromScript(
      {required BdkScriptBuf script, required Network network, dynamic hint});

  Future<BdkAddress> bdkAddressFromString(
      {required String address, required Network network, dynamic hint});

  Future<bool> bdkAddressIsValidForNetwork(
      {required BdkAddress that, required Network network, dynamic hint});

  Future<Network> bdkAddressNetwork({required BdkAddress that, dynamic hint});

  Future<Payload> bdkAddressPayload({required BdkAddress that, dynamic hint});

  Future<BdkScriptBuf> bdkAddressScript(
      {required BdkAddress ptr, dynamic hint});

  Future<String> bdkAddressToQrUri({required BdkAddress that, dynamic hint});

  Future<BdkScriptBuf> bdkScriptBufEmpty({dynamic hint});

  Future<BdkScriptBuf> bdkScriptBufFromHex({required String s, dynamic hint});

  Future<BdkScriptBuf> bdkScriptBufWithCapacity(
      {required int capacity, dynamic hint});

  Future<BdkTransaction> bdkTransactionFromBytes(
      {required List<int> transactionBytes, dynamic hint});

  Future<List<TxIn>> bdkTransactionInput(
      {required BdkTransaction that, dynamic hint});

  Future<bool> bdkTransactionIsCoinBase(
      {required BdkTransaction that, dynamic hint});

  Future<bool> bdkTransactionIsExplicitlyRbf(
      {required BdkTransaction that, dynamic hint});

  Future<bool> bdkTransactionIsLockTimeEnabled(
      {required BdkTransaction that, dynamic hint});

  Future<LockTime> bdkTransactionLockTime(
      {required BdkTransaction that, dynamic hint});

  Future<BdkTransaction> bdkTransactionNew(
      {required int version,
      required LockTime lockTime,
      required List<TxIn> input,
      required List<TxOut> output,
      dynamic hint});

  Future<List<TxOut>> bdkTransactionOutput(
      {required BdkTransaction that, dynamic hint});

  Future<Uint8List> bdkTransactionSerialize(
      {required BdkTransaction that, dynamic hint});

  Future<int> bdkTransactionSize({required BdkTransaction that, dynamic hint});

  Future<String> bdkTransactionTxid(
      {required BdkTransaction that, dynamic hint});

  Future<int> bdkTransactionVersion(
      {required BdkTransaction that, dynamic hint});

  Future<int> bdkTransactionVsize({required BdkTransaction that, dynamic hint});

  Future<int> bdkTransactionWeight(
      {required BdkTransaction that, dynamic hint});

  Future<AddressInfo> bdkWalletGetAddress(
      {required BdkWallet that,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<Balance> bdkWalletGetBalance({required BdkWallet that, dynamic hint});

  Future<BdkDescriptor> bdkWalletGetDescriptorForKeychain(
      {required BdkWallet ptr, required KeychainKind keychain, dynamic hint});

  Future<AddressInfo> bdkWalletGetInternalAddress(
      {required BdkWallet that,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<Input> bdkWalletGetPsbtInput(
      {required BdkWallet that,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? sighashType,
      dynamic hint});

  Future<bool> bdkWalletIsMine(
      {required BdkWallet that, required BdkScriptBuf script, dynamic hint});

  Future<List<TransactionDetails>> bdkWalletListTransactions(
      {required BdkWallet that, required bool includeRaw, dynamic hint});

  Future<List<LocalUtxo>> bdkWalletListUnspent(
      {required BdkWallet that, dynamic hint});

  Future<Network> bdkWalletNetwork({required BdkWallet that, dynamic hint});

  Future<BdkWallet> bdkWalletNew(
      {required BdkDescriptor descriptor,
      BdkDescriptor? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint});

  Future<bool> bdkWalletSign(
      {required BdkWallet ptr,
      required BdkPsbt psbt,
      SignOptions? signOptions,
      dynamic hint});

  Future<void> bdkWalletSync(
      {required BdkWallet ptr,
      required BdkBlockchain blockchain,
      dynamic hint});

  Future<(BdkPsbt, TransactionDetails)> finishBumpFeeTxBuilder(
      {required String txid,
      required double feeRate,
      BdkAddress? allowShrinking,
      required BdkWallet wallet,
      required bool enableRbf,
      int? nSequence,
      dynamic hint});

  Future<(BdkPsbt, TransactionDetails)> txBuilderFinish(
      {required BdkWallet wallet,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, Input, int)? foreignUtxo,
      required List<OutPoint> unSpendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      BdkScriptBuf? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AnyBlockchain;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AnyBlockchain;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AnyBlockchainPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedDescriptor;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtendedDescriptorPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPartiallySignedTransaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPartiallySignedTransaction;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexPartiallySignedTransactionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexBdkWalletAnyDatabase;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabase;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabasePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkBitcoinAddress;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkBitcoinAddress;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BdkBitcoinAddressPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BitcoinBip32DerivationPath;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BitcoinBip32DerivationPath;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BitcoinBip32DerivationPathPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysDescriptorPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysDescriptorPublicKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_KeysDescriptorPublicKeyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysDescriptorSecretKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysDescriptorSecretKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_KeysDescriptorSecretKeyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysKeyMap;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysKeyMap;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_KeysKeyMapPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysBip39Mnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysBip39Mnemonic;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_KeysBip39MnemonicPtr;
}

class BdkCoreApiImpl extends BdkCoreApiImplPlatform implements BdkCoreApi {
  BdkCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> bdkBlockchainBroadcast(
      {required BdkBlockchain that,
      required BdkTransaction transaction,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
        var arg1 = cst_encode_box_autoadd_bdk_transaction(transaction);
        return wire.wire_BdkBlockchain_broadcast(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkBlockchainBroadcastConstMeta,
      argValues: [that, transaction],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkBlockchainBroadcastConstMeta => const TaskConstMeta(
        debugName: "BdkBlockchain_broadcast",
        argNames: ["that", "transaction"],
      );

  @override
  Future<FeeRate> bdkBlockchainEstimateFee(
      {required BdkBlockchain that, required int target, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
        var arg1 = cst_encode_u_64(target);
        return wire.wire_BdkBlockchain_estimate_fee(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_fee_rate,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkBlockchainEstimateFeeConstMeta,
      argValues: [that, target],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkBlockchainEstimateFeeConstMeta => const TaskConstMeta(
        debugName: "BdkBlockchain_estimate_fee",
        argNames: ["that", "target"],
      );

  @override
  Future<String> bdkBlockchainGetBlockHash(
      {required BdkBlockchain that, required int height, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
        var arg1 = cst_encode_u_32(height);
        return wire.wire_BdkBlockchain_get_block_hash(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkBlockchainGetBlockHashConstMeta,
      argValues: [that, height],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkBlockchainGetBlockHashConstMeta => const TaskConstMeta(
        debugName: "BdkBlockchain_get_block_hash",
        argNames: ["that", "height"],
      );

  @override
  Future<int> bdkBlockchainGetHeight(
      {required BdkBlockchain that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_blockchain(that);
        return wire.wire_BdkBlockchain_get_height(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_32,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkBlockchainGetHeightConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkBlockchainGetHeightConstMeta => const TaskConstMeta(
        debugName: "BdkBlockchain_get_height",
        argNames: ["that"],
      );

  @override
  Future<BdkBlockchain> bdkBlockchainNew(
      {required BlockchainConfig blockchainConfig, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_blockchain_config(blockchainConfig);
        return wire.wire_BdkBlockchain_new(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_blockchain,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkBlockchainNewConstMeta,
      argValues: [blockchainConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkBlockchainNewConstMeta => const TaskConstMeta(
        debugName: "BdkBlockchain_new",
        argNames: ["blockchainConfig"],
      );

  @override
  Future<String> bdkDescriptorAsString(
      {required BdkDescriptor that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
        return wire.wire_BdkDescriptor_as_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkDescriptorAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorAsStringConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_as_string",
        argNames: ["that"],
      );

  @override
  Future<String> bdkDescriptorAsStringPrivate(
      {required BdkDescriptor that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
        return wire.wire_BdkDescriptor_as_string_private(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkDescriptorAsStringPrivateConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorAsStringPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_as_string_private",
        argNames: ["that"],
      );

  @override
  Future<int> bdkDescriptorMaxSatisfactionWeight(
      {required BdkDescriptor that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor(that);
        return wire.wire_BdkDescriptor_max_satisfaction_weight(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorMaxSatisfactionWeightConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorMaxSatisfactionWeightConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_max_satisfaction_weight",
        argNames: ["that"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNew(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(descriptor);
        var arg1 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_new",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip44(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip44(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip44ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip44ConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip44",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip44Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip44_public(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip44PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip44PublicConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip44_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip49(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip49(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip49ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip49ConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip49",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip49Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip49_public(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip49PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip49PublicConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip49_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip84(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip84(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip84ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip84ConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip84",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip84Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip84_public(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip84PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip84PublicConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip84_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip86(
      {required BdkDescriptorSecretKey secretKey,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(secretKey);
        var arg1 = cst_encode_keychain_kind(keychainKind);
        var arg2 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip86(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip86ConstMeta,
      argValues: [secretKey, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip86ConstMeta => const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip86",
        argNames: ["secretKey", "keychainKind", "network"],
      );

  @override
  Future<BdkDescriptor> bdkDescriptorNewBip86Public(
      {required BdkDescriptorPublicKey publicKey,
      required String fingerprint,
      required KeychainKind keychainKind,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(publicKey);
        var arg1 = cst_encode_String(fingerprint);
        var arg2 = cst_encode_keychain_kind(keychainKind);
        var arg3 = cst_encode_network(network);
        return wire.wire_BdkDescriptor_new_bip86_public(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorNewBip86PublicConstMeta,
      argValues: [publicKey, fingerprint, keychainKind, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorNewBip86PublicConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptor_new_bip86_public",
        argNames: ["publicKey", "fingerprint", "keychainKind", "network"],
      );

  @override
  Future<BdkDerivationPath> bdkDerivationPathFromString(
      {required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        return wire.wire_BdkDerivationPath_from_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_derivation_path,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDerivationPathFromStringConstMeta,
      argValues: [path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDerivationPathFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDerivationPath_from_string",
        argNames: ["path"],
      );

  @override
  Future<String> bdkDescriptorPublicKeyAsString(
      {required BdkDescriptorPublicKey that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(that);
        return wire.wire_BdkDescriptorPublicKey_as_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkDescriptorPublicKeyAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorPublicKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorPublicKey_as_string",
        argNames: ["that"],
      );

  @override
  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyDerive(
      {required BdkDescriptorPublicKey ptr,
      required BdkDerivationPath path,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
        return wire.wire_BdkDescriptorPublicKey_derive(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_public_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorPublicKeyDeriveConstMeta,
      argValues: [ptr, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorPublicKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorPublicKey_derive",
        argNames: ["ptr", "path"],
      );

  @override
  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyExtend(
      {required BdkDescriptorPublicKey ptr,
      required BdkDerivationPath path,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_public_key(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
        return wire.wire_BdkDescriptorPublicKey_extend(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_public_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorPublicKeyExtendConstMeta,
      argValues: [ptr, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorPublicKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorPublicKey_extend",
        argNames: ["ptr", "path"],
      );

  @override
  Future<BdkDescriptorPublicKey> bdkDescriptorPublicKeyFromString(
      {required String publicKey, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(publicKey);
        return wire.wire_BdkDescriptorPublicKey_from_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_public_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorPublicKeyFromStringConstMeta,
      argValues: [publicKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorPublicKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorPublicKey_from_string",
        argNames: ["publicKey"],
      );

  @override
  Future<BdkDescriptorPublicKey> bdkDescriptorSecretKeyAsPublic(
      {required BdkDescriptorSecretKey ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
        return wire.wire_BdkDescriptorSecretKey_as_public(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_public_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeyAsPublicConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyAsPublicConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_as_public",
        argNames: ["ptr"],
      );

  @override
  Future<String> bdkDescriptorSecretKeyAsString(
      {required BdkDescriptorSecretKey that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(that);
        return wire.wire_BdkDescriptorSecretKey_as_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkDescriptorSecretKeyAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyAsStringConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_as_string",
        argNames: ["that"],
      );

  @override
  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyCreate(
      {required Network network,
      required BdkMnemonic mnemonic,
      String? password,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_network(network);
        var arg1 = cst_encode_box_autoadd_bdk_mnemonic(mnemonic);
        var arg2 = cst_encode_opt_String(password);
        return wire.wire_BdkDescriptorSecretKey_create(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeyCreateConstMeta,
      argValues: [network, mnemonic, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyCreateConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_create",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyDerive(
      {required BdkDescriptorSecretKey ptr,
      required BdkDerivationPath path,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
        return wire.wire_BdkDescriptorSecretKey_derive(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeyDeriveConstMeta,
      argValues: [ptr, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyDeriveConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_derive",
        argNames: ["ptr", "path"],
      );

  @override
  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyExtend(
      {required BdkDescriptorSecretKey ptr,
      required BdkDerivationPath path,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_derivation_path(path);
        return wire.wire_BdkDescriptorSecretKey_extend(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeyExtendConstMeta,
      argValues: [ptr, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyExtendConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_extend",
        argNames: ["ptr", "path"],
      );

  @override
  Future<BdkDescriptorSecretKey> bdkDescriptorSecretKeyFromString(
      {required String secretKey, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(secretKey);
        return wire.wire_BdkDescriptorSecretKey_from_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor_secret_key,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeyFromStringConstMeta,
      argValues: [secretKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_from_string",
        argNames: ["secretKey"],
      );

  @override
  Future<Uint8List> bdkDescriptorSecretKeySecretBytes(
      {required BdkDescriptorSecretKey that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor_secret_key(that);
        return wire.wire_BdkDescriptorSecretKey_secret_bytes(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkDescriptorSecretKeySecretBytesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkDescriptorSecretKeySecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "BdkDescriptorSecretKey_secret_bytes",
        argNames: ["that"],
      );

  @override
  Future<String> bdkMnemonicAsString(
      {required BdkMnemonic that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_mnemonic(that);
        return wire.wire_BdkMnemonic_as_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkMnemonicAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkMnemonicAsStringConstMeta => const TaskConstMeta(
        debugName: "BdkMnemonic_as_string",
        argNames: ["that"],
      );

  @override
  Future<BdkMnemonic> bdkMnemonicFromEntropy(
      {required List<int> entropy, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_list_prim_u_8_loose(entropy);
        return wire.wire_BdkMnemonic_from_entropy(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_mnemonic,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkMnemonicFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkMnemonicFromEntropyConstMeta => const TaskConstMeta(
        debugName: "BdkMnemonic_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<BdkMnemonic> bdkMnemonicFromString(
      {required String mnemonic, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        return wire.wire_BdkMnemonic_from_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_mnemonic,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkMnemonicFromStringConstMeta,
      argValues: [mnemonic],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkMnemonicFromStringConstMeta => const TaskConstMeta(
        debugName: "BdkMnemonic_from_string",
        argNames: ["mnemonic"],
      );

  @override
  Future<BdkMnemonic> bdkMnemonicNew(
      {required WordCount wordCount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_word_count(wordCount);
        return wire.wire_BdkMnemonic_new(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_mnemonic,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkMnemonicNewConstMeta,
      argValues: [wordCount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkMnemonicNewConstMeta => const TaskConstMeta(
        debugName: "BdkMnemonic_new",
        argNames: ["wordCount"],
      );

  @override
  Future<BdkPsbt> bdkPsbtCombine(
      {required BdkPsbt ptr, required BdkPsbt other, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_psbt(other);
        return wire.wire_BdkPsbt_combine(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_psbt,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkPsbtCombineConstMeta,
      argValues: [ptr, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtCombineConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_combine",
        argNames: ["ptr", "other"],
      );

  @override
  Future<BdkTransaction> bdkPsbtExtractTx(
      {required BdkPsbt ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(ptr);
        return wire.wire_BdkPsbt_extract_tx(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_transaction,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkPsbtExtractTxConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtExtractTxConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_extract_tx",
        argNames: ["ptr"],
      );

  @override
  Future<int?> bdkPsbtFeeAmount({required BdkPsbt that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        return wire.wire_BdkPsbt_fee_amount(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kBdkPsbtFeeAmountConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtFeeAmountConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_fee_amount",
        argNames: ["that"],
      );

  @override
  Future<FeeRate?> bdkPsbtFeeRate({required BdkPsbt that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        return wire.wire_BdkPsbt_fee_rate(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_fee_rate,
        decodeErrorData: null,
      ),
      constMeta: kBdkPsbtFeeRateConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtFeeRateConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_fee_rate",
        argNames: ["that"],
      );

  @override
  Future<BdkPsbt> bdkPsbtFromStr({required String psbtBase64, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(psbtBase64);
        return wire.wire_BdkPsbt_from_str(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_psbt,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkPsbtFromStrConstMeta,
      argValues: [psbtBase64],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtFromStrConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_from_str",
        argNames: ["psbtBase64"],
      );

  @override
  Future<BdkPsbt> bdkPsbtFromUnsignedTx(
      {required BdkTransaction tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(tx);
        return wire.wire_BdkPsbt_from_unsigned_tx(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_psbt,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkPsbtFromUnsignedTxConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtFromUnsignedTxConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_from_unsigned_tx",
        argNames: ["tx"],
      );

  @override
  Future<String> bdkPsbtJsonSerialize({required BdkPsbt that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        return wire.wire_BdkPsbt_json_serialize(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkPsbtJsonSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtJsonSerializeConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_json_serialize",
        argNames: ["that"],
      );

  @override
  Future<String> bdkPsbtSerialize({required BdkPsbt that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        return wire.wire_BdkPsbt_serialize(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkPsbtSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtSerializeConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_serialize",
        argNames: ["that"],
      );

  @override
  Future<String> bdkPsbtTxid({required BdkPsbt that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        return wire.wire_BdkPsbt_txid(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkPsbtTxidConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtTxidConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_txid",
        argNames: ["that"],
      );

  @override
  Future<BdkPsbt> bdkPsbtUpdateInput(
      {required BdkPsbt that, required Input input, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_psbt(that);
        var arg1 = cst_encode_box_autoadd_input(input);
        return wire.wire_BdkPsbt_update_input(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_psbt,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkPsbtUpdateInputConstMeta,
      argValues: [that, input],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkPsbtUpdateInputConstMeta => const TaskConstMeta(
        debugName: "BdkPsbt_update_input",
        argNames: ["that", "input"],
      );

  @override
  Future<String> bdkAddressAsString({required BdkAddress that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(that);
        return wire.wire_BdkAddress_as_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressAsStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressAsStringConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_as_string",
        argNames: ["that"],
      );

  @override
  Future<BdkAddress> bdkAddressFromScript(
      {required BdkScriptBuf script, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_script_buf(script);
        var arg1 = cst_encode_network(network);
        return wire.wire_BdkAddress_from_script(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_address,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkAddressFromScriptConstMeta,
      argValues: [script, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressFromScriptConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_from_script",
        argNames: ["script", "network"],
      );

  @override
  Future<BdkAddress> bdkAddressFromString(
      {required String address, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(address);
        var arg1 = cst_encode_network(network);
        return wire.wire_BdkAddress_from_string(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_address,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkAddressFromStringConstMeta,
      argValues: [address, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressFromStringConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_from_string",
        argNames: ["address", "network"],
      );

  @override
  Future<bool> bdkAddressIsValidForNetwork(
      {required BdkAddress that, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(that);
        var arg1 = cst_encode_network(network);
        return wire.wire_BdkAddress_is_valid_for_network(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressIsValidForNetworkConstMeta,
      argValues: [that, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressIsValidForNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "BdkAddress_is_valid_for_network",
        argNames: ["that", "network"],
      );

  @override
  Future<Network> bdkAddressNetwork({required BdkAddress that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(that);
        return wire.wire_BdkAddress_network(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressNetworkConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_network",
        argNames: ["that"],
      );

  @override
  Future<Payload> bdkAddressPayload({required BdkAddress that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(that);
        return wire.wire_BdkAddress_payload(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payload,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressPayloadConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressPayloadConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_payload",
        argNames: ["that"],
      );

  @override
  Future<BdkScriptBuf> bdkAddressScript(
      {required BdkAddress ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(ptr);
        return wire.wire_BdkAddress_script(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressScriptConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressScriptConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_script",
        argNames: ["ptr"],
      );

  @override
  Future<String> bdkAddressToQrUri({required BdkAddress that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_address(that);
        return wire.wire_BdkAddress_to_qr_uri(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkAddressToQrUriConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkAddressToQrUriConstMeta => const TaskConstMeta(
        debugName: "BdkAddress_to_qr_uri",
        argNames: ["that"],
      );

  @override
  Future<BdkScriptBuf> bdkScriptBufEmpty({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire_BdkScriptBuf_empty(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kBdkScriptBufEmptyConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkScriptBufEmptyConstMeta => const TaskConstMeta(
        debugName: "BdkScriptBuf_empty",
        argNames: [],
      );

  @override
  Future<BdkScriptBuf> bdkScriptBufFromHex({required String s, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(s);
        return wire.wire_BdkScriptBuf_from_hex(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_script_buf,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkScriptBufFromHexConstMeta,
      argValues: [s],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkScriptBufFromHexConstMeta => const TaskConstMeta(
        debugName: "BdkScriptBuf_from_hex",
        argNames: ["s"],
      );

  @override
  Future<BdkScriptBuf> bdkScriptBufWithCapacity(
      {required int capacity, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_usize(capacity);
        return wire.wire_BdkScriptBuf_with_capacity(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_script_buf,
        decodeErrorData: null,
      ),
      constMeta: kBdkScriptBufWithCapacityConstMeta,
      argValues: [capacity],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkScriptBufWithCapacityConstMeta => const TaskConstMeta(
        debugName: "BdkScriptBuf_with_capacity",
        argNames: ["capacity"],
      );

  @override
  Future<BdkTransaction> bdkTransactionFromBytes(
      {required List<int> transactionBytes, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_list_prim_u_8_loose(transactionBytes);
        return wire.wire_BdkTransaction_from_bytes(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_transaction,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionFromBytesConstMeta,
      argValues: [transactionBytes],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionFromBytesConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_from_bytes",
        argNames: ["transactionBytes"],
      );

  @override
  Future<List<TxIn>> bdkTransactionInput(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_input(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_tx_in,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionInputConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionInputConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_input",
        argNames: ["that"],
      );

  @override
  Future<bool> bdkTransactionIsCoinBase(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_is_coin_base(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionIsCoinBaseConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionIsCoinBaseConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_is_coin_base",
        argNames: ["that"],
      );

  @override
  Future<bool> bdkTransactionIsExplicitlyRbf(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_is_explicitly_rbf(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionIsExplicitlyRbfConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionIsExplicitlyRbfConstMeta =>
      const TaskConstMeta(
        debugName: "BdkTransaction_is_explicitly_rbf",
        argNames: ["that"],
      );

  @override
  Future<bool> bdkTransactionIsLockTimeEnabled(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_is_lock_time_enabled(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionIsLockTimeEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionIsLockTimeEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "BdkTransaction_is_lock_time_enabled",
        argNames: ["that"],
      );

  @override
  Future<LockTime> bdkTransactionLockTime(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_lock_time(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lock_time,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionLockTimeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionLockTimeConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_lock_time",
        argNames: ["that"],
      );

  @override
  Future<BdkTransaction> bdkTransactionNew(
      {required int version,
      required LockTime lockTime,
      required List<TxIn> input,
      required List<TxOut> output,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_i_32(version);
        var arg1 = cst_encode_box_autoadd_lock_time(lockTime);
        var arg2 = cst_encode_list_tx_in(input);
        var arg3 = cst_encode_list_tx_out(output);
        return wire.wire_BdkTransaction_new(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_transaction,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionNewConstMeta,
      argValues: [version, lockTime, input, output],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionNewConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_new",
        argNames: ["version", "lockTime", "input", "output"],
      );

  @override
  Future<List<TxOut>> bdkTransactionOutput(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_output(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_tx_out,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionOutputConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionOutputConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_output",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> bdkTransactionSerialize(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_serialize(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionSerializeConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_serialize",
        argNames: ["that"],
      );

  @override
  Future<int> bdkTransactionSize({required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionSizeConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_size",
        argNames: ["that"],
      );

  @override
  Future<String> bdkTransactionTxid(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_txid(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionTxidConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionTxidConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_txid",
        argNames: ["that"],
      );

  @override
  Future<int> bdkTransactionVersion(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_version(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_i_32,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionVersionConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionVersionConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_version",
        argNames: ["that"],
      );

  @override
  Future<int> bdkTransactionVsize(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_vsize(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionVsizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionVsizeConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_vsize",
        argNames: ["that"],
      );

  @override
  Future<int> bdkTransactionWeight(
      {required BdkTransaction that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_transaction(that);
        return wire.wire_BdkTransaction_weight(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkTransactionWeightConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkTransactionWeightConstMeta => const TaskConstMeta(
        debugName: "BdkTransaction_weight",
        argNames: ["that"],
      );

  @override
  Future<AddressInfo> bdkWalletGetAddress(
      {required BdkWallet that,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        var arg1 = cst_encode_box_autoadd_address_index(addressIndex);
        return wire.wire_BdkWallet_get_address(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address_info,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletGetAddressConstMeta,
      argValues: [that, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletGetAddressConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_get_address",
        argNames: ["that", "addressIndex"],
      );

  @override
  Future<Balance> bdkWalletGetBalance({required BdkWallet that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        return wire.wire_BdkWallet_get_balance(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_balance,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletGetBalanceConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletGetBalanceConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_get_balance",
        argNames: ["that"],
      );

  @override
  Future<BdkDescriptor> bdkWalletGetDescriptorForKeychain(
      {required BdkWallet ptr, required KeychainKind keychain, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
        var arg1 = cst_encode_keychain_kind(keychain);
        return wire.wire_BdkWallet_get_descriptor_for_keychain(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_descriptor,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletGetDescriptorForKeychainConstMeta,
      argValues: [ptr, keychain],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletGetDescriptorForKeychainConstMeta =>
      const TaskConstMeta(
        debugName: "BdkWallet_get_descriptor_for_keychain",
        argNames: ["ptr", "keychain"],
      );

  @override
  Future<AddressInfo> bdkWalletGetInternalAddress(
      {required BdkWallet that,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        var arg1 = cst_encode_box_autoadd_address_index(addressIndex);
        return wire.wire_BdkWallet_get_internal_address(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address_info,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletGetInternalAddressConstMeta,
      argValues: [that, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletGetInternalAddressConstMeta =>
      const TaskConstMeta(
        debugName: "BdkWallet_get_internal_address",
        argNames: ["that", "addressIndex"],
      );

  @override
  Future<Input> bdkWalletGetPsbtInput(
      {required BdkWallet that,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? sighashType,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        var arg1 = cst_encode_box_autoadd_local_utxo(utxo);
        var arg2 = cst_encode_bool(onlyWitnessUtxo);
        var arg3 = cst_encode_opt_box_autoadd_psbt_sig_hash_type(sighashType);
        return wire.wire_BdkWallet_get_psbt_input(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_input,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletGetPsbtInputConstMeta,
      argValues: [that, utxo, onlyWitnessUtxo, sighashType],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletGetPsbtInputConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_get_psbt_input",
        argNames: ["that", "utxo", "onlyWitnessUtxo", "sighashType"],
      );

  @override
  Future<bool> bdkWalletIsMine(
      {required BdkWallet that, required BdkScriptBuf script, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        var arg1 = cst_encode_box_autoadd_bdk_script_buf(script);
        return wire.wire_BdkWallet_is_mine(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletIsMineConstMeta,
      argValues: [that, script],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletIsMineConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_is_mine",
        argNames: ["that", "script"],
      );

  @override
  Future<List<TransactionDetails>> bdkWalletListTransactions(
      {required BdkWallet that, required bool includeRaw, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        var arg1 = cst_encode_bool(includeRaw);
        return wire.wire_BdkWallet_list_transactions(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_transaction_details,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletListTransactionsConstMeta,
      argValues: [that, includeRaw],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletListTransactionsConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_list_transactions",
        argNames: ["that", "includeRaw"],
      );

  @override
  Future<List<LocalUtxo>> bdkWalletListUnspent(
      {required BdkWallet that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        return wire.wire_BdkWallet_list_unspent(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_local_utxo,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletListUnspentConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletListUnspentConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_list_unspent",
        argNames: ["that"],
      );

  @override
  Future<Network> bdkWalletNetwork({required BdkWallet that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(that);
        return wire.wire_BdkWallet_network(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kBdkWalletNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletNetworkConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_network",
        argNames: ["that"],
      );

  @override
  Future<BdkWallet> bdkWalletNew(
      {required BdkDescriptor descriptor,
      BdkDescriptor? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_descriptor(descriptor);
        var arg1 = cst_encode_opt_box_autoadd_bdk_descriptor(changeDescriptor);
        var arg2 = cst_encode_network(network);
        var arg3 = cst_encode_box_autoadd_database_config(databaseConfig);
        return wire.wire_BdkWallet_new(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bdk_wallet,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletNewConstMeta,
      argValues: [descriptor, changeDescriptor, network, databaseConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletNewConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_new",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig"
        ],
      );

  @override
  Future<bool> bdkWalletSign(
      {required BdkWallet ptr,
      required BdkPsbt psbt,
      SignOptions? signOptions,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_psbt(psbt);
        var arg2 = cst_encode_opt_box_autoadd_sign_options(signOptions);
        return wire.wire_BdkWallet_sign(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletSignConstMeta,
      argValues: [ptr, psbt, signOptions],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletSignConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_sign",
        argNames: ["ptr", "psbt", "signOptions"],
      );

  @override
  Future<void> bdkWalletSync(
      {required BdkWallet ptr,
      required BdkBlockchain blockchain,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(ptr);
        var arg1 = cst_encode_box_autoadd_bdk_blockchain(blockchain);
        return wire.wire_BdkWallet_sync(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kBdkWalletSyncConstMeta,
      argValues: [ptr, blockchain],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletSyncConstMeta => const TaskConstMeta(
        debugName: "BdkWallet_sync",
        argNames: ["ptr", "blockchain"],
      );

  @override
  Future<(BdkPsbt, TransactionDetails)> finishBumpFeeTxBuilder(
      {required String txid,
      required double feeRate,
      BdkAddress? allowShrinking,
      required BdkWallet wallet,
      required bool enableRbf,
      int? nSequence,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(txid);
        var arg1 = cst_encode_f_32(feeRate);
        var arg2 = cst_encode_opt_box_autoadd_bdk_address(allowShrinking);
        var arg3 = cst_encode_box_autoadd_bdk_wallet(wallet);
        var arg4 = cst_encode_bool(enableRbf);
        var arg5 = cst_encode_opt_box_autoadd_u_32(nSequence);
        return wire.wire_finish_bump_fee_tx_builder(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_record_bdk_psbt_transaction_details,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kFinishBumpFeeTxBuilderConstMeta,
      argValues: [txid, feeRate, allowShrinking, wallet, enableRbf, nSequence],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kFinishBumpFeeTxBuilderConstMeta => const TaskConstMeta(
        debugName: "finish_bump_fee_tx_builder",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "wallet",
          "enableRbf",
          "nSequence"
        ],
      );

  @override
  Future<(BdkPsbt, TransactionDetails)> txBuilderFinish(
      {required BdkWallet wallet,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, Input, int)? foreignUtxo,
      required List<OutPoint> unSpendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      BdkScriptBuf? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_bdk_wallet(wallet);
        var arg1 = cst_encode_list_script_amount(recipients);
        var arg2 = cst_encode_list_out_point(utxos);
        var arg3 = cst_encode_opt_box_autoadd_record_out_point_input_usize(
            foreignUtxo);
        var arg4 = cst_encode_list_out_point(unSpendable);
        var arg5 = cst_encode_change_spend_policy(changePolicy);
        var arg6 = cst_encode_bool(manuallySelectedOnly);
        var arg7 = cst_encode_opt_box_autoadd_f_32(feeRate);
        var arg8 = cst_encode_opt_box_autoadd_u_64(feeAbsolute);
        var arg9 = cst_encode_bool(drainWallet);
        var arg10 = cst_encode_opt_box_autoadd_bdk_script_buf(drainTo);
        var arg11 = cst_encode_opt_box_autoadd_rbf_value(rbf);
        var arg12 = cst_encode_list_prim_u_8_loose(data);
        return wire.wire_tx_builder_finish(port_, arg0, arg1, arg2, arg3, arg4,
            arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_record_bdk_psbt_transaction_details,
        decodeErrorData: dco_decode_bdk_error,
      ),
      constMeta: kTxBuilderFinishConstMeta,
      argValues: [
        wallet,
        recipients,
        utxos,
        foreignUtxo,
        unSpendable,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "tx_builder_finish",
        argNames: [
          "wallet",
          "recipients",
          "utxos",
          "foreignUtxo",
          "unSpendable",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data"
        ],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AnyBlockchain =>
          wire.rust_arc_increment_strong_count_RustOpaque_AnyBlockchain;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AnyBlockchain =>
          wire.rust_arc_decrement_strong_count_RustOpaque_AnyBlockchain;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedDescriptor =>
          wire.rust_arc_increment_strong_count_RustOpaque_ExtendedDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedDescriptor =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ExtendedDescriptor;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexPartiallySignedTransaction => wire
          .rust_arc_increment_strong_count_RustOpaque_MutexPartiallySignedTransaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexPartiallySignedTransaction => wire
          .rust_arc_decrement_strong_count_RustOpaque_MutexPartiallySignedTransaction;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MutexBdkWalletAnyDatabase => wire
          .rust_arc_increment_strong_count_RustOpaque_MutexbdkWalletAnyDatabase;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabase => wire
          .rust_arc_decrement_strong_count_RustOpaque_MutexbdkWalletAnyDatabase;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkBitcoinAddress =>
          wire.rust_arc_increment_strong_count_RustOpaque_bdkbitcoinAddress;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkBitcoinAddress =>
          wire.rust_arc_decrement_strong_count_RustOpaque_bdkbitcoinAddress;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BitcoinBip32DerivationPath => wire
          .rust_arc_increment_strong_count_RustOpaque_bitcoinbip32DerivationPath;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BitcoinBip32DerivationPath => wire
          .rust_arc_decrement_strong_count_RustOpaque_bitcoinbip32DerivationPath;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysDescriptorPublicKey => wire
          .rust_arc_increment_strong_count_RustOpaque_keysDescriptorPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysDescriptorPublicKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_keysDescriptorPublicKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysDescriptorSecretKey => wire
          .rust_arc_increment_strong_count_RustOpaque_keysDescriptorSecretKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysDescriptorSecretKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_keysDescriptorSecretKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysKeyMap =>
          wire.rust_arc_increment_strong_count_RustOpaque_keysKeyMap;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysKeyMap =>
          wire.rust_arc_decrement_strong_count_RustOpaque_keysKeyMap;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_KeysBip39Mnemonic =>
          wire.rust_arc_increment_strong_count_RustOpaque_keysbip39Mnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_KeysBip39Mnemonic =>
          wire.rust_arc_decrement_strong_count_RustOpaque_keysbip39Mnemonic;

  @protected
  AnyBlockchain dco_decode_RustOpaque_AnyBlockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyBlockchain.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedDescriptor dco_decode_RustOpaque_ExtendedDescriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedDescriptor.dcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexPartiallySignedTransaction
      dco_decode_RustOpaque_MutexPartiallySignedTransaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexPartiallySignedTransaction.dcoDecode(raw as List<dynamic>);
  }

  @protected
  MutexBdkWalletAnyDatabase dco_decode_RustOpaque_MutexbdkWalletAnyDatabase(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MutexBdkWalletAnyDatabase.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkBitcoinAddress dco_decode_RustOpaque_bdkbitcoinAddress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkBitcoinAddress.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BitcoinBip32DerivationPath dco_decode_RustOpaque_bitcoinbip32DerivationPath(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BitcoinBip32DerivationPath.dcoDecode(raw as List<dynamic>);
  }

  @protected
  KeysDescriptorPublicKey dco_decode_RustOpaque_keysDescriptorPublicKey(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeysDescriptorPublicKey.dcoDecode(raw as List<dynamic>);
  }

  @protected
  KeysDescriptorSecretKey dco_decode_RustOpaque_keysDescriptorSecretKey(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeysDescriptorSecretKey.dcoDecode(raw as List<dynamic>);
  }

  @protected
  KeysKeyMap dco_decode_RustOpaque_keysKeyMap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeysKeyMap.dcoDecode(raw as List<dynamic>);
  }

  @protected
  KeysBip39Mnemonic dco_decode_RustOpaque_keysbip39Mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeysBip39Mnemonic.dcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressError dco_decode_address_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressError_Base58(
          dco_decode_String(raw[1]),
        );
      case 1:
        return AddressError_Bech32(
          dco_decode_String(raw[1]),
        );
      case 2:
        return AddressError_EmptyBech32Payload();
      case 3:
        return AddressError_InvalidBech32Variant(
          expected: dco_decode_variant(raw[1]),
          found: dco_decode_variant(raw[2]),
        );
      case 4:
        return AddressError_InvalidWitnessVersion(
          dco_decode_u_8(raw[1]),
        );
      case 5:
        return AddressError_UnparsableWitnessVersion(
          dco_decode_String(raw[1]),
        );
      case 6:
        return AddressError_MalformedWitnessVersion();
      case 7:
        return AddressError_InvalidWitnessProgramLength(
          dco_decode_usize(raw[1]),
        );
      case 8:
        return AddressError_InvalidSegwitV0ProgramLength(
          dco_decode_usize(raw[1]),
        );
      case 9:
        return AddressError_UncompressedPubkey();
      case 10:
        return AddressError_ExcessiveScriptSize();
      case 11:
        return AddressError_UnrecognizedScript();
      case 12:
        return AddressError_UnknownAddressType(
          dco_decode_String(raw[1]),
        );
      case 13:
        return AddressError_NetworkValidation(
          networkRequired: dco_decode_network(raw[1]),
          networkFound: dco_decode_network(raw[2]),
          address: dco_decode_String(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressIndex dco_decode_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressIndex_Increase();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        return AddressIndex_Peek(
          index: dco_decode_u_32(raw[1]),
        );
      case 3:
        return AddressIndex_Reset(
          index: dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: dco_decode_u_32(arr[0]),
      address: dco_decode_bdk_address(arr[1]),
    );
  }

  @protected
  Auth dco_decode_auth(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Auth_None();
      case 1:
        return Auth_UserPass(
          username: dco_decode_String(raw[1]),
          password: dco_decode_String(raw[2]),
        );
      case 2:
        return Auth_Cookie(
          file: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  BdkAddress dco_decode_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkAddress(
      ptr: dco_decode_RustOpaque_bdkbitcoinAddress(arr[0]),
    );
  }

  @protected
  BdkBlockchain dco_decode_bdk_blockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkBlockchain(
      ptr: dco_decode_RustOpaque_AnyBlockchain(arr[0]),
    );
  }

  @protected
  BdkDerivationPath dco_decode_bdk_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDerivationPath(
      ptr: dco_decode_RustOpaque_bitcoinbip32DerivationPath(arr[0]),
    );
  }

  @protected
  BdkDescriptor dco_decode_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BdkDescriptor(
      extendedDescriptor: dco_decode_RustOpaque_ExtendedDescriptor(arr[0]),
      keyMap: dco_decode_RustOpaque_keysKeyMap(arr[1]),
    );
  }

  @protected
  BdkDescriptorPublicKey dco_decode_bdk_descriptor_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDescriptorPublicKey(
      ptr: dco_decode_RustOpaque_keysDescriptorPublicKey(arr[0]),
    );
  }

  @protected
  BdkDescriptorSecretKey dco_decode_bdk_descriptor_secret_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkDescriptorSecretKey(
      ptr: dco_decode_RustOpaque_keysDescriptorSecretKey(arr[0]),
    );
  }

  @protected
  BdkError dco_decode_bdk_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BdkError_Hex(
          dco_decode_box_autoadd_hex_error(raw[1]),
        );
      case 1:
        return BdkError_Consensus(
          dco_decode_box_autoadd_consensus_error(raw[1]),
        );
      case 2:
        return BdkError_Address(
          dco_decode_box_autoadd_address_error(raw[1]),
        );
      case 3:
        return BdkError_Descriptor(
          dco_decode_box_autoadd_descriptor_error(raw[1]),
        );
      case 4:
        return BdkError_InvalidU32Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 5:
        return BdkError_Generic(
          dco_decode_String(raw[1]),
        );
      case 6:
        return BdkError_ScriptDoesntHaveAddressForm();
      case 7:
        return BdkError_NoRecipients();
      case 8:
        return BdkError_NoUtxosSelected();
      case 9:
        return BdkError_OutputBelowDustLimit(
          dco_decode_usize(raw[1]),
        );
      case 10:
        return BdkError_InsufficientFunds(
          needed: dco_decode_u_64(raw[1]),
          available: dco_decode_u_64(raw[2]),
        );
      case 11:
        return BdkError_BnBTotalTriesExceeded();
      case 12:
        return BdkError_BnBNoExactMatch();
      case 13:
        return BdkError_UnknownUtxo();
      case 14:
        return BdkError_TransactionNotFound();
      case 15:
        return BdkError_TransactionConfirmed();
      case 16:
        return BdkError_IrreplaceableTransaction();
      case 17:
        return BdkError_FeeRateTooLow(
          needed: dco_decode_f_32(raw[1]),
        );
      case 18:
        return BdkError_FeeTooLow(
          needed: dco_decode_u_64(raw[1]),
        );
      case 19:
        return BdkError_FeeRateUnavailable();
      case 20:
        return BdkError_MissingKeyOrigin(
          dco_decode_String(raw[1]),
        );
      case 21:
        return BdkError_Key(
          dco_decode_String(raw[1]),
        );
      case 22:
        return BdkError_ChecksumMismatch();
      case 23:
        return BdkError_SpendingPolicyRequired(
          dco_decode_keychain_kind(raw[1]),
        );
      case 24:
        return BdkError_InvalidPolicyPathError(
          dco_decode_String(raw[1]),
        );
      case 25:
        return BdkError_Signer(
          dco_decode_String(raw[1]),
        );
      case 26:
        return BdkError_InvalidNetwork(
          requested: dco_decode_network(raw[1]),
          found: dco_decode_network(raw[2]),
        );
      case 27:
        return BdkError_InvalidOutpoint(
          dco_decode_box_autoadd_out_point(raw[1]),
        );
      case 28:
        return BdkError_Encode(
          dco_decode_String(raw[1]),
        );
      case 29:
        return BdkError_Miniscript(
          dco_decode_String(raw[1]),
        );
      case 30:
        return BdkError_MiniscriptPsbt(
          dco_decode_String(raw[1]),
        );
      case 31:
        return BdkError_Bip32(
          dco_decode_String(raw[1]),
        );
      case 32:
        return BdkError_Bip39(
          dco_decode_String(raw[1]),
        );
      case 33:
        return BdkError_Secp256k1(
          dco_decode_String(raw[1]),
        );
      case 34:
        return BdkError_Json(
          dco_decode_String(raw[1]),
        );
      case 35:
        return BdkError_Psbt(
          dco_decode_String(raw[1]),
        );
      case 36:
        return BdkError_PsbtParse(
          dco_decode_String(raw[1]),
        );
      case 37:
        return BdkError_MissingCachedScripts(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      case 38:
        return BdkError_Electrum(
          dco_decode_String(raw[1]),
        );
      case 39:
        return BdkError_Esplora(
          dco_decode_String(raw[1]),
        );
      case 40:
        return BdkError_Sled(
          dco_decode_String(raw[1]),
        );
      case 41:
        return BdkError_Rpc(
          dco_decode_String(raw[1]),
        );
      case 42:
        return BdkError_Rusqlite(
          dco_decode_String(raw[1]),
        );
      case 43:
        return BdkError_InvalidInput(
          dco_decode_String(raw[1]),
        );
      case 44:
        return BdkError_InvalidLockTime(
          dco_decode_String(raw[1]),
        );
      case 45:
        return BdkError_InvalidTransaction(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BdkMnemonic dco_decode_bdk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkMnemonic(
      ptr: dco_decode_RustOpaque_keysbip39Mnemonic(arr[0]),
    );
  }

  @protected
  BdkPsbt dco_decode_bdk_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkPsbt(
      ptr: dco_decode_RustOpaque_MutexPartiallySignedTransaction(arr[0]),
    );
  }

  @protected
  BdkScriptBuf dco_decode_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkScriptBuf(
      bytes: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  BdkTransaction dco_decode_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkTransaction(
      inner: dco_decode_String(arr[0]),
    );
  }

  @protected
  BdkWallet dco_decode_bdk_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BdkWallet(
      ptr: dco_decode_RustOpaque_MutexbdkWalletAnyDatabase(arr[0]),
    );
  }

  @protected
  BlockTime dco_decode_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  BlockchainConfig dco_decode_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BlockchainConfig_Electrum(
          config: dco_decode_box_autoadd_electrum_config(raw[1]),
        );
      case 1:
        return BlockchainConfig_Esplora(
          config: dco_decode_box_autoadd_esplora_config(raw[1]),
        );
      case 2:
        return BlockchainConfig_Rpc(
          config: dco_decode_box_autoadd_rpc_config(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddressError dco_decode_box_autoadd_address_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_error(raw);
  }

  @protected
  AddressIndex dco_decode_box_autoadd_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_index(raw);
  }

  @protected
  BdkAddress dco_decode_box_autoadd_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_address(raw);
  }

  @protected
  BdkBlockchain dco_decode_box_autoadd_bdk_blockchain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_blockchain(raw);
  }

  @protected
  BdkDerivationPath dco_decode_box_autoadd_bdk_derivation_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_derivation_path(raw);
  }

  @protected
  BdkDescriptor dco_decode_box_autoadd_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor(raw);
  }

  @protected
  BdkDescriptorPublicKey dco_decode_box_autoadd_bdk_descriptor_public_key(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor_public_key(raw);
  }

  @protected
  BdkDescriptorSecretKey dco_decode_box_autoadd_bdk_descriptor_secret_key(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_descriptor_secret_key(raw);
  }

  @protected
  BdkMnemonic dco_decode_box_autoadd_bdk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_mnemonic(raw);
  }

  @protected
  BdkPsbt dco_decode_box_autoadd_bdk_psbt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_psbt(raw);
  }

  @protected
  BdkScriptBuf dco_decode_box_autoadd_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_script_buf(raw);
  }

  @protected
  BdkTransaction dco_decode_box_autoadd_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_transaction(raw);
  }

  @protected
  BdkWallet dco_decode_box_autoadd_bdk_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bdk_wallet(raw);
  }

  @protected
  BlockTime dco_decode_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_time(raw);
  }

  @protected
  BlockchainConfig dco_decode_box_autoadd_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_blockchain_config(raw);
  }

  @protected
  ConsensusError dco_decode_box_autoadd_consensus_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_consensus_error(raw);
  }

  @protected
  DatabaseConfig dco_decode_box_autoadd_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_database_config(raw);
  }

  @protected
  DescriptorError dco_decode_box_autoadd_descriptor_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_descriptor_error(raw);
  }

  @protected
  ElectrumConfig dco_decode_box_autoadd_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_electrum_config(raw);
  }

  @protected
  EsploraConfig dco_decode_box_autoadd_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_config(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FeeRate dco_decode_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fee_rate(raw);
  }

  @protected
  HexError dco_decode_box_autoadd_hex_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_hex_error(raw);
  }

  @protected
  Input dco_decode_box_autoadd_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_input(raw);
  }

  @protected
  LocalUtxo dco_decode_box_autoadd_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_local_utxo(raw);
  }

  @protected
  LockTime dco_decode_box_autoadd_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lock_time(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PsbtSigHashType dco_decode_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  (OutPoint, Input, int) dco_decode_box_autoadd_record_out_point_input_usize(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (OutPoint, Input, int);
  }

  @protected
  RpcConfig dco_decode_box_autoadd_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_config(raw);
  }

  @protected
  RpcSyncParams dco_decode_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_sync_params(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  SledDbConfiguration dco_decode_box_autoadd_sled_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sled_db_configuration(raw);
  }

  @protected
  SqliteDbConfiguration dco_decode_box_autoadd_sqlite_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sqlite_db_configuration(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  ConsensusError dco_decode_consensus_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ConsensusError_Io(
          dco_decode_String(raw[1]),
        );
      case 1:
        return ConsensusError_OversizedVectorAllocation(
          requested: dco_decode_usize(raw[1]),
          max: dco_decode_usize(raw[2]),
        );
      case 2:
        return ConsensusError_InvalidChecksum(
          expected: dco_decode_u_8_array_4(raw[1]),
          actual: dco_decode_u_8_array_4(raw[2]),
        );
      case 3:
        return ConsensusError_NonMinimalVarInt();
      case 4:
        return ConsensusError_ParseFailed(
          dco_decode_String(raw[1]),
        );
      case 5:
        return ConsensusError_UnsupportedSegwitFlag(
          dco_decode_u_8(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DatabaseConfig dco_decode_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        return DatabaseConfig_Sqlite(
          config: dco_decode_box_autoadd_sqlite_db_configuration(raw[1]),
        );
      case 2:
        return DatabaseConfig_Sled(
          config: dco_decode_box_autoadd_sled_db_configuration(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DescriptorError dco_decode_descriptor_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_InvalidDescriptorChecksum();
      case 2:
        return DescriptorError_HardenedDerivationXpub();
      case 3:
        return DescriptorError_MultiPath();
      case 4:
        return DescriptorError_Key(
          dco_decode_String(raw[1]),
        );
      case 5:
        return DescriptorError_Policy(
          dco_decode_String(raw[1]),
        );
      case 6:
        return DescriptorError_InvalidDescriptorCharacter(
          dco_decode_u_8(raw[1]),
        );
      case 7:
        return DescriptorError_Bip32(
          dco_decode_String(raw[1]),
        );
      case 8:
        return DescriptorError_Base58(
          dco_decode_String(raw[1]),
        );
      case 9:
        return DescriptorError_Pk(
          dco_decode_String(raw[1]),
        );
      case 10:
        return DescriptorError_Miniscript(
          dco_decode_String(raw[1]),
        );
      case 11:
        return DescriptorError_Hex(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ElectrumConfig dco_decode_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ElectrumConfig(
      url: dco_decode_String(arr[0]),
      socks5: dco_decode_opt_String(arr[1]),
      retry: dco_decode_u_8(arr[2]),
      timeout: dco_decode_opt_box_autoadd_u_8(arr[3]),
      stopGap: dco_decode_u_64(arr[4]),
      validateDomain: dco_decode_bool(arr[5]),
    );
  }

  @protected
  EsploraConfig dco_decode_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return EsploraConfig(
      baseUrl: dco_decode_String(arr[0]),
      proxy: dco_decode_opt_String(arr[1]),
      concurrency: dco_decode_opt_box_autoadd_u_8(arr[2]),
      stopGap: dco_decode_u_64(arr[3]),
      timeout: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FeeRate dco_decode_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FeeRate(
      satPerVb: dco_decode_f_32(arr[0]),
    );
  }

  @protected
  HexError dco_decode_hex_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return HexError_InvalidChar(
          dco_decode_u_8(raw[1]),
        );
      case 1:
        return HexError_OddLengthString(
          dco_decode_usize(raw[1]),
        );
      case 2:
        return HexError_InvalidLength(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Input dco_decode_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Input(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  List<Uint8List> dco_decode_list_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_prim_u_8_strict).toList();
  }

  @protected
  List<LocalUtxo> dco_decode_list_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_utxo).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ScriptAmount> dco_decode_list_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_script_amount).toList();
  }

  @protected
  List<TransactionDetails> dco_decode_list_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction_details).toList();
  }

  @protected
  List<TxIn> dco_decode_list_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_in).toList();
  }

  @protected
  List<TxOut> dco_decode_list_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_out).toList();
  }

  @protected
  LocalUtxo dco_decode_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out(arr[1]),
      keychain: dco_decode_keychain_kind(arr[2]),
      isSpent: dco_decode_bool(arr[3]),
    );
  }

  @protected
  LockTime dco_decode_lock_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LockTime_Blocks(
          dco_decode_u_32(raw[1]),
        );
      case 1:
        return LockTime_Seconds(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BdkAddress? dco_decode_opt_box_autoadd_bdk_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_address(raw);
  }

  @protected
  BdkDescriptor? dco_decode_opt_box_autoadd_bdk_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_descriptor(raw);
  }

  @protected
  BdkScriptBuf? dco_decode_opt_box_autoadd_bdk_script_buf(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_script_buf(raw);
  }

  @protected
  BdkTransaction? dco_decode_opt_box_autoadd_bdk_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bdk_transaction(raw);
  }

  @protected
  BlockTime? dco_decode_opt_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_time(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  FeeRate? dco_decode_opt_box_autoadd_fee_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_fee_rate(raw);
  }

  @protected
  PsbtSigHashType? dco_decode_opt_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  (OutPoint, Input, int)?
      dco_decode_opt_box_autoadd_record_out_point_input_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_out_point_input_usize(raw);
  }

  @protected
  RpcSyncParams? dco_decode_opt_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_sync_params(raw);
  }

  @protected
  SignOptions? dco_decode_opt_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sign_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Payload dco_decode_payload(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Payload_PubkeyHash(
          pubkeyHash: dco_decode_String(raw[1]),
        );
      case 1:
        return Payload_ScriptHash(
          scriptHash: dco_decode_String(raw[1]),
        );
      case 2:
        return Payload_WitnessProgram(
          version: dco_decode_witness_version(raw[1]),
          program: dco_decode_list_prim_u_8_strict(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PsbtSigHashType dco_decode_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PsbtSigHashType(
      inner: dco_decode_u_32(arr[0]),
    );
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (BdkPsbt, TransactionDetails) dco_decode_record_bdk_psbt_transaction_details(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_bdk_psbt(arr[0]),
      dco_decode_transaction_details(arr[1]),
    );
  }

  @protected
  (OutPoint, Input, int) dco_decode_record_out_point_input_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_out_point(arr[0]),
      dco_decode_input(arr[1]),
      dco_decode_usize(arr[2]),
    );
  }

  @protected
  RpcConfig dco_decode_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RpcConfig(
      url: dco_decode_String(arr[0]),
      auth: dco_decode_auth(arr[1]),
      network: dco_decode_network(arr[2]),
      walletName: dco_decode_String(arr[3]),
      syncParams: dco_decode_opt_box_autoadd_rpc_sync_params(arr[4]),
    );
  }

  @protected
  RpcSyncParams dco_decode_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RpcSyncParams(
      startScriptCount: dco_decode_u_64(arr[0]),
      startTime: dco_decode_u_64(arr[1]),
      forceStartTime: dco_decode_bool(arr[2]),
      pollRateSec: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  ScriptAmount dco_decode_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScriptAmount(
      script: dco_decode_bdk_script_buf(arr[0]),
      amount: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SignOptions(
      multiSig: dco_decode_bool(arr[0]),
      trustWitnessUtxo: dco_decode_bool(arr[1]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[2]),
      allowAllSighashes: dco_decode_bool(arr[3]),
      removePartialSigs: dco_decode_bool(arr[4]),
      tryFinalize: dco_decode_bool(arr[5]),
      signWithTapInternalKey: dco_decode_bool(arr[6]),
      allowGrinding: dco_decode_bool(arr[7]),
    );
  }

  @protected
  SledDbConfiguration dco_decode_sled_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SledDbConfiguration(
      path: dco_decode_String(arr[0]),
      treeName: dco_decode_String(arr[1]),
    );
  }

  @protected
  SqliteDbConfiguration dco_decode_sqlite_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SqliteDbConfiguration(
      path: dco_decode_String(arr[0]),
    );
  }

  @protected
  TransactionDetails dco_decode_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TransactionDetails(
      transaction: dco_decode_opt_box_autoadd_bdk_transaction(arr[0]),
      txid: dco_decode_String(arr[1]),
      received: dco_decode_u_64(arr[2]),
      sent: dco_decode_u_64(arr[3]),
      fee: dco_decode_opt_box_autoadd_u_64(arr[4]),
      confirmationTime: dco_decode_opt_box_autoadd_block_time(arr[5]),
    );
  }

  @protected
  TxIn dco_decode_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_bdk_script_buf(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  TxOut dco_decode_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_bdk_script_buf(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  Variant dco_decode_variant(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Variant.values[raw as int];
  }

  @protected
  WitnessVersion dco_decode_witness_version(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WitnessVersion.values[raw as int];
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  AnyBlockchain sse_decode_RustOpaque_AnyBlockchain(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnyBlockchain.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedDescriptor sse_decode_RustOpaque_ExtendedDescriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedDescriptor.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexPartiallySignedTransaction
      sse_decode_RustOpaque_MutexPartiallySignedTransaction(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexPartiallySignedTransaction.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MutexBdkWalletAnyDatabase sse_decode_RustOpaque_MutexbdkWalletAnyDatabase(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MutexBdkWalletAnyDatabase.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkBitcoinAddress sse_decode_RustOpaque_bdkbitcoinAddress(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkBitcoinAddress.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BitcoinBip32DerivationPath sse_decode_RustOpaque_bitcoinbip32DerivationPath(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BitcoinBip32DerivationPath.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  KeysDescriptorPublicKey sse_decode_RustOpaque_keysDescriptorPublicKey(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeysDescriptorPublicKey.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  KeysDescriptorSecretKey sse_decode_RustOpaque_keysDescriptorSecretKey(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeysDescriptorSecretKey.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  KeysKeyMap sse_decode_RustOpaque_keysKeyMap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeysKeyMap.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  KeysBip39Mnemonic sse_decode_RustOpaque_keysbip39Mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return KeysBip39Mnemonic.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressError sse_decode_address_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_Base58(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_Bech32(var_field0);
      case 2:
        return AddressError_EmptyBech32Payload();
      case 3:
        var var_expected = sse_decode_variant(deserializer);
        var var_found = sse_decode_variant(deserializer);
        return AddressError_InvalidBech32Variant(
            expected: var_expected, found: var_found);
      case 4:
        var var_field0 = sse_decode_u_8(deserializer);
        return AddressError_InvalidWitnessVersion(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_UnparsableWitnessVersion(var_field0);
      case 6:
        return AddressError_MalformedWitnessVersion();
      case 7:
        var var_field0 = sse_decode_usize(deserializer);
        return AddressError_InvalidWitnessProgramLength(var_field0);
      case 8:
        var var_field0 = sse_decode_usize(deserializer);
        return AddressError_InvalidSegwitV0ProgramLength(var_field0);
      case 9:
        return AddressError_UncompressedPubkey();
      case 10:
        return AddressError_ExcessiveScriptSize();
      case 11:
        return AddressError_UnrecognizedScript();
      case 12:
        var var_field0 = sse_decode_String(deserializer);
        return AddressError_UnknownAddressType(var_field0);
      case 13:
        var var_networkRequired = sse_decode_network(deserializer);
        var var_networkFound = sse_decode_network(deserializer);
        var var_address = sse_decode_String(deserializer);
        return AddressError_NetworkValidation(
            networkRequired: var_networkRequired,
            networkFound: var_networkFound,
            address: var_address);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressIndex sse_decode_address_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressIndex_Increase();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Peek(index: var_index);
      case 3:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Reset(index: var_index);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_address = sse_decode_bdk_address(deserializer);
    return AddressInfo(index: var_index, address: var_address);
  }

  @protected
  Auth sse_decode_auth(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Auth_None();
      case 1:
        var var_username = sse_decode_String(deserializer);
        var var_password = sse_decode_String(deserializer);
        return Auth_UserPass(username: var_username, password: var_password);
      case 2:
        var var_file = sse_decode_String(deserializer);
        return Auth_Cookie(file: var_file);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
        immature: var_immature,
        trustedPending: var_trustedPending,
        untrustedPending: var_untrustedPending,
        confirmed: var_confirmed,
        spendable: var_spendable,
        total: var_total);
  }

  @protected
  BdkAddress sse_decode_bdk_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_bdkbitcoinAddress(deserializer);
    return BdkAddress(ptr: var_ptr);
  }

  @protected
  BdkBlockchain sse_decode_bdk_blockchain(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_AnyBlockchain(deserializer);
    return BdkBlockchain(ptr: var_ptr);
  }

  @protected
  BdkDerivationPath sse_decode_bdk_derivation_path(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_bitcoinbip32DerivationPath(deserializer);
    return BdkDerivationPath(ptr: var_ptr);
  }

  @protected
  BdkDescriptor sse_decode_bdk_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_extendedDescriptor =
        sse_decode_RustOpaque_ExtendedDescriptor(deserializer);
    var var_keyMap = sse_decode_RustOpaque_keysKeyMap(deserializer);
    return BdkDescriptor(
        extendedDescriptor: var_extendedDescriptor, keyMap: var_keyMap);
  }

  @protected
  BdkDescriptorPublicKey sse_decode_bdk_descriptor_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_keysDescriptorPublicKey(deserializer);
    return BdkDescriptorPublicKey(ptr: var_ptr);
  }

  @protected
  BdkDescriptorSecretKey sse_decode_bdk_descriptor_secret_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_keysDescriptorSecretKey(deserializer);
    return BdkDescriptorSecretKey(ptr: var_ptr);
  }

  @protected
  BdkError sse_decode_bdk_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_hex_error(deserializer);
        return BdkError_Hex(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_consensus_error(deserializer);
        return BdkError_Consensus(var_field0);
      case 2:
        var var_field0 = sse_decode_box_autoadd_address_error(deserializer);
        return BdkError_Address(var_field0);
      case 3:
        var var_field0 = sse_decode_box_autoadd_descriptor_error(deserializer);
        return BdkError_Descriptor(var_field0);
      case 4:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return BdkError_InvalidU32Bytes(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Generic(var_field0);
      case 6:
        return BdkError_ScriptDoesntHaveAddressForm();
      case 7:
        return BdkError_NoRecipients();
      case 8:
        return BdkError_NoUtxosSelected();
      case 9:
        var var_field0 = sse_decode_usize(deserializer);
        return BdkError_OutputBelowDustLimit(var_field0);
      case 10:
        var var_needed = sse_decode_u_64(deserializer);
        var var_available = sse_decode_u_64(deserializer);
        return BdkError_InsufficientFunds(
            needed: var_needed, available: var_available);
      case 11:
        return BdkError_BnBTotalTriesExceeded();
      case 12:
        return BdkError_BnBNoExactMatch();
      case 13:
        return BdkError_UnknownUtxo();
      case 14:
        return BdkError_TransactionNotFound();
      case 15:
        return BdkError_TransactionConfirmed();
      case 16:
        return BdkError_IrreplaceableTransaction();
      case 17:
        var var_needed = sse_decode_f_32(deserializer);
        return BdkError_FeeRateTooLow(needed: var_needed);
      case 18:
        var var_needed = sse_decode_u_64(deserializer);
        return BdkError_FeeTooLow(needed: var_needed);
      case 19:
        return BdkError_FeeRateUnavailable();
      case 20:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_MissingKeyOrigin(var_field0);
      case 21:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Key(var_field0);
      case 22:
        return BdkError_ChecksumMismatch();
      case 23:
        var var_field0 = sse_decode_keychain_kind(deserializer);
        return BdkError_SpendingPolicyRequired(var_field0);
      case 24:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidPolicyPathError(var_field0);
      case 25:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Signer(var_field0);
      case 26:
        var var_requested = sse_decode_network(deserializer);
        var var_found = sse_decode_network(deserializer);
        return BdkError_InvalidNetwork(
            requested: var_requested, found: var_found);
      case 27:
        var var_field0 = sse_decode_box_autoadd_out_point(deserializer);
        return BdkError_InvalidOutpoint(var_field0);
      case 28:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Encode(var_field0);
      case 29:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Miniscript(var_field0);
      case 30:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_MiniscriptPsbt(var_field0);
      case 31:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Bip32(var_field0);
      case 32:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Bip39(var_field0);
      case 33:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Secp256k1(var_field0);
      case 34:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Json(var_field0);
      case 35:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Psbt(var_field0);
      case 36:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_PsbtParse(var_field0);
      case 37:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return BdkError_MissingCachedScripts(var_field0, var_field1);
      case 38:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Electrum(var_field0);
      case 39:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Esplora(var_field0);
      case 40:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Sled(var_field0);
      case 41:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Rpc(var_field0);
      case 42:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_Rusqlite(var_field0);
      case 43:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidInput(var_field0);
      case 44:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidLockTime(var_field0);
      case 45:
        var var_field0 = sse_decode_String(deserializer);
        return BdkError_InvalidTransaction(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BdkMnemonic sse_decode_bdk_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_keysbip39Mnemonic(deserializer);
    return BdkMnemonic(ptr: var_ptr);
  }

  @protected
  BdkPsbt sse_decode_bdk_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_MutexPartiallySignedTransaction(deserializer);
    return BdkPsbt(ptr: var_ptr);
  }

  @protected
  BdkScriptBuf sse_decode_bdk_script_buf(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bytes = sse_decode_list_prim_u_8_strict(deserializer);
    return BdkScriptBuf(bytes: var_bytes);
  }

  @protected
  BdkTransaction sse_decode_bdk_transaction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inner = sse_decode_String(deserializer);
    return BdkTransaction(inner: var_inner);
  }

  @protected
  BdkWallet sse_decode_bdk_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_MutexbdkWalletAnyDatabase(deserializer);
    return BdkWallet(ptr: var_ptr);
  }

  @protected
  BlockTime sse_decode_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    return BlockTime(height: var_height, timestamp: var_timestamp);
  }

  @protected
  BlockchainConfig sse_decode_blockchain_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_config = sse_decode_box_autoadd_electrum_config(deserializer);
        return BlockchainConfig_Electrum(config: var_config);
      case 1:
        var var_config = sse_decode_box_autoadd_esplora_config(deserializer);
        return BlockchainConfig_Esplora(config: var_config);
      case 2:
        var var_config = sse_decode_box_autoadd_rpc_config(deserializer);
        return BlockchainConfig_Rpc(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddressError sse_decode_box_autoadd_address_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_error(deserializer));
  }

  @protected
  AddressIndex sse_decode_box_autoadd_address_index(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_index(deserializer));
  }

  @protected
  BdkAddress sse_decode_box_autoadd_bdk_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_address(deserializer));
  }

  @protected
  BdkBlockchain sse_decode_box_autoadd_bdk_blockchain(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_blockchain(deserializer));
  }

  @protected
  BdkDerivationPath sse_decode_box_autoadd_bdk_derivation_path(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_derivation_path(deserializer));
  }

  @protected
  BdkDescriptor sse_decode_box_autoadd_bdk_descriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor(deserializer));
  }

  @protected
  BdkDescriptorPublicKey sse_decode_box_autoadd_bdk_descriptor_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor_public_key(deserializer));
  }

  @protected
  BdkDescriptorSecretKey sse_decode_box_autoadd_bdk_descriptor_secret_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_descriptor_secret_key(deserializer));
  }

  @protected
  BdkMnemonic sse_decode_box_autoadd_bdk_mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_mnemonic(deserializer));
  }

  @protected
  BdkPsbt sse_decode_box_autoadd_bdk_psbt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_psbt(deserializer));
  }

  @protected
  BdkScriptBuf sse_decode_box_autoadd_bdk_script_buf(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_script_buf(deserializer));
  }

  @protected
  BdkTransaction sse_decode_box_autoadd_bdk_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_transaction(deserializer));
  }

  @protected
  BdkWallet sse_decode_box_autoadd_bdk_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bdk_wallet(deserializer));
  }

  @protected
  BlockTime sse_decode_box_autoadd_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_time(deserializer));
  }

  @protected
  BlockchainConfig sse_decode_box_autoadd_blockchain_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_blockchain_config(deserializer));
  }

  @protected
  ConsensusError sse_decode_box_autoadd_consensus_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_consensus_error(deserializer));
  }

  @protected
  DatabaseConfig sse_decode_box_autoadd_database_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_database_config(deserializer));
  }

  @protected
  DescriptorError sse_decode_box_autoadd_descriptor_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_descriptor_error(deserializer));
  }

  @protected
  ElectrumConfig sse_decode_box_autoadd_electrum_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_electrum_config(deserializer));
  }

  @protected
  EsploraConfig sse_decode_box_autoadd_esplora_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_config(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  FeeRate sse_decode_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fee_rate(deserializer));
  }

  @protected
  HexError sse_decode_box_autoadd_hex_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_hex_error(deserializer));
  }

  @protected
  Input sse_decode_box_autoadd_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_input(deserializer));
  }

  @protected
  LocalUtxo sse_decode_box_autoadd_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_local_utxo(deserializer));
  }

  @protected
  LockTime sse_decode_box_autoadd_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lock_time(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PsbtSigHashType sse_decode_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_psbt_sig_hash_type(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  (OutPoint, Input, int) sse_decode_box_autoadd_record_out_point_input_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_out_point_input_usize(deserializer));
  }

  @protected
  RpcConfig sse_decode_box_autoadd_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_config(deserializer));
  }

  @protected
  RpcSyncParams sse_decode_box_autoadd_rpc_sync_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_sync_params(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  SledDbConfiguration sse_decode_box_autoadd_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sled_db_configuration(deserializer));
  }

  @protected
  SqliteDbConfiguration sse_decode_box_autoadd_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sqlite_db_configuration(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  ConsensusError sse_decode_consensus_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ConsensusError_Io(var_field0);
      case 1:
        var var_requested = sse_decode_usize(deserializer);
        var var_max = sse_decode_usize(deserializer);
        return ConsensusError_OversizedVectorAllocation(
            requested: var_requested, max: var_max);
      case 2:
        var var_expected = sse_decode_u_8_array_4(deserializer);
        var var_actual = sse_decode_u_8_array_4(deserializer);
        return ConsensusError_InvalidChecksum(
            expected: var_expected, actual: var_actual);
      case 3:
        return ConsensusError_NonMinimalVarInt();
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return ConsensusError_ParseFailed(var_field0);
      case 5:
        var var_field0 = sse_decode_u_8(deserializer);
        return ConsensusError_UnsupportedSegwitFlag(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DatabaseConfig sse_decode_database_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        var var_config =
            sse_decode_box_autoadd_sqlite_db_configuration(deserializer);
        return DatabaseConfig_Sqlite(config: var_config);
      case 2:
        var var_config =
            sse_decode_box_autoadd_sled_db_configuration(deserializer);
        return DatabaseConfig_Sled(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DescriptorError sse_decode_descriptor_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DescriptorError_InvalidHdKeyPath();
      case 1:
        return DescriptorError_InvalidDescriptorChecksum();
      case 2:
        return DescriptorError_HardenedDerivationXpub();
      case 3:
        return DescriptorError_MultiPath();
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Key(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Policy(var_field0);
      case 6:
        var var_field0 = sse_decode_u_8(deserializer);
        return DescriptorError_InvalidDescriptorCharacter(var_field0);
      case 7:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Bip32(var_field0);
      case 8:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Base58(var_field0);
      case 9:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Pk(var_field0);
      case 10:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Miniscript(var_field0);
      case 11:
        var var_field0 = sse_decode_String(deserializer);
        return DescriptorError_Hex(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ElectrumConfig sse_decode_electrum_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_socks5 = sse_decode_opt_String(deserializer);
    var var_retry = sse_decode_u_8(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_validateDomain = sse_decode_bool(deserializer);
    return ElectrumConfig(
        url: var_url,
        socks5: var_socks5,
        retry: var_retry,
        timeout: var_timeout,
        stopGap: var_stopGap,
        validateDomain: var_validateDomain);
  }

  @protected
  EsploraConfig sse_decode_esplora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_proxy = sse_decode_opt_String(deserializer);
    var var_concurrency = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_64(deserializer);
    return EsploraConfig(
        baseUrl: var_baseUrl,
        proxy: var_proxy,
        concurrency: var_concurrency,
        stopGap: var_stopGap,
        timeout: var_timeout);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  FeeRate sse_decode_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_satPerVb = sse_decode_f_32(deserializer);
    return FeeRate(satPerVb: var_satPerVb);
  }

  @protected
  HexError sse_decode_hex_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_8(deserializer);
        return HexError_InvalidChar(var_field0);
      case 1:
        var var_field0 = sse_decode_usize(deserializer);
        return HexError_OddLengthString(var_field0);
      case 2:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return HexError_InvalidLength(var_field0, var_field1);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  Input sse_decode_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Input(s: var_s);
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  List<Uint8List> sse_decode_list_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Uint8List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_u_8_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalUtxo> sse_decode_list_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ScriptAmount> sse_decode_list_script_amount(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScriptAmount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_script_amount(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionDetails> sse_decode_list_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxIn> sse_decode_list_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOut> sse_decode_list_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  LocalUtxo sse_decode_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    return LocalUtxo(
        outpoint: var_outpoint,
        txout: var_txout,
        keychain: var_keychain,
        isSpent: var_isSpent);
  }

  @protected
  LockTime sse_decode_lock_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Blocks(var_field0);
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return LockTime_Seconds(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkAddress? sse_decode_opt_box_autoadd_bdk_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkDescriptor? sse_decode_opt_box_autoadd_bdk_descriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_descriptor(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkScriptBuf? sse_decode_opt_box_autoadd_bdk_script_buf(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_script_buf(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkTransaction? sse_decode_opt_box_autoadd_bdk_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bdk_transaction(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockTime? sse_decode_opt_box_autoadd_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FeeRate? sse_decode_opt_box_autoadd_fee_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_fee_rate(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsbtSigHashType? sse_decode_opt_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_psbt_sig_hash_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (OutPoint, Input, int)?
      sse_decode_opt_box_autoadd_record_out_point_input_usize(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_out_point_input_usize(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  RpcSyncParams? sse_decode_opt_box_autoadd_rpc_sync_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_sync_params(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SignOptions? sse_decode_opt_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sign_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  Payload sse_decode_payload(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_pubkeyHash = sse_decode_String(deserializer);
        return Payload_PubkeyHash(pubkeyHash: var_pubkeyHash);
      case 1:
        var var_scriptHash = sse_decode_String(deserializer);
        return Payload_ScriptHash(scriptHash: var_scriptHash);
      case 2:
        var var_version = sse_decode_witness_version(deserializer);
        var var_program = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_WitnessProgram(
            version: var_version, program: var_program);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PsbtSigHashType sse_decode_psbt_sig_hash_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inner = sse_decode_u_32(deserializer);
    return PsbtSigHashType(inner: var_inner);
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (BdkPsbt, TransactionDetails) sse_decode_record_bdk_psbt_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_bdk_psbt(deserializer);
    var var_field1 = sse_decode_transaction_details(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (OutPoint, Input, int) sse_decode_record_out_point_input_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_out_point(deserializer);
    var var_field1 = sse_decode_input(deserializer);
    var var_field2 = sse_decode_usize(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  RpcConfig sse_decode_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_auth = sse_decode_auth(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_syncParams =
        sse_decode_opt_box_autoadd_rpc_sync_params(deserializer);
    return RpcConfig(
        url: var_url,
        auth: var_auth,
        network: var_network,
        walletName: var_walletName,
        syncParams: var_syncParams);
  }

  @protected
  RpcSyncParams sse_decode_rpc_sync_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startScriptCount = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_forceStartTime = sse_decode_bool(deserializer);
    var var_pollRateSec = sse_decode_u_64(deserializer);
    return RpcSyncParams(
        startScriptCount: var_startScriptCount,
        startTime: var_startTime,
        forceStartTime: var_forceStartTime,
        pollRateSec: var_pollRateSec);
  }

  @protected
  ScriptAmount sse_decode_script_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_script = sse_decode_bdk_script_buf(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    return ScriptAmount(script: var_script, amount: var_amount);
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_multiSig = sse_decode_bool(deserializer);
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
        multiSig: var_multiSig,
        trustWitnessUtxo: var_trustWitnessUtxo,
        assumeHeight: var_assumeHeight,
        allowAllSighashes: var_allowAllSighashes,
        removePartialSigs: var_removePartialSigs,
        tryFinalize: var_tryFinalize,
        signWithTapInternalKey: var_signWithTapInternalKey,
        allowGrinding: var_allowGrinding);
  }

  @protected
  SledDbConfiguration sse_decode_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_treeName = sse_decode_String(deserializer);
    return SledDbConfiguration(path: var_path, treeName: var_treeName);
  }

  @protected
  SqliteDbConfiguration sse_decode_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    return SqliteDbConfiguration(path: var_path);
  }

  @protected
  TransactionDetails sse_decode_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transaction =
        sse_decode_opt_box_autoadd_bdk_transaction(deserializer);
    var var_txid = sse_decode_String(deserializer);
    var var_received = sse_decode_u_64(deserializer);
    var var_sent = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_confirmationTime =
        sse_decode_opt_box_autoadd_block_time(deserializer);
    return TransactionDetails(
        transaction: var_transaction,
        txid: var_txid,
        received: var_received,
        sent: var_sent,
        fee: var_fee,
        confirmationTime: var_confirmationTime);
  }

  @protected
  TxIn sse_decode_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_bdk_script_buf(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_list_prim_u_8_strict(deserializer);
    return TxIn(
        previousOutput: var_previousOutput,
        scriptSig: var_scriptSig,
        sequence: var_sequence,
        witness: var_witness);
  }

  @protected
  TxOut sse_decode_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_bdk_script_buf(deserializer);
    return TxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  Variant sse_decode_variant(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Variant.values[inner];
  }

  @protected
  WitnessVersion sse_decode_witness_version(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WitnessVersion.values[inner];
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  int cst_encode_RustOpaque_AnyBlockchain(AnyBlockchain raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ExtendedDescriptor(ExtendedDescriptor raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_MutexPartiallySignedTransaction(
      MutexPartiallySignedTransaction raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_MutexbdkWalletAnyDatabase(
      MutexBdkWalletAnyDatabase raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bdkbitcoinAddress(BdkBitcoinAddress raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_bitcoinbip32DerivationPath(
      BitcoinBip32DerivationPath raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_keysDescriptorPublicKey(
      KeysDescriptorPublicKey raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_keysDescriptorSecretKey(
      KeysDescriptorSecretKey raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_keysKeyMap(KeysKeyMap raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_keysbip39Mnemonic(KeysBip39Mnemonic raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_change_spend_policy(ChangeSpendPolicy raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_keychain_kind(KeychainKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_variant(Variant raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_witness_version(WitnessVersion raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_word_count(WordCount raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  void sse_encode_RustOpaque_AnyBlockchain(
      AnyBlockchain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ExtendedDescriptor(
      ExtendedDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_MutexPartiallySignedTransaction(
      MutexPartiallySignedTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_MutexbdkWalletAnyDatabase(
      MutexBdkWalletAnyDatabase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_bdkbitcoinAddress(
      BdkBitcoinAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_bitcoinbip32DerivationPath(
      BitcoinBip32DerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_keysDescriptorPublicKey(
      KeysDescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_keysDescriptorSecretKey(
      KeysDescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_keysKeyMap(
      KeysKeyMap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_keysbip39Mnemonic(
      KeysBip39Mnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_error(AddressError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressError_Base58(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_Bech32(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_EmptyBech32Payload():
        sse_encode_i_32(2, serializer);
      case AddressError_InvalidBech32Variant(
          expected: final expected,
          found: final found
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_variant(expected, serializer);
        sse_encode_variant(found, serializer);
      case AddressError_InvalidWitnessVersion(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_u_8(field0, serializer);
      case AddressError_UnparsableWitnessVersion(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_MalformedWitnessVersion():
        sse_encode_i_32(6, serializer);
      case AddressError_InvalidWitnessProgramLength(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_usize(field0, serializer);
      case AddressError_InvalidSegwitV0ProgramLength(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_usize(field0, serializer);
      case AddressError_UncompressedPubkey():
        sse_encode_i_32(9, serializer);
      case AddressError_ExcessiveScriptSize():
        sse_encode_i_32(10, serializer);
      case AddressError_UnrecognizedScript():
        sse_encode_i_32(11, serializer);
      case AddressError_UnknownAddressType(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_String(field0, serializer);
      case AddressError_NetworkValidation(
          networkRequired: final networkRequired,
          networkFound: final networkFound,
          address: final address
        ):
        sse_encode_i_32(13, serializer);
        sse_encode_network(networkRequired, serializer);
        sse_encode_network(networkFound, serializer);
        sse_encode_String(address, serializer);
    }
  }

  @protected
  void sse_encode_address_index(AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressIndex_Increase():
        sse_encode_i_32(0, serializer);
      case AddressIndex_LastUnused():
        sse_encode_i_32(1, serializer);
      case AddressIndex_Peek(index: final index):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(index, serializer);
      case AddressIndex_Reset(index: final index):
        sse_encode_i_32(3, serializer);
        sse_encode_u_32(index, serializer);
    }
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_bdk_address(self.address, serializer);
  }

  @protected
  void sse_encode_auth(Auth self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Auth_None():
        sse_encode_i_32(0, serializer);
      case Auth_UserPass(username: final username, password: final password):
        sse_encode_i_32(1, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
      case Auth_Cookie(file: final file):
        sse_encode_i_32(2, serializer);
        sse_encode_String(file, serializer);
    }
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_bdk_address(BdkAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bdkbitcoinAddress(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_blockchain(BdkBlockchain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_AnyBlockchain(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_derivation_path(
      BdkDerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_bitcoinbip32DerivationPath(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor(BdkDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ExtendedDescriptor(
        self.extendedDescriptor, serializer);
    sse_encode_RustOpaque_keysKeyMap(self.keyMap, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor_public_key(
      BdkDescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_keysDescriptorPublicKey(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_descriptor_secret_key(
      BdkDescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_keysDescriptorSecretKey(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_error(BdkError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BdkError_Hex(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_hex_error(field0, serializer);
      case BdkError_Consensus(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_consensus_error(field0, serializer);
      case BdkError_Address(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_address_error(field0, serializer);
      case BdkError_Descriptor(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_descriptor_error(field0, serializer);
      case BdkError_InvalidU32Bytes(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
      case BdkError_Generic(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_ScriptDoesntHaveAddressForm():
        sse_encode_i_32(6, serializer);
      case BdkError_NoRecipients():
        sse_encode_i_32(7, serializer);
      case BdkError_NoUtxosSelected():
        sse_encode_i_32(8, serializer);
      case BdkError_OutputBelowDustLimit(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_usize(field0, serializer);
      case BdkError_InsufficientFunds(
          needed: final needed,
          available: final available
        ):
        sse_encode_i_32(10, serializer);
        sse_encode_u_64(needed, serializer);
        sse_encode_u_64(available, serializer);
      case BdkError_BnBTotalTriesExceeded():
        sse_encode_i_32(11, serializer);
      case BdkError_BnBNoExactMatch():
        sse_encode_i_32(12, serializer);
      case BdkError_UnknownUtxo():
        sse_encode_i_32(13, serializer);
      case BdkError_TransactionNotFound():
        sse_encode_i_32(14, serializer);
      case BdkError_TransactionConfirmed():
        sse_encode_i_32(15, serializer);
      case BdkError_IrreplaceableTransaction():
        sse_encode_i_32(16, serializer);
      case BdkError_FeeRateTooLow(needed: final needed):
        sse_encode_i_32(17, serializer);
        sse_encode_f_32(needed, serializer);
      case BdkError_FeeTooLow(needed: final needed):
        sse_encode_i_32(18, serializer);
        sse_encode_u_64(needed, serializer);
      case BdkError_FeeRateUnavailable():
        sse_encode_i_32(19, serializer);
      case BdkError_MissingKeyOrigin(field0: final field0):
        sse_encode_i_32(20, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Key(field0: final field0):
        sse_encode_i_32(21, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_ChecksumMismatch():
        sse_encode_i_32(22, serializer);
      case BdkError_SpendingPolicyRequired(field0: final field0):
        sse_encode_i_32(23, serializer);
        sse_encode_keychain_kind(field0, serializer);
      case BdkError_InvalidPolicyPathError(field0: final field0):
        sse_encode_i_32(24, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Signer(field0: final field0):
        sse_encode_i_32(25, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidNetwork(
          requested: final requested,
          found: final found
        ):
        sse_encode_i_32(26, serializer);
        sse_encode_network(requested, serializer);
        sse_encode_network(found, serializer);
      case BdkError_InvalidOutpoint(field0: final field0):
        sse_encode_i_32(27, serializer);
        sse_encode_box_autoadd_out_point(field0, serializer);
      case BdkError_Encode(field0: final field0):
        sse_encode_i_32(28, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Miniscript(field0: final field0):
        sse_encode_i_32(29, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_MiniscriptPsbt(field0: final field0):
        sse_encode_i_32(30, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Bip32(field0: final field0):
        sse_encode_i_32(31, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Bip39(field0: final field0):
        sse_encode_i_32(32, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Secp256k1(field0: final field0):
        sse_encode_i_32(33, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Json(field0: final field0):
        sse_encode_i_32(34, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Psbt(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_PsbtParse(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_MissingCachedScripts(
          field0: final field0,
          field1: final field1
        ):
        sse_encode_i_32(37, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
      case BdkError_Electrum(field0: final field0):
        sse_encode_i_32(38, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Esplora(field0: final field0):
        sse_encode_i_32(39, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Sled(field0: final field0):
        sse_encode_i_32(40, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Rpc(field0: final field0):
        sse_encode_i_32(41, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_Rusqlite(field0: final field0):
        sse_encode_i_32(42, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidInput(field0: final field0):
        sse_encode_i_32(43, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidLockTime(field0: final field0):
        sse_encode_i_32(44, serializer);
        sse_encode_String(field0, serializer);
      case BdkError_InvalidTransaction(field0: final field0):
        sse_encode_i_32(45, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_bdk_mnemonic(BdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_keysbip39Mnemonic(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_psbt(BdkPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_MutexPartiallySignedTransaction(self.ptr, serializer);
  }

  @protected
  void sse_encode_bdk_script_buf(BdkScriptBuf self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.bytes, serializer);
  }

  @protected
  void sse_encode_bdk_transaction(
      BdkTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.inner, serializer);
  }

  @protected
  void sse_encode_bdk_wallet(BdkWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_MutexbdkWalletAnyDatabase(self.ptr, serializer);
  }

  @protected
  void sse_encode_block_time(BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_blockchain_config(
      BlockchainConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BlockchainConfig_Electrum(config: final config):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_electrum_config(config, serializer);
      case BlockchainConfig_Esplora(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_esplora_config(config, serializer);
      case BlockchainConfig_Rpc(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_rpc_config(config, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address_error(
      AddressError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_address_index(
      AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_index(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_address(
      BdkAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_blockchain(
      BdkBlockchain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_blockchain(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_derivation_path(
      BdkDerivationPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_derivation_path(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor(
      BdkDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor_public_key(
      BdkDescriptorPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_descriptor_secret_key(
      BdkDescriptorSecretKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_descriptor_secret_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_mnemonic(
      BdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_psbt(BdkPsbt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_psbt(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_script_buf(
      BdkScriptBuf self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_script_buf(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_transaction(
      BdkTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_transaction(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bdk_wallet(
      BdkWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_wallet(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_block_time(
      BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_blockchain_config(
      BlockchainConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_blockchain_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_consensus_error(
      ConsensusError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_consensus_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_database_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_descriptor_error(
      DescriptorError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_descriptor_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_electrum_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_config(
      EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fee_rate(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_hex_error(
      HexError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_hex_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_input(Input self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_input(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_local_utxo(
      LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_local_utxo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lock_time(
      LockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lock_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_psbt_sig_hash_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
      RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_record_out_point_input_usize(
      (OutPoint, Input, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_out_point_input_usize(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_config(
      RpcConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_sync_params(
      RpcSyncParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_sync_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
      SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sled_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sqlite_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_change_spend_policy(
      ChangeSpendPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_consensus_error(
      ConsensusError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ConsensusError_Io(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case ConsensusError_OversizedVectorAllocation(
          requested: final requested,
          max: final max
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_usize(requested, serializer);
        sse_encode_usize(max, serializer);
      case ConsensusError_InvalidChecksum(
          expected: final expected,
          actual: final actual
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_4(expected, serializer);
        sse_encode_u_8_array_4(actual, serializer);
      case ConsensusError_NonMinimalVarInt():
        sse_encode_i_32(3, serializer);
      case ConsensusError_ParseFailed(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case ConsensusError_UnsupportedSegwitFlag(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_u_8(field0, serializer);
    }
  }

  @protected
  void sse_encode_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DatabaseConfig_Memory():
        sse_encode_i_32(0, serializer);
      case DatabaseConfig_Sqlite(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_sqlite_db_configuration(config, serializer);
      case DatabaseConfig_Sled(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_sled_db_configuration(config, serializer);
    }
  }

  @protected
  void sse_encode_descriptor_error(
      DescriptorError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DescriptorError_InvalidHdKeyPath():
        sse_encode_i_32(0, serializer);
      case DescriptorError_InvalidDescriptorChecksum():
        sse_encode_i_32(1, serializer);
      case DescriptorError_HardenedDerivationXpub():
        sse_encode_i_32(2, serializer);
      case DescriptorError_MultiPath():
        sse_encode_i_32(3, serializer);
      case DescriptorError_Key(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Policy(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_InvalidDescriptorCharacter(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_u_8(field0, serializer);
      case DescriptorError_Bip32(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Base58(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Pk(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Miniscript(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_String(field0, serializer);
      case DescriptorError_Hex(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.socks5, serializer);
    sse_encode_u_8(self.retry, serializer);
    sse_encode_opt_box_autoadd_u_8(self.timeout, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_bool(self.validateDomain, serializer);
  }

  @protected
  void sse_encode_esplora_config(EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.proxy, serializer);
    sse_encode_opt_box_autoadd_u_8(self.concurrency, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_opt_box_autoadd_u_64(self.timeout, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_fee_rate(FeeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.satPerVb, serializer);
  }

  @protected
  void sse_encode_hex_error(HexError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case HexError_InvalidChar(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8(field0, serializer);
      case HexError_OddLengthString(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_usize(field0, serializer);
      case HexError_InvalidLength(field0: final field0, field1: final field1):
        sse_encode_i_32(2, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_input(Input self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_list_prim_u_8_strict(
      List<Uint8List> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_u_8_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_utxo(
      List<LocalUtxo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
      List<OutPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_script_amount(
      List<ScriptAmount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_script_amount(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_details(
      List<TransactionDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_in(List<TxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_out(List<TxOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_local_utxo(LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out(self.txout, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
    sse_encode_bool(self.isSpent, serializer);
  }

  @protected
  void sse_encode_lock_time(LockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LockTime_Blocks(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(field0, serializer);
      case LockTime_Seconds(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_address(
      BdkAddress? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_address(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_descriptor(
      BdkDescriptor? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_descriptor(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_script_buf(
      BdkScriptBuf? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_script_buf(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bdk_transaction(
      BdkTransaction? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bdk_transaction(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_time(
      BlockTime? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_fee_rate(
      FeeRate? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_fee_rate(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_psbt_sig_hash_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
      RbfValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_record_out_point_input_usize(
      (OutPoint, Input, int)? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_out_point_input_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_sync_params(
      RpcSyncParams? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_sync_params(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sign_options(
      SignOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sign_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payload(Payload self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Payload_PubkeyHash(pubkeyHash: final pubkeyHash):
        sse_encode_i_32(0, serializer);
        sse_encode_String(pubkeyHash, serializer);
      case Payload_ScriptHash(scriptHash: final scriptHash):
        sse_encode_i_32(1, serializer);
        sse_encode_String(scriptHash, serializer);
      case Payload_WitnessProgram(
          version: final version,
          program: final program
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_witness_version(version, serializer);
        sse_encode_list_prim_u_8_strict(program, serializer);
    }
  }

  @protected
  void sse_encode_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.inner, serializer);
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_record_bdk_psbt_transaction_details(
      (BdkPsbt, TransactionDetails) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_psbt(self.$1, serializer);
    sse_encode_transaction_details(self.$2, serializer);
  }

  @protected
  void sse_encode_record_out_point_input_usize(
      (OutPoint, Input, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.$1, serializer);
    sse_encode_input(self.$2, serializer);
    sse_encode_usize(self.$3, serializer);
  }

  @protected
  void sse_encode_rpc_config(RpcConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_auth(self.auth, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_opt_box_autoadd_rpc_sync_params(self.syncParams, serializer);
  }

  @protected
  void sse_encode_rpc_sync_params(
      RpcSyncParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.startScriptCount, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_bool(self.forceStartTime, serializer);
    sse_encode_u_64(self.pollRateSec, serializer);
  }

  @protected
  void sse_encode_script_amount(ScriptAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bdk_script_buf(self.script, serializer);
    sse_encode_u_64(self.amount, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.multiSig, serializer);
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.treeName, serializer);
  }

  @protected
  void sse_encode_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_transaction_details(
      TransactionDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bdk_transaction(self.transaction, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.received, serializer);
    sse_encode_u_64(self.sent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_block_time(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_tx_in(TxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_bdk_script_buf(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_list_prim_u_8_strict(self.witness, serializer);
  }

  @protected
  void sse_encode_tx_out(TxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_bdk_script_buf(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_variant(Variant self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_witness_version(
      WitnessVersion self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}
