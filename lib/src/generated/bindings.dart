// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.51.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member

import 'dart:convert';
import 'dart:async';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import 'package:meta/meta.dart';
import 'package:meta/meta.dart';
import 'dart:ffi' as ffi;

part 'bindings.freezed.dart';

abstract class Rust {
  Future<BlockchainInstance> blockchainInit({required BlockchainConfig config, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBlockchainInitConstMeta;

  Future<int> getBlockchainHeight({required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHeightConstMeta;

  Future<String> getBlockchainHash(
      {required int blockchainHeight, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHashConstMeta;

  Future<String> broadcast({required String psbtStr, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBroadcastConstMeta;

  Future<String> psbtToTxid({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPsbtToTxidConstMeta;

  Future<Uint8List> extractTx({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExtractTxConstMeta;

  Future<double> getFeeRate({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetFeeRateConstMeta;

  Future<String> combinePsbt({required String psbtStr, required String other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCombinePsbtConstMeta;

  Future<TxBuilderResult> txBuilderFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      required List<OutPoint> unspendable,
      required bool manuallySelectedOnly,
      required bool onlySpendChange,
      required bool doNotSpendChange,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      String? drainTo,
      required bool enableRbf,
      int? nSequence,
      required Uint8List data,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxBuilderFinishConstMeta;

  Future<String> bumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required WalletInstance wallet,
      required bool enableRbf,
      int? nSequence,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBumpFeeTxBuilderFinishConstMeta;

  Future<String> descriptorSecretExtend({required String xprv, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretExtendConstMeta;

  Future<String> descriptorSecretDerive({required String xprv, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretDeriveConstMeta;

  Future<Uint8List> descriptorSecretAsSecretBytes({String? descriptorSecret, String? xprv, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretAsSecretBytesConstMeta;

  Future<String> descriptorSecretAsPublic({String? descriptorSecret, String? xprv, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretAsPublicConstMeta;

  Future<String> createDescriptorSecret(
      {required Network network, required String mnemonic, String? password, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorSecretConstMeta;

  Future<String> createDerivationPath({required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDerivationPathConstMeta;

  Future<String> createDescriptorPublic({String? xpub, required String path, required bool derive, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorPublicConstMeta;

  Future<String> initScript({required Uint8List rawOutputScript, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitScriptConstMeta;

  Future<String> initAddress({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitAddressConstMeta;

  Future<String> addressToScriptPubkeyHex({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddressToScriptPubkeyHexConstMeta;

  Future<WalletInstance> walletInit(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWalletInitConstMeta;

  Future<AddressInfo> getAddress({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetAddressConstMeta;

  Future<void> syncWallet({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncWalletConstMeta;

  Future<Balance> getBalance({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBalanceConstMeta;

  Future<List<LocalUtxo>> listUnspentOutputs({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kListUnspentOutputsConstMeta;

  Future<List<TransactionDetails>> getTransactions({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetTransactionsConstMeta;

  Future<String?> sign(
      {required WalletInstance wallet, required String psbtStr, required bool isMultiSig, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSignConstMeta;

  Future<Network> getNetwork({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetNetworkConstMeta;

  Future<List<LocalUtxo>> listUnspent({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kListUnspentConstMeta;

  Future<String> generateSeedFromWordCount({required WordCount wordCount, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromWordCountConstMeta;

  Future<String> generateSeedFromString({required String mnemonic, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromStringConstMeta;

  Future<String> generateSeedFromEntropy({required Uint8List entropy, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromEntropyConstMeta;

  DropFnType get dropOpaqueBlockchainInstance;
  ShareFnType get shareOpaqueBlockchainInstance;
  OpaqueTypeFinalizer get BlockchainInstanceFinalizer;

  DropFnType get dropOpaqueWalletInstance;
  ShareFnType get shareOpaqueWalletInstance;
  OpaqueTypeFinalizer get WalletInstanceFinalizer;
}

@sealed
class BlockchainInstance extends FrbOpaque {
  final Rust bridge;
  BlockchainInstance.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueBlockchainInstance;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueBlockchainInstance;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.BlockchainInstanceFinalizer;
}

@sealed
class WalletInstance extends FrbOpaque {
  final Rust bridge;
  WalletInstance.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueWalletInstance;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueWalletInstance;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.WalletInstanceFinalizer;
}

/// The address index selection strategy to use to derived an address from the wallet's external
/// descriptor.
enum AddressIndex {
  ///Return a new address after incrementing the current descriptor index.
  New,

  ///Return the address for the current descriptor index if it has not been used in a received transaction. Otherwise return a new address as with AddressIndex.New.
  ///Use with caution, if the wallet has not yet detected an address has been used it could return an already used address. This function is primarily meant for situations where the caller is untrusted; for example when deriving donation addresses on-demand for a public web page.
  LastUnused,
}

///A derived address and the index it was found at For convenience this automatically derefs to Address
class AddressInfo {
  ///Child index of this address
  final int index;

  /// Address
  final String address;

  AddressInfo({
    required this.index,
    required this.address,
  });
}

/// Local Wallet's Balance
class Balance {
  final int immature;

  /// Unconfirmed UTXOs generated by a wallet tx
  final int trustedPending;

  /// Unconfirmed UTXOs received from an external wallet
  final int untrustedPending;

  /// Confirmed and immediately spendable balance
  final int confirmed;

  /// Get sum of trusted_pending and confirmed coins
  final int spendable;

  /// Get the whole balance visible to the wallet
  final int total;

  Balance({
    required this.immature,
    required this.trustedPending,
    required this.untrustedPending,
    required this.confirmed,
    required this.spendable,
    required this.total,
  });
}

///Block height and timestamp of a block
class BlockTime {
  ///Confirmation block height
  final int height;

  ///Confirmation block timestamp
  final int timestamp;

  BlockTime({
    required this.height,
    required this.timestamp,
  });
}

@freezed
class BlockchainConfig with _$BlockchainConfig {
  const factory BlockchainConfig.electrum({
    required ElectrumConfig config,
  }) = BlockchainConfig_Electrum;
  const factory BlockchainConfig.esplora({
    required EsploraConfig config,
  }) = BlockchainConfig_Esplora;
}

@freezed
class DatabaseConfig with _$DatabaseConfig {
  const factory DatabaseConfig.memory() = DatabaseConfig_Memory;

  ///Simple key-value embedded database based on sled
  const factory DatabaseConfig.sqlite({
    required SqliteDbConfiguration config,
  }) = DatabaseConfig_Sqlite;

  ///Sqlite embedded database using rusqlite
  const factory DatabaseConfig.sled({
    required SledDbConfiguration config,
  }) = DatabaseConfig_Sled;
}

/// Configuration for an ElectrumBlockchain
class ElectrumConfig {
  ///URL of the Electrum server (such as ElectrumX, Esplora, BWT) may start with ssl:// or tcp:// and include a port
  ///eg. ssl://electrum.blockstream.info:60002
  final String url;

  ///URL of the socks5 proxy server or a Tor service
  final String? socks5;

  ///Request retry count
  final int retry;

  ///Request timeout (seconds)
  final int? timeout;

  ///Stop searching addresses for transactions after finding an unused gap of this length
  final int stopGap;

  ElectrumConfig({
    required this.url,
    this.socks5,
    required this.retry,
    this.timeout,
    required this.stopGap,
  });
}

///Configuration for an EsploraBlockchain
class EsploraConfig {
  ///Base URL of the esplora service
  ///eg. https://blockstream.info/api/
  final String baseUrl;

  ///  Optional URL of the proxy to use to make requests to the Esplora server
  /// The string should be formatted as: <protocol>://<user>:<password>@host:<port>.
  /// Note that the format of this value and the supported protocols change slightly between the sync version of esplora (using ureq) and the async version (using reqwest).
  ///  For more details check with the documentation of the two crates. Both of them are compiled with the socks feature enabled.
  /// The proxy is ignored when targeting wasm32.
  final String? proxy;

  ///Number of parallel requests sent to the esplora service (default: 4)
  final int? concurrency;

  ///Stop searching addresses for transactions after finding an unused gap of this length.
  final int stopGap;

  ///Socket timeout.
  final int? timeout;

  EsploraConfig({
    required this.baseUrl,
    this.proxy,
    this.concurrency,
    required this.stopGap,
    this.timeout,
  });
}

/// Unspent outputs of this wallet
class LocalUtxo {
  /// Reference to a transaction output
  final OutPoint outpoint;

  ///Transaction output
  final TxOut txout;

  ///Whether this UTXO is spent or not
  final bool isSpent;

  LocalUtxo({
    required this.outpoint,
    required this.txout,
    required this.isSpent,
  });
}

///The cryptocurrency to act on
enum Network {
  ///Bitcoin’s testnet
  Testnet,

  ///Bitcoin’s regtest
  Regtest,

  ///Classic Bitcoin
  Bitcoin,

  ///Bitcoin’s signet
  Signet,
}

/// A reference to a transaction output.
class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  OutPoint({
    required this.txid,
    required this.vout,
  });
}

/// A output script and an amount of satoshis.
class ScriptAmount {
  final String script;
  final int amount;

  ScriptAmount({
    required this.script,
    required this.amount,
  });
}

///Configuration type for a sled Tree database
class SledDbConfiguration {
  ///Main directory of the db
  final String path;

  ///Name of the database tree, a separated namespace for the data
  final String treeName;

  SledDbConfiguration({
    required this.path,
    required this.treeName,
  });
}

///Configuration type for a SqliteDatabase database
class SqliteDbConfiguration {
  ///Main directory of the db
  final String path;

  SqliteDbConfiguration({
    required this.path,
  });
}

///A wallet transaction
class TransactionDetails {
  /// Transaction id.
  final String txid;

  /// Received value (sats)
  /// Sum of owned outputs of this transaction.
  final int received;

  /// Sent value (sats)
  /// Sum of owned inputs of this transaction.
  final int sent;

  /// Fee value (sats) if confirmed.
  /// The availability of the fee depends on the backend. It's never None with an Electrum
  /// Server backend, but it could be None with a Bitcoin RPC node without txindex that receive
  /// funds while offline.
  final int? fee;

  /// If the transaction is confirmed, contains height and timestamp of the block containing the
  /// transaction, unconfirmed transaction contains `None`.
  final BlockTime? confirmationTime;

  TransactionDetails({
    required this.txid,
    required this.received,
    required this.sent,
    this.fee,
    this.confirmationTime,
  });
}

/// The result after calling the TxBuilder finish() function. Contains unsigned PSBT and
/// transaction details.
class TxBuilderResult {
  final String psbt;

  ///A wallet transaction
  final TransactionDetails transactionDetails;

  TxBuilderResult({
    required this.psbt,
    required this.transactionDetails,
  });
}

///A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final int value;

  /// The address of the output.
  final String address;

  TxOut({
    required this.value,
    required this.address,
  });
}

///Type describing entropy length (aka word count) in the mnemonic
enum WordCount {
  ///12 words mnemonic (128 bits entropy)
  Words12,

  ///18 words mnemonic (192 bits entropy)
  Words18,

  ///24 words mnemonic (256 bits entropy)
  Words24,
}

class RustImpl implements Rust {
  final RustPlatform _platform;
  factory RustImpl(ExternalLibrary dylib) => RustImpl.raw(RustPlatform(dylib));

  /// Only valid on web/WASM platforms.
  factory RustImpl.wasm(FutureOr<WasmModule> module) => RustImpl(module as ExternalLibrary);
  RustImpl.raw(this._platform);
  Future<BlockchainInstance> blockchainInit({required BlockchainConfig config, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_blockchain_config(config);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_blockchain_init(port_, arg0),
      parseSuccessData: _wire2api_BlockchainInstance,
      constMeta: kBlockchainInitConstMeta,
      argValues: [config],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBlockchainInitConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "blockchain_init",
        argNames: ["config"],
      );

  Future<int> getBlockchainHeight({required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_blockchain_height(port_, arg0),
      parseSuccessData: _wire2api_u32,
      constMeta: kGetBlockchainHeightConstMeta,
      argValues: [blockchain],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHeightConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_blockchain_height",
        argNames: ["blockchain"],
      );

  Future<String> getBlockchainHash(
      {required int blockchainHeight, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = api2wire_u32(blockchainHeight);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_blockchain_hash(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kGetBlockchainHashConstMeta,
      argValues: [blockchainHeight, blockchain],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHashConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_blockchain_hash",
        argNames: ["blockchainHeight", "blockchain"],
      );

  Future<String> broadcast({required String psbtStr, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_broadcast(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kBroadcastConstMeta,
      argValues: [psbtStr, blockchain],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBroadcastConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "broadcast",
        argNames: ["psbtStr", "blockchain"],
      );

  Future<String> psbtToTxid({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_psbt_to_txid(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kPsbtToTxidConstMeta,
      argValues: [psbtStr],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPsbtToTxidConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "psbt_to_txid",
        argNames: ["psbtStr"],
      );

  Future<Uint8List> extractTx({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_extract_tx(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kExtractTxConstMeta,
      argValues: [psbtStr],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kExtractTxConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "extract_tx",
        argNames: ["psbtStr"],
      );

  Future<double> getFeeRate({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_fee_rate(port_, arg0),
      parseSuccessData: _wire2api_f32,
      constMeta: kGetFeeRateConstMeta,
      argValues: [psbtStr],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetFeeRateConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_fee_rate",
        argNames: ["psbtStr"],
      );

  Future<String> combinePsbt({required String psbtStr, required String other, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    var arg1 = _platform.api2wire_String(other);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_combine_psbt(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kCombinePsbtConstMeta,
      argValues: [psbtStr, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCombinePsbtConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "combine_psbt",
        argNames: ["psbtStr", "other"],
      );

  Future<TxBuilderResult> txBuilderFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      required List<OutPoint> unspendable,
      required bool manuallySelectedOnly,
      required bool onlySpendChange,
      required bool doNotSpendChange,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      String? drainTo,
      required bool enableRbf,
      int? nSequence,
      required Uint8List data,
      dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_list_script_amount(recipients);
    var arg2 = _platform.api2wire_list_out_point(utxos);
    var arg3 = _platform.api2wire_list_out_point(unspendable);
    var arg4 = manuallySelectedOnly;
    var arg5 = onlySpendChange;
    var arg6 = doNotSpendChange;
    var arg7 = _platform.api2wire_opt_box_autoadd_f32(feeRate);
    var arg8 = _platform.api2wire_opt_box_autoadd_u64(feeAbsolute);
    var arg9 = drainWallet;
    var arg10 = _platform.api2wire_opt_String(drainTo);
    var arg11 = enableRbf;
    var arg12 = _platform.api2wire_opt_box_autoadd_u32(nSequence);
    var arg13 = _platform.api2wire_uint_8_list(data);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_tx_builder_finish(
          port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13),
      parseSuccessData: _wire2api_tx_builder_result,
      constMeta: kTxBuilderFinishConstMeta,
      argValues: [
        wallet,
        recipients,
        utxos,
        unspendable,
        manuallySelectedOnly,
        onlySpendChange,
        doNotSpendChange,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        enableRbf,
        nSequence,
        data
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTxBuilderFinishConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "tx_builder_finish",
        argNames: [
          "wallet",
          "recipients",
          "utxos",
          "unspendable",
          "manuallySelectedOnly",
          "onlySpendChange",
          "doNotSpendChange",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "enableRbf",
          "nSequence",
          "data"
        ],
      );

  Future<String> bumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required WalletInstance wallet,
      required bool enableRbf,
      int? nSequence,
      dynamic hint}) {
    var arg0 = _platform.api2wire_String(txid);
    var arg1 = api2wire_f32(feeRate);
    var arg2 = _platform.api2wire_opt_String(allowShrinking);
    var arg3 = _platform.api2wire_WalletInstance(wallet);
    var arg4 = enableRbf;
    var arg5 = _platform.api2wire_opt_box_autoadd_u32(nSequence);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bump_fee_tx_builder_finish(port_, arg0, arg1, arg2, arg3, arg4, arg5),
      parseSuccessData: _wire2api_String,
      constMeta: kBumpFeeTxBuilderFinishConstMeta,
      argValues: [txid, feeRate, allowShrinking, wallet, enableRbf, nSequence],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBumpFeeTxBuilderFinishConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bump_fee_tx_builder_finish",
        argNames: ["txid", "feeRate", "allowShrinking", "wallet", "enableRbf", "nSequence"],
      );

  Future<String> descriptorSecretExtend({required String xprv, required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(xprv);
    var arg1 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_secret_extend(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kDescriptorSecretExtendConstMeta,
      argValues: [xprv, path],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretExtendConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_secret_extend",
        argNames: ["xprv", "path"],
      );

  Future<String> descriptorSecretDerive({required String xprv, required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(xprv);
    var arg1 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_secret_derive(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kDescriptorSecretDeriveConstMeta,
      argValues: [xprv, path],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretDeriveConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_secret_derive",
        argNames: ["xprv", "path"],
      );

  Future<Uint8List> descriptorSecretAsSecretBytes({String? descriptorSecret, String? xprv, dynamic hint}) {
    var arg0 = _platform.api2wire_opt_String(descriptorSecret);
    var arg1 = _platform.api2wire_opt_String(xprv);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_secret_as_secret_bytes(port_, arg0, arg1),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kDescriptorSecretAsSecretBytesConstMeta,
      argValues: [descriptorSecret, xprv],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretAsSecretBytesConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_secret_as_secret_bytes",
        argNames: ["descriptorSecret", "xprv"],
      );

  Future<String> descriptorSecretAsPublic({String? descriptorSecret, String? xprv, dynamic hint}) {
    var arg0 = _platform.api2wire_opt_String(descriptorSecret);
    var arg1 = _platform.api2wire_opt_String(xprv);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_secret_as_public(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kDescriptorSecretAsPublicConstMeta,
      argValues: [descriptorSecret, xprv],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretAsPublicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_secret_as_public",
        argNames: ["descriptorSecret", "xprv"],
      );

  Future<String> createDescriptorSecret(
      {required Network network, required String mnemonic, String? password, dynamic hint}) {
    var arg0 = api2wire_network(network);
    var arg1 = _platform.api2wire_String(mnemonic);
    var arg2 = _platform.api2wire_opt_String(password);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_descriptor_secret(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDescriptorSecretConstMeta,
      argValues: [network, mnemonic, password],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorSecretConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_descriptor_secret",
        argNames: ["network", "mnemonic", "password"],
      );

  Future<String> createDerivationPath({required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_derivation_path(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDerivationPathConstMeta,
      argValues: [path],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDerivationPathConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_derivation_path",
        argNames: ["path"],
      );

  Future<String> createDescriptorPublic({String? xpub, required String path, required bool derive, dynamic hint}) {
    var arg0 = _platform.api2wire_opt_String(xpub);
    var arg1 = _platform.api2wire_String(path);
    var arg2 = derive;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_descriptor_public(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDescriptorPublicConstMeta,
      argValues: [xpub, path, derive],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorPublicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_descriptor_public",
        argNames: ["xpub", "path", "derive"],
      );

  Future<String> initScript({required Uint8List rawOutputScript, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(rawOutputScript);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_init_script(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kInitScriptConstMeta,
      argValues: [rawOutputScript],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kInitScriptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "init_script",
        argNames: ["rawOutputScript"],
      );

  Future<String> initAddress({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_init_address(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kInitAddressConstMeta,
      argValues: [address],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kInitAddressConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "init_address",
        argNames: ["address"],
      );

  Future<String> addressToScriptPubkeyHex({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_address_to_script_pubkey_hex(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kAddressToScriptPubkeyHexConstMeta,
      argValues: [address],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAddressToScriptPubkeyHexConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "address_to_script_pubkey_hex",
        argNames: ["address"],
      );

  Future<WalletInstance> walletInit(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint}) {
    var arg0 = _platform.api2wire_String(descriptor);
    var arg1 = _platform.api2wire_opt_String(changeDescriptor);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_box_autoadd_database_config(databaseConfig);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_wallet_init(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_WalletInstance,
      constMeta: kWalletInitConstMeta,
      argValues: [descriptor, changeDescriptor, network, databaseConfig],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWalletInitConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "wallet_init",
        argNames: ["descriptor", "changeDescriptor", "network", "databaseConfig"],
      );

  Future<AddressInfo> getAddress({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = api2wire_address_index(addressIndex);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_address(port_, arg0, arg1),
      parseSuccessData: _wire2api_address_info,
      constMeta: kGetAddressConstMeta,
      argValues: [wallet, addressIndex],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetAddressConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_address",
        argNames: ["wallet", "addressIndex"],
      );

  Future<void> syncWallet({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sync_wallet(port_, arg0, arg1),
      parseSuccessData: _wire2api_unit,
      constMeta: kSyncWalletConstMeta,
      argValues: [wallet, blockchain],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSyncWalletConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "sync_wallet",
        argNames: ["wallet", "blockchain"],
      );

  Future<Balance> getBalance({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_balance(port_, arg0),
      parseSuccessData: _wire2api_balance,
      constMeta: kGetBalanceConstMeta,
      argValues: [wallet],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetBalanceConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_balance",
        argNames: ["wallet"],
      );

  Future<List<LocalUtxo>> listUnspentOutputs({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_list_unspent_outputs(port_, arg0),
      parseSuccessData: _wire2api_list_local_utxo,
      constMeta: kListUnspentOutputsConstMeta,
      argValues: [wallet],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kListUnspentOutputsConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "list_unspent_outputs",
        argNames: ["wallet"],
      );

  Future<List<TransactionDetails>> getTransactions({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_transactions(port_, arg0),
      parseSuccessData: _wire2api_list_transaction_details,
      constMeta: kGetTransactionsConstMeta,
      argValues: [wallet],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetTransactionsConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_transactions",
        argNames: ["wallet"],
      );

  Future<String?> sign(
      {required WalletInstance wallet, required String psbtStr, required bool isMultiSig, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_String(psbtStr);
    var arg2 = isMultiSig;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sign(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_opt_String,
      constMeta: kSignConstMeta,
      argValues: [wallet, psbtStr, isMultiSig],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSignConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "sign",
        argNames: ["wallet", "psbtStr", "isMultiSig"],
      );

  Future<Network> getNetwork({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_network(port_, arg0),
      parseSuccessData: _wire2api_network,
      constMeta: kGetNetworkConstMeta,
      argValues: [wallet],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetNetworkConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_network",
        argNames: ["wallet"],
      );

  Future<List<LocalUtxo>> listUnspent({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_list_unspent(port_, arg0),
      parseSuccessData: _wire2api_list_local_utxo,
      constMeta: kListUnspentConstMeta,
      argValues: [wallet],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kListUnspentConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "list_unspent",
        argNames: ["wallet"],
      );

  Future<String> generateSeedFromWordCount({required WordCount wordCount, dynamic hint}) {
    var arg0 = api2wire_word_count(wordCount);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_word_count(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromWordCountConstMeta,
      argValues: [wordCount],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromWordCountConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_word_count",
        argNames: ["wordCount"],
      );

  Future<String> generateSeedFromString({required String mnemonic, dynamic hint}) {
    var arg0 = _platform.api2wire_String(mnemonic);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_string(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromStringConstMeta,
      argValues: [mnemonic],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromStringConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_string",
        argNames: ["mnemonic"],
      );

  Future<String> generateSeedFromEntropy({required Uint8List entropy, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(entropy);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_entropy(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromEntropyConstMeta,
      argValues: [entropy],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromEntropyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_entropy",
        argNames: ["entropy"],
      );

  DropFnType get dropOpaqueBlockchainInstance => _platform.inner.drop_opaque_BlockchainInstance;
  ShareFnType get shareOpaqueBlockchainInstance => _platform.inner.share_opaque_BlockchainInstance;
  OpaqueTypeFinalizer get BlockchainInstanceFinalizer => _platform.BlockchainInstanceFinalizer;

  DropFnType get dropOpaqueWalletInstance => _platform.inner.drop_opaque_WalletInstance;
  ShareFnType get shareOpaqueWalletInstance => _platform.inner.share_opaque_WalletInstance;
  OpaqueTypeFinalizer get WalletInstanceFinalizer => _platform.WalletInstanceFinalizer;

// Section: wire2api

  BlockchainInstance _wire2api_BlockchainInstance(dynamic raw) {
    return BlockchainInstance.fromRaw(raw[0], raw[1], this);
  }

  String _wire2api_String(dynamic raw) {
    return raw as String;
  }

  WalletInstance _wire2api_WalletInstance(dynamic raw) {
    return WalletInstance.fromRaw(raw[0], raw[1], this);
  }

  AddressInfo _wire2api_address_info(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: _wire2api_u32(arr[0]),
      address: _wire2api_String(arr[1]),
    );
  }

  Balance _wire2api_balance(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: _wire2api_u64(arr[0]),
      trustedPending: _wire2api_u64(arr[1]),
      untrustedPending: _wire2api_u64(arr[2]),
      confirmed: _wire2api_u64(arr[3]),
      spendable: _wire2api_u64(arr[4]),
      total: _wire2api_u64(arr[5]),
    );
  }

  BlockTime _wire2api_block_time(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: _wire2api_u32(arr[0]),
      timestamp: _wire2api_u64(arr[1]),
    );
  }

  bool _wire2api_bool(dynamic raw) {
    return raw as bool;
  }

  BlockTime _wire2api_box_autoadd_block_time(dynamic raw) {
    return _wire2api_block_time(raw);
  }

  int _wire2api_box_autoadd_u64(dynamic raw) {
    return _wire2api_u64(raw);
  }

  double _wire2api_f32(dynamic raw) {
    return raw as double;
  }

  int _wire2api_i32(dynamic raw) {
    return raw as int;
  }

  List<LocalUtxo> _wire2api_list_local_utxo(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_local_utxo).toList();
  }

  List<TransactionDetails> _wire2api_list_transaction_details(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_transaction_details).toList();
  }

  LocalUtxo _wire2api_local_utxo(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LocalUtxo(
      outpoint: _wire2api_out_point(arr[0]),
      txout: _wire2api_tx_out(arr[1]),
      isSpent: _wire2api_bool(arr[2]),
    );
  }

  Network _wire2api_network(dynamic raw) {
    return Network.values[raw];
  }

  String? _wire2api_opt_String(dynamic raw) {
    return raw == null ? null : _wire2api_String(raw);
  }

  BlockTime? _wire2api_opt_box_autoadd_block_time(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_block_time(raw);
  }

  int? _wire2api_opt_box_autoadd_u64(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_u64(raw);
  }

  OutPoint _wire2api_out_point(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: _wire2api_String(arr[0]),
      vout: _wire2api_u32(arr[1]),
    );
  }

  TransactionDetails _wire2api_transaction_details(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return TransactionDetails(
      txid: _wire2api_String(arr[0]),
      received: _wire2api_u64(arr[1]),
      sent: _wire2api_u64(arr[2]),
      fee: _wire2api_opt_box_autoadd_u64(arr[3]),
      confirmationTime: _wire2api_opt_box_autoadd_block_time(arr[4]),
    );
  }

  TxBuilderResult _wire2api_tx_builder_result(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxBuilderResult(
      psbt: _wire2api_String(arr[0]),
      transactionDetails: _wire2api_transaction_details(arr[1]),
    );
  }

  TxOut _wire2api_tx_out(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: _wire2api_u64(arr[0]),
      address: _wire2api_String(arr[1]),
    );
  }

  int _wire2api_u32(dynamic raw) {
    return raw as int;
  }

  int _wire2api_u64(dynamic raw) {
    return castInt(raw);
  }

  int _wire2api_u8(dynamic raw) {
    return raw as int;
  }

  Uint8List _wire2api_uint_8_list(dynamic raw) {
    return raw as Uint8List;
  }

  void _wire2api_unit(dynamic raw) {
    return;
  }
}

// Section: api2wire

@protected
int api2wire_address_index(AddressIndex raw) {
  return api2wire_i32(raw.index);
}

@protected
bool api2wire_bool(bool raw) {
  return raw;
}

@protected
double api2wire_f32(double raw) {
  return raw;
}

@protected
int api2wire_i32(int raw) {
  return raw;
}

@protected
int api2wire_network(Network raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_u32(int raw) {
  return raw;
}

@protected
int api2wire_u8(int raw) {
  return raw;
}

@protected
int api2wire_word_count(WordCount raw) {
  return api2wire_i32(raw.index);
}
// Section: finalizer

class RustPlatform extends FlutterRustBridgeBase<RustWire> {
  RustPlatform(ffi.DynamicLibrary dylib) : super(RustWire(dylib));
// Section: api2wire

  @protected
  wire_BlockchainInstance api2wire_BlockchainInstance(BlockchainInstance raw) {
    final ptr = inner.new_BlockchainInstance();
    _api_fill_to_wire_BlockchainInstance(raw, ptr);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_uint_8_list> api2wire_String(String raw) {
    return api2wire_uint_8_list(utf8.encoder.convert(raw));
  }

  @protected
  wire_WalletInstance api2wire_WalletInstance(WalletInstance raw) {
    final ptr = inner.new_WalletInstance();
    _api_fill_to_wire_WalletInstance(raw, ptr);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_BlockchainConfig> api2wire_box_autoadd_blockchain_config(BlockchainConfig raw) {
    final ptr = inner.new_box_autoadd_blockchain_config_0();
    _api_fill_to_wire_blockchain_config(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_DatabaseConfig> api2wire_box_autoadd_database_config(DatabaseConfig raw) {
    final ptr = inner.new_box_autoadd_database_config_0();
    _api_fill_to_wire_database_config(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_ElectrumConfig> api2wire_box_autoadd_electrum_config(ElectrumConfig raw) {
    final ptr = inner.new_box_autoadd_electrum_config_0();
    _api_fill_to_wire_electrum_config(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_EsploraConfig> api2wire_box_autoadd_esplora_config(EsploraConfig raw) {
    final ptr = inner.new_box_autoadd_esplora_config_0();
    _api_fill_to_wire_esplora_config(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<ffi.Float> api2wire_box_autoadd_f32(double raw) {
    return inner.new_box_autoadd_f32_0(api2wire_f32(raw));
  }

  @protected
  ffi.Pointer<wire_SledDbConfiguration> api2wire_box_autoadd_sled_db_configuration(SledDbConfiguration raw) {
    final ptr = inner.new_box_autoadd_sled_db_configuration_0();
    _api_fill_to_wire_sled_db_configuration(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<wire_SqliteDbConfiguration> api2wire_box_autoadd_sqlite_db_configuration(SqliteDbConfiguration raw) {
    final ptr = inner.new_box_autoadd_sqlite_db_configuration_0();
    _api_fill_to_wire_sqlite_db_configuration(raw, ptr.ref);
    return ptr;
  }

  @protected
  ffi.Pointer<ffi.Uint32> api2wire_box_autoadd_u32(int raw) {
    return inner.new_box_autoadd_u32_0(api2wire_u32(raw));
  }

  @protected
  ffi.Pointer<ffi.Uint64> api2wire_box_autoadd_u64(int raw) {
    return inner.new_box_autoadd_u64_0(api2wire_u64(raw));
  }

  @protected
  ffi.Pointer<ffi.Uint8> api2wire_box_autoadd_u8(int raw) {
    return inner.new_box_autoadd_u8_0(api2wire_u8(raw));
  }

  @protected
  ffi.Pointer<wire_list_out_point> api2wire_list_out_point(List<OutPoint> raw) {
    final ans = inner.new_list_out_point_0(raw.length);
    for (var i = 0; i < raw.length; ++i) {
      _api_fill_to_wire_out_point(raw[i], ans.ref.ptr[i]);
    }
    return ans;
  }

  @protected
  ffi.Pointer<wire_list_script_amount> api2wire_list_script_amount(List<ScriptAmount> raw) {
    final ans = inner.new_list_script_amount_0(raw.length);
    for (var i = 0; i < raw.length; ++i) {
      _api_fill_to_wire_script_amount(raw[i], ans.ref.ptr[i]);
    }
    return ans;
  }

  @protected
  ffi.Pointer<wire_uint_8_list> api2wire_opt_String(String? raw) {
    return raw == null ? ffi.nullptr : api2wire_String(raw);
  }

  @protected
  ffi.Pointer<ffi.Float> api2wire_opt_box_autoadd_f32(double? raw) {
    return raw == null ? ffi.nullptr : api2wire_box_autoadd_f32(raw);
  }

  @protected
  ffi.Pointer<ffi.Uint32> api2wire_opt_box_autoadd_u32(int? raw) {
    return raw == null ? ffi.nullptr : api2wire_box_autoadd_u32(raw);
  }

  @protected
  ffi.Pointer<ffi.Uint64> api2wire_opt_box_autoadd_u64(int? raw) {
    return raw == null ? ffi.nullptr : api2wire_box_autoadd_u64(raw);
  }

  @protected
  ffi.Pointer<ffi.Uint8> api2wire_opt_box_autoadd_u8(int? raw) {
    return raw == null ? ffi.nullptr : api2wire_box_autoadd_u8(raw);
  }

  @protected
  int api2wire_u64(int raw) {
    return raw;
  }

  @protected
  ffi.Pointer<wire_uint_8_list> api2wire_uint_8_list(Uint8List raw) {
    final ans = inner.new_uint_8_list_0(raw.length);
    ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);
    return ans;
  }

// Section: finalizer

  late final OpaqueTypeFinalizer _BlockchainInstanceFinalizer =
      OpaqueTypeFinalizer(inner._drop_opaque_BlockchainInstancePtr);
  OpaqueTypeFinalizer get BlockchainInstanceFinalizer => _BlockchainInstanceFinalizer;
  late final OpaqueTypeFinalizer _WalletInstanceFinalizer = OpaqueTypeFinalizer(inner._drop_opaque_WalletInstancePtr);
  OpaqueTypeFinalizer get WalletInstanceFinalizer => _WalletInstanceFinalizer;
// Section: api_fill_to_wire

  void _api_fill_to_wire_BlockchainInstance(BlockchainInstance apiObj, wire_BlockchainInstance wireObj) {
    wireObj.ptr = apiObj.share();
  }

  void _api_fill_to_wire_WalletInstance(WalletInstance apiObj, wire_WalletInstance wireObj) {
    wireObj.ptr = apiObj.share();
  }

  void _api_fill_to_wire_blockchain_config(BlockchainConfig apiObj, wire_BlockchainConfig wireObj) {
    if (apiObj is BlockchainConfig_Electrum) {
      var pre_config = api2wire_box_autoadd_electrum_config(apiObj.config);
      wireObj.tag = 0;
      wireObj.kind = inner.inflate_BlockchainConfig_Electrum();
      wireObj.kind.ref.Electrum.ref.config = pre_config;
      return;
    }
    if (apiObj is BlockchainConfig_Esplora) {
      var pre_config = api2wire_box_autoadd_esplora_config(apiObj.config);
      wireObj.tag = 1;
      wireObj.kind = inner.inflate_BlockchainConfig_Esplora();
      wireObj.kind.ref.Esplora.ref.config = pre_config;
      return;
    }
  }

  void _api_fill_to_wire_box_autoadd_blockchain_config(
      BlockchainConfig apiObj, ffi.Pointer<wire_BlockchainConfig> wireObj) {
    _api_fill_to_wire_blockchain_config(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_box_autoadd_database_config(DatabaseConfig apiObj, ffi.Pointer<wire_DatabaseConfig> wireObj) {
    _api_fill_to_wire_database_config(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_box_autoadd_electrum_config(ElectrumConfig apiObj, ffi.Pointer<wire_ElectrumConfig> wireObj) {
    _api_fill_to_wire_electrum_config(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_box_autoadd_esplora_config(EsploraConfig apiObj, ffi.Pointer<wire_EsploraConfig> wireObj) {
    _api_fill_to_wire_esplora_config(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_box_autoadd_sled_db_configuration(
      SledDbConfiguration apiObj, ffi.Pointer<wire_SledDbConfiguration> wireObj) {
    _api_fill_to_wire_sled_db_configuration(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_box_autoadd_sqlite_db_configuration(
      SqliteDbConfiguration apiObj, ffi.Pointer<wire_SqliteDbConfiguration> wireObj) {
    _api_fill_to_wire_sqlite_db_configuration(apiObj, wireObj.ref);
  }

  void _api_fill_to_wire_database_config(DatabaseConfig apiObj, wire_DatabaseConfig wireObj) {
    if (apiObj is DatabaseConfig_Memory) {
      wireObj.tag = 0;
      return;
    }
    if (apiObj is DatabaseConfig_Sqlite) {
      var pre_config = api2wire_box_autoadd_sqlite_db_configuration(apiObj.config);
      wireObj.tag = 1;
      wireObj.kind = inner.inflate_DatabaseConfig_Sqlite();
      wireObj.kind.ref.Sqlite.ref.config = pre_config;
      return;
    }
    if (apiObj is DatabaseConfig_Sled) {
      var pre_config = api2wire_box_autoadd_sled_db_configuration(apiObj.config);
      wireObj.tag = 2;
      wireObj.kind = inner.inflate_DatabaseConfig_Sled();
      wireObj.kind.ref.Sled.ref.config = pre_config;
      return;
    }
  }

  void _api_fill_to_wire_electrum_config(ElectrumConfig apiObj, wire_ElectrumConfig wireObj) {
    wireObj.url = api2wire_String(apiObj.url);
    wireObj.socks5 = api2wire_opt_String(apiObj.socks5);
    wireObj.retry = api2wire_u8(apiObj.retry);
    wireObj.timeout = api2wire_opt_box_autoadd_u8(apiObj.timeout);
    wireObj.stop_gap = api2wire_u64(apiObj.stopGap);
  }

  void _api_fill_to_wire_esplora_config(EsploraConfig apiObj, wire_EsploraConfig wireObj) {
    wireObj.base_url = api2wire_String(apiObj.baseUrl);
    wireObj.proxy = api2wire_opt_String(apiObj.proxy);
    wireObj.concurrency = api2wire_opt_box_autoadd_u8(apiObj.concurrency);
    wireObj.stop_gap = api2wire_u64(apiObj.stopGap);
    wireObj.timeout = api2wire_opt_box_autoadd_u64(apiObj.timeout);
  }

  void _api_fill_to_wire_out_point(OutPoint apiObj, wire_OutPoint wireObj) {
    wireObj.txid = api2wire_String(apiObj.txid);
    wireObj.vout = api2wire_u32(apiObj.vout);
  }

  void _api_fill_to_wire_script_amount(ScriptAmount apiObj, wire_ScriptAmount wireObj) {
    wireObj.script = api2wire_String(apiObj.script);
    wireObj.amount = api2wire_u64(apiObj.amount);
  }

  void _api_fill_to_wire_sled_db_configuration(SledDbConfiguration apiObj, wire_SledDbConfiguration wireObj) {
    wireObj.path = api2wire_String(apiObj.path);
    wireObj.tree_name = api2wire_String(apiObj.treeName);
  }

  void _api_fill_to_wire_sqlite_db_configuration(SqliteDbConfiguration apiObj, wire_SqliteDbConfiguration wireObj) {
    wireObj.path = api2wire_String(apiObj.path);
  }
}

// ignore_for_file: camel_case_types, non_constant_identifier_names, avoid_positional_boolean_parameters, annotate_overrides, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.

/// generated by flutter_rust_bridge
class RustWire implements FlutterRustBridgeWireBase {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustWire(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RustWire.fromLookup(ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup) : _lookup = lookup;

  void store_dart_post_cobject(
    DartPostCObjectFnType ptr,
  ) {
    return _store_dart_post_cobject(
      ptr,
    );
  }

  late final _store_dart_post_cobjectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(DartPostCObjectFnType)>>('store_dart_post_cobject');
  late final _store_dart_post_cobject = _store_dart_post_cobjectPtr.asFunction<void Function(DartPostCObjectFnType)>();

  void wire_blockchain_init(
    int port_,
    ffi.Pointer<wire_BlockchainConfig> config,
  ) {
    return _wire_blockchain_init(
      port_,
      config,
    );
  }

  late final _wire_blockchain_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_BlockchainConfig>)>>(
          'wire_blockchain_init');
  late final _wire_blockchain_init =
      _wire_blockchain_initPtr.asFunction<void Function(int, ffi.Pointer<wire_BlockchainConfig>)>();

  void wire_get_blockchain_height(
    int port_,
    wire_BlockchainInstance blockchain,
  ) {
    return _wire_get_blockchain_height(
      port_,
      blockchain,
    );
  }

  late final _wire_get_blockchain_heightPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_BlockchainInstance)>>('wire_get_blockchain_height');
  late final _wire_get_blockchain_height =
      _wire_get_blockchain_heightPtr.asFunction<void Function(int, wire_BlockchainInstance)>();

  void wire_get_blockchain_hash(
    int port_,
    int blockchain_height,
    wire_BlockchainInstance blockchain,
  ) {
    return _wire_get_blockchain_hash(
      port_,
      blockchain_height,
      blockchain,
    );
  }

  late final _wire_get_blockchain_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Uint32, wire_BlockchainInstance)>>(
          'wire_get_blockchain_hash');
  late final _wire_get_blockchain_hash =
      _wire_get_blockchain_hashPtr.asFunction<void Function(int, int, wire_BlockchainInstance)>();

  void wire_broadcast(
    int port_,
    ffi.Pointer<wire_uint_8_list> psbt_str,
    wire_BlockchainInstance blockchain,
  ) {
    return _wire_broadcast(
      port_,
      psbt_str,
      blockchain,
    );
  }

  late final _wire_broadcastPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>, wire_BlockchainInstance)>>(
          'wire_broadcast');
  late final _wire_broadcast =
      _wire_broadcastPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, wire_BlockchainInstance)>();

  void wire_psbt_to_txid(
    int port_,
    ffi.Pointer<wire_uint_8_list> psbt_str,
  ) {
    return _wire_psbt_to_txid(
      port_,
      psbt_str,
    );
  }

  late final _wire_psbt_to_txidPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>('wire_psbt_to_txid');
  late final _wire_psbt_to_txid = _wire_psbt_to_txidPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_extract_tx(
    int port_,
    ffi.Pointer<wire_uint_8_list> psbt_str,
  ) {
    return _wire_extract_tx(
      port_,
      psbt_str,
    );
  }

  late final _wire_extract_txPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>('wire_extract_tx');
  late final _wire_extract_tx = _wire_extract_txPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_get_fee_rate(
    int port_,
    ffi.Pointer<wire_uint_8_list> psbt_str,
  ) {
    return _wire_get_fee_rate(
      port_,
      psbt_str,
    );
  }

  late final _wire_get_fee_ratePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>('wire_get_fee_rate');
  late final _wire_get_fee_rate = _wire_get_fee_ratePtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_combine_psbt(
    int port_,
    ffi.Pointer<wire_uint_8_list> psbt_str,
    ffi.Pointer<wire_uint_8_list> other,
  ) {
    return _wire_combine_psbt(
      port_,
      psbt_str,
      other,
    );
  }

  late final _wire_combine_psbtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int64, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>>('wire_combine_psbt');
  late final _wire_combine_psbt = _wire_combine_psbtPtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_tx_builder_finish(
    int port_,
    wire_WalletInstance wallet,
    ffi.Pointer<wire_list_script_amount> recipients,
    ffi.Pointer<wire_list_out_point> utxos,
    ffi.Pointer<wire_list_out_point> unspendable,
    bool manually_selected_only,
    bool only_spend_change,
    bool do_not_spend_change,
    ffi.Pointer<ffi.Float> fee_rate,
    ffi.Pointer<ffi.Uint64> fee_absolute,
    bool drain_wallet,
    ffi.Pointer<wire_uint_8_list> drain_to,
    bool enable_rbf,
    ffi.Pointer<ffi.Uint32> n_sequence,
    ffi.Pointer<wire_uint_8_list> data,
  ) {
    return _wire_tx_builder_finish(
      port_,
      wallet,
      recipients,
      utxos,
      unspendable,
      manually_selected_only,
      only_spend_change,
      do_not_spend_change,
      fee_rate,
      fee_absolute,
      drain_wallet,
      drain_to,
      enable_rbf,
      n_sequence,
      data,
    );
  }

  late final _wire_tx_builder_finishPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int64,
              wire_WalletInstance,
              ffi.Pointer<wire_list_script_amount>,
              ffi.Pointer<wire_list_out_point>,
              ffi.Pointer<wire_list_out_point>,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Bool,
              ffi.Pointer<wire_uint_8_list>,
              ffi.Bool,
              ffi.Pointer<ffi.Uint32>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_tx_builder_finish');
  late final _wire_tx_builder_finish = _wire_tx_builder_finishPtr.asFunction<
      void Function(
          int,
          wire_WalletInstance,
          ffi.Pointer<wire_list_script_amount>,
          ffi.Pointer<wire_list_out_point>,
          ffi.Pointer<wire_list_out_point>,
          bool,
          bool,
          bool,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Uint64>,
          bool,
          ffi.Pointer<wire_uint_8_list>,
          bool,
          ffi.Pointer<ffi.Uint32>,
          ffi.Pointer<wire_uint_8_list>)>();

  void wire_bump_fee_tx_builder_finish(
    int port_,
    ffi.Pointer<wire_uint_8_list> txid,
    double fee_rate,
    ffi.Pointer<wire_uint_8_list> allow_shrinking,
    wire_WalletInstance wallet,
    bool enable_rbf,
    ffi.Pointer<ffi.Uint32> n_sequence,
  ) {
    return _wire_bump_fee_tx_builder_finish(
      port_,
      txid,
      fee_rate,
      allow_shrinking,
      wallet,
      enable_rbf,
      n_sequence,
    );
  }

  late final _wire_bump_fee_tx_builder_finishPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>, ffi.Float, ffi.Pointer<wire_uint_8_list>,
              wire_WalletInstance, ffi.Bool, ffi.Pointer<ffi.Uint32>)>>('wire_bump_fee_tx_builder_finish');
  late final _wire_bump_fee_tx_builder_finish = _wire_bump_fee_tx_builder_finishPtr.asFunction<
      void Function(int, ffi.Pointer<wire_uint_8_list>, double, ffi.Pointer<wire_uint_8_list>, wire_WalletInstance,
          bool, ffi.Pointer<ffi.Uint32>)>();

  void wire_descriptor_secret_extend(
    int port_,
    ffi.Pointer<wire_uint_8_list> xprv,
    ffi.Pointer<wire_uint_8_list> path,
  ) {
    return _wire_descriptor_secret_extend(
      port_,
      xprv,
      path,
    );
  }

  late final _wire_descriptor_secret_extendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_descriptor_secret_extend');
  late final _wire_descriptor_secret_extend = _wire_descriptor_secret_extendPtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_descriptor_secret_derive(
    int port_,
    ffi.Pointer<wire_uint_8_list> xprv,
    ffi.Pointer<wire_uint_8_list> path,
  ) {
    return _wire_descriptor_secret_derive(
      port_,
      xprv,
      path,
    );
  }

  late final _wire_descriptor_secret_derivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_descriptor_secret_derive');
  late final _wire_descriptor_secret_derive = _wire_descriptor_secret_derivePtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_descriptor_secret_as_secret_bytes(
    int port_,
    ffi.Pointer<wire_uint_8_list> descriptor_secret,
    ffi.Pointer<wire_uint_8_list> xprv,
  ) {
    return _wire_descriptor_secret_as_secret_bytes(
      port_,
      descriptor_secret,
      xprv,
    );
  }

  late final _wire_descriptor_secret_as_secret_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_descriptor_secret_as_secret_bytes');
  late final _wire_descriptor_secret_as_secret_bytes = _wire_descriptor_secret_as_secret_bytesPtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_descriptor_secret_as_public(
    int port_,
    ffi.Pointer<wire_uint_8_list> descriptor_secret,
    ffi.Pointer<wire_uint_8_list> xprv,
  ) {
    return _wire_descriptor_secret_as_public(
      port_,
      descriptor_secret,
      xprv,
    );
  }

  late final _wire_descriptor_secret_as_publicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_descriptor_secret_as_public');
  late final _wire_descriptor_secret_as_public = _wire_descriptor_secret_as_publicPtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_create_descriptor_secret(
    int port_,
    int network,
    ffi.Pointer<wire_uint_8_list> mnemonic,
    ffi.Pointer<wire_uint_8_list> password,
  ) {
    return _wire_create_descriptor_secret(
      port_,
      network,
      mnemonic,
      password,
    );
  }

  late final _wire_create_descriptor_secretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Int32, ffi.Pointer<wire_uint_8_list>,
              ffi.Pointer<wire_uint_8_list>)>>('wire_create_descriptor_secret');
  late final _wire_create_descriptor_secret = _wire_create_descriptor_secretPtr
      .asFunction<void Function(int, int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>)>();

  void wire_create_derivation_path(
    int port_,
    ffi.Pointer<wire_uint_8_list> path,
  ) {
    return _wire_create_derivation_path(
      port_,
      path,
    );
  }

  late final _wire_create_derivation_pathPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>(
          'wire_create_derivation_path');
  late final _wire_create_derivation_path =
      _wire_create_derivation_pathPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_create_descriptor_public(
    int port_,
    ffi.Pointer<wire_uint_8_list> xpub,
    ffi.Pointer<wire_uint_8_list> path,
    bool derive,
  ) {
    return _wire_create_descriptor_public(
      port_,
      xpub,
      path,
      derive,
    );
  }

  late final _wire_create_descriptor_publicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>,
              ffi.Bool)>>('wire_create_descriptor_public');
  late final _wire_create_descriptor_public = _wire_create_descriptor_publicPtr
      .asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>, bool)>();

  void wire_init_script(
    int port_,
    ffi.Pointer<wire_uint_8_list> raw_output_script,
  ) {
    return _wire_init_script(
      port_,
      raw_output_script,
    );
  }

  late final _wire_init_scriptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>('wire_init_script');
  late final _wire_init_script = _wire_init_scriptPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_init_address(
    int port_,
    ffi.Pointer<wire_uint_8_list> address,
  ) {
    return _wire_init_address(
      port_,
      address,
    );
  }

  late final _wire_init_addressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>('wire_init_address');
  late final _wire_init_address = _wire_init_addressPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_address_to_script_pubkey_hex(
    int port_,
    ffi.Pointer<wire_uint_8_list> address,
  ) {
    return _wire_address_to_script_pubkey_hex(
      port_,
      address,
    );
  }

  late final _wire_address_to_script_pubkey_hexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>(
          'wire_address_to_script_pubkey_hex');
  late final _wire_address_to_script_pubkey_hex =
      _wire_address_to_script_pubkey_hexPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_wallet_init(
    int port_,
    ffi.Pointer<wire_uint_8_list> descriptor,
    ffi.Pointer<wire_uint_8_list> change_descriptor,
    int network,
    ffi.Pointer<wire_DatabaseConfig> database_config,
  ) {
    return _wire_wallet_init(
      port_,
      descriptor,
      change_descriptor,
      network,
      database_config,
    );
  }

  late final _wire_wallet_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>, ffi.Int32,
              ffi.Pointer<wire_DatabaseConfig>)>>('wire_wallet_init');
  late final _wire_wallet_init = _wire_wallet_initPtr.asFunction<
      void Function(
          int, ffi.Pointer<wire_uint_8_list>, ffi.Pointer<wire_uint_8_list>, int, ffi.Pointer<wire_DatabaseConfig>)>();

  void wire_get_address(
    int port_,
    wire_WalletInstance wallet,
    int address_index,
  ) {
    return _wire_get_address(
      port_,
      wallet,
      address_index,
    );
  }

  late final _wire_get_addressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance, ffi.Int32)>>('wire_get_address');
  late final _wire_get_address = _wire_get_addressPtr.asFunction<void Function(int, wire_WalletInstance, int)>();

  void wire_sync_wallet(
    int port_,
    wire_WalletInstance wallet,
    wire_BlockchainInstance blockchain,
  ) {
    return _wire_sync_wallet(
      port_,
      wallet,
      blockchain,
    );
  }

  late final _wire_sync_walletPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance, wire_BlockchainInstance)>>(
          'wire_sync_wallet');
  late final _wire_sync_wallet =
      _wire_sync_walletPtr.asFunction<void Function(int, wire_WalletInstance, wire_BlockchainInstance)>();

  void wire_get_balance(
    int port_,
    wire_WalletInstance wallet,
  ) {
    return _wire_get_balance(
      port_,
      wallet,
    );
  }

  late final _wire_get_balancePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance)>>('wire_get_balance');
  late final _wire_get_balance = _wire_get_balancePtr.asFunction<void Function(int, wire_WalletInstance)>();

  void wire_list_unspent_outputs(
    int port_,
    wire_WalletInstance wallet,
  ) {
    return _wire_list_unspent_outputs(
      port_,
      wallet,
    );
  }

  late final _wire_list_unspent_outputsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance)>>('wire_list_unspent_outputs');
  late final _wire_list_unspent_outputs =
      _wire_list_unspent_outputsPtr.asFunction<void Function(int, wire_WalletInstance)>();

  void wire_get_transactions(
    int port_,
    wire_WalletInstance wallet,
  ) {
    return _wire_get_transactions(
      port_,
      wallet,
    );
  }

  late final _wire_get_transactionsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance)>>('wire_get_transactions');
  late final _wire_get_transactions = _wire_get_transactionsPtr.asFunction<void Function(int, wire_WalletInstance)>();

  void wire_sign(
    int port_,
    wire_WalletInstance wallet,
    ffi.Pointer<wire_uint_8_list> psbt_str,
    bool is_multi_sig,
  ) {
    return _wire_sign(
      port_,
      wallet,
      psbt_str,
      is_multi_sig,
    );
  }

  late final _wire_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int64, wire_WalletInstance, ffi.Pointer<wire_uint_8_list>, ffi.Bool)>>('wire_sign');
  late final _wire_sign =
      _wire_signPtr.asFunction<void Function(int, wire_WalletInstance, ffi.Pointer<wire_uint_8_list>, bool)>();

  void wire_get_network(
    int port_,
    wire_WalletInstance wallet,
  ) {
    return _wire_get_network(
      port_,
      wallet,
    );
  }

  late final _wire_get_networkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance)>>('wire_get_network');
  late final _wire_get_network = _wire_get_networkPtr.asFunction<void Function(int, wire_WalletInstance)>();

  void wire_list_unspent(
    int port_,
    wire_WalletInstance wallet,
  ) {
    return _wire_list_unspent(
      port_,
      wallet,
    );
  }

  late final _wire_list_unspentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, wire_WalletInstance)>>('wire_list_unspent');
  late final _wire_list_unspent = _wire_list_unspentPtr.asFunction<void Function(int, wire_WalletInstance)>();

  void wire_generate_seed_from_word_count(
    int port_,
    int word_count,
  ) {
    return _wire_generate_seed_from_word_count(
      port_,
      word_count,
    );
  }

  late final _wire_generate_seed_from_word_countPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Int32)>>('wire_generate_seed_from_word_count');
  late final _wire_generate_seed_from_word_count =
      _wire_generate_seed_from_word_countPtr.asFunction<void Function(int, int)>();

  void wire_generate_seed_from_string(
    int port_,
    ffi.Pointer<wire_uint_8_list> mnemonic,
  ) {
    return _wire_generate_seed_from_string(
      port_,
      mnemonic,
    );
  }

  late final _wire_generate_seed_from_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>(
          'wire_generate_seed_from_string');
  late final _wire_generate_seed_from_string =
      _wire_generate_seed_from_stringPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  void wire_generate_seed_from_entropy(
    int port_,
    ffi.Pointer<wire_uint_8_list> entropy,
  ) {
    return _wire_generate_seed_from_entropy(
      port_,
      entropy,
    );
  }

  late final _wire_generate_seed_from_entropyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, ffi.Pointer<wire_uint_8_list>)>>(
          'wire_generate_seed_from_entropy');
  late final _wire_generate_seed_from_entropy =
      _wire_generate_seed_from_entropyPtr.asFunction<void Function(int, ffi.Pointer<wire_uint_8_list>)>();

  wire_BlockchainInstance new_BlockchainInstance() {
    return _new_BlockchainInstance();
  }

  late final _new_BlockchainInstancePtr =
      _lookup<ffi.NativeFunction<wire_BlockchainInstance Function()>>('new_BlockchainInstance');
  late final _new_BlockchainInstance = _new_BlockchainInstancePtr.asFunction<wire_BlockchainInstance Function()>();

  wire_WalletInstance new_WalletInstance() {
    return _new_WalletInstance();
  }

  late final _new_WalletInstancePtr = _lookup<ffi.NativeFunction<wire_WalletInstance Function()>>('new_WalletInstance');
  late final _new_WalletInstance = _new_WalletInstancePtr.asFunction<wire_WalletInstance Function()>();

  ffi.Pointer<wire_BlockchainConfig> new_box_autoadd_blockchain_config_0() {
    return _new_box_autoadd_blockchain_config_0();
  }

  late final _new_box_autoadd_blockchain_config_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_BlockchainConfig> Function()>>('new_box_autoadd_blockchain_config_0');
  late final _new_box_autoadd_blockchain_config_0 =
      _new_box_autoadd_blockchain_config_0Ptr.asFunction<ffi.Pointer<wire_BlockchainConfig> Function()>();

  ffi.Pointer<wire_DatabaseConfig> new_box_autoadd_database_config_0() {
    return _new_box_autoadd_database_config_0();
  }

  late final _new_box_autoadd_database_config_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_DatabaseConfig> Function()>>('new_box_autoadd_database_config_0');
  late final _new_box_autoadd_database_config_0 =
      _new_box_autoadd_database_config_0Ptr.asFunction<ffi.Pointer<wire_DatabaseConfig> Function()>();

  ffi.Pointer<wire_ElectrumConfig> new_box_autoadd_electrum_config_0() {
    return _new_box_autoadd_electrum_config_0();
  }

  late final _new_box_autoadd_electrum_config_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_ElectrumConfig> Function()>>('new_box_autoadd_electrum_config_0');
  late final _new_box_autoadd_electrum_config_0 =
      _new_box_autoadd_electrum_config_0Ptr.asFunction<ffi.Pointer<wire_ElectrumConfig> Function()>();

  ffi.Pointer<wire_EsploraConfig> new_box_autoadd_esplora_config_0() {
    return _new_box_autoadd_esplora_config_0();
  }

  late final _new_box_autoadd_esplora_config_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_EsploraConfig> Function()>>('new_box_autoadd_esplora_config_0');
  late final _new_box_autoadd_esplora_config_0 =
      _new_box_autoadd_esplora_config_0Ptr.asFunction<ffi.Pointer<wire_EsploraConfig> Function()>();

  ffi.Pointer<ffi.Float> new_box_autoadd_f32_0(
    double value,
  ) {
    return _new_box_autoadd_f32_0(
      value,
    );
  }

  late final _new_box_autoadd_f32_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Float> Function(ffi.Float)>>('new_box_autoadd_f32_0');
  late final _new_box_autoadd_f32_0 = _new_box_autoadd_f32_0Ptr.asFunction<ffi.Pointer<ffi.Float> Function(double)>();

  ffi.Pointer<wire_SledDbConfiguration> new_box_autoadd_sled_db_configuration_0() {
    return _new_box_autoadd_sled_db_configuration_0();
  }

  late final _new_box_autoadd_sled_db_configuration_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_SledDbConfiguration> Function()>>(
          'new_box_autoadd_sled_db_configuration_0');
  late final _new_box_autoadd_sled_db_configuration_0 =
      _new_box_autoadd_sled_db_configuration_0Ptr.asFunction<ffi.Pointer<wire_SledDbConfiguration> Function()>();

  ffi.Pointer<wire_SqliteDbConfiguration> new_box_autoadd_sqlite_db_configuration_0() {
    return _new_box_autoadd_sqlite_db_configuration_0();
  }

  late final _new_box_autoadd_sqlite_db_configuration_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_SqliteDbConfiguration> Function()>>(
          'new_box_autoadd_sqlite_db_configuration_0');
  late final _new_box_autoadd_sqlite_db_configuration_0 =
      _new_box_autoadd_sqlite_db_configuration_0Ptr.asFunction<ffi.Pointer<wire_SqliteDbConfiguration> Function()>();

  ffi.Pointer<ffi.Uint32> new_box_autoadd_u32_0(
    int value,
  ) {
    return _new_box_autoadd_u32_0(
      value,
    );
  }

  late final _new_box_autoadd_u32_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint32> Function(ffi.Uint32)>>('new_box_autoadd_u32_0');
  late final _new_box_autoadd_u32_0 = _new_box_autoadd_u32_0Ptr.asFunction<ffi.Pointer<ffi.Uint32> Function(int)>();

  ffi.Pointer<ffi.Uint64> new_box_autoadd_u64_0(
    int value,
  ) {
    return _new_box_autoadd_u64_0(
      value,
    );
  }

  late final _new_box_autoadd_u64_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint64> Function(ffi.Uint64)>>('new_box_autoadd_u64_0');
  late final _new_box_autoadd_u64_0 = _new_box_autoadd_u64_0Ptr.asFunction<ffi.Pointer<ffi.Uint64> Function(int)>();

  ffi.Pointer<ffi.Uint8> new_box_autoadd_u8_0(
    int value,
  ) {
    return _new_box_autoadd_u8_0(
      value,
    );
  }

  late final _new_box_autoadd_u8_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.Uint8)>>('new_box_autoadd_u8_0');
  late final _new_box_autoadd_u8_0 = _new_box_autoadd_u8_0Ptr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  ffi.Pointer<wire_list_out_point> new_list_out_point_0(
    int len,
  ) {
    return _new_list_out_point_0(
      len,
    );
  }

  late final _new_list_out_point_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_list_out_point> Function(ffi.Int32)>>('new_list_out_point_0');
  late final _new_list_out_point_0 =
      _new_list_out_point_0Ptr.asFunction<ffi.Pointer<wire_list_out_point> Function(int)>();

  ffi.Pointer<wire_list_script_amount> new_list_script_amount_0(
    int len,
  ) {
    return _new_list_script_amount_0(
      len,
    );
  }

  late final _new_list_script_amount_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_list_script_amount> Function(ffi.Int32)>>('new_list_script_amount_0');
  late final _new_list_script_amount_0 =
      _new_list_script_amount_0Ptr.asFunction<ffi.Pointer<wire_list_script_amount> Function(int)>();

  ffi.Pointer<wire_uint_8_list> new_uint_8_list_0(
    int len,
  ) {
    return _new_uint_8_list_0(
      len,
    );
  }

  late final _new_uint_8_list_0Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wire_uint_8_list> Function(ffi.Int32)>>('new_uint_8_list_0');
  late final _new_uint_8_list_0 = _new_uint_8_list_0Ptr.asFunction<ffi.Pointer<wire_uint_8_list> Function(int)>();

  void drop_opaque_BlockchainInstance(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _drop_opaque_BlockchainInstance(
      ptr,
    );
  }

  late final _drop_opaque_BlockchainInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('drop_opaque_BlockchainInstance');
  late final _drop_opaque_BlockchainInstance =
      _drop_opaque_BlockchainInstancePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> share_opaque_BlockchainInstance(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _share_opaque_BlockchainInstance(
      ptr,
    );
  }

  late final _share_opaque_BlockchainInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          'share_opaque_BlockchainInstance');
  late final _share_opaque_BlockchainInstance =
      _share_opaque_BlockchainInstancePtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void drop_opaque_WalletInstance(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _drop_opaque_WalletInstance(
      ptr,
    );
  }

  late final _drop_opaque_WalletInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('drop_opaque_WalletInstance');
  late final _drop_opaque_WalletInstance =
      _drop_opaque_WalletInstancePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> share_opaque_WalletInstance(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _share_opaque_WalletInstance(
      ptr,
    );
  }

  late final _share_opaque_WalletInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('share_opaque_WalletInstance');
  late final _share_opaque_WalletInstance =
      _share_opaque_WalletInstancePtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<BlockchainConfigKind> inflate_BlockchainConfig_Electrum() {
    return _inflate_BlockchainConfig_Electrum();
  }

  late final _inflate_BlockchainConfig_ElectrumPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<BlockchainConfigKind> Function()>>('inflate_BlockchainConfig_Electrum');
  late final _inflate_BlockchainConfig_Electrum =
      _inflate_BlockchainConfig_ElectrumPtr.asFunction<ffi.Pointer<BlockchainConfigKind> Function()>();

  ffi.Pointer<BlockchainConfigKind> inflate_BlockchainConfig_Esplora() {
    return _inflate_BlockchainConfig_Esplora();
  }

  late final _inflate_BlockchainConfig_EsploraPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<BlockchainConfigKind> Function()>>('inflate_BlockchainConfig_Esplora');
  late final _inflate_BlockchainConfig_Esplora =
      _inflate_BlockchainConfig_EsploraPtr.asFunction<ffi.Pointer<BlockchainConfigKind> Function()>();

  ffi.Pointer<DatabaseConfigKind> inflate_DatabaseConfig_Sqlite() {
    return _inflate_DatabaseConfig_Sqlite();
  }

  late final _inflate_DatabaseConfig_SqlitePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<DatabaseConfigKind> Function()>>('inflate_DatabaseConfig_Sqlite');
  late final _inflate_DatabaseConfig_Sqlite =
      _inflate_DatabaseConfig_SqlitePtr.asFunction<ffi.Pointer<DatabaseConfigKind> Function()>();

  ffi.Pointer<DatabaseConfigKind> inflate_DatabaseConfig_Sled() {
    return _inflate_DatabaseConfig_Sled();
  }

  late final _inflate_DatabaseConfig_SledPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<DatabaseConfigKind> Function()>>('inflate_DatabaseConfig_Sled');
  late final _inflate_DatabaseConfig_Sled =
      _inflate_DatabaseConfig_SledPtr.asFunction<ffi.Pointer<DatabaseConfigKind> Function()>();

  void free_WireSyncReturnStruct(
    WireSyncReturnStruct val,
  ) {
    return _free_WireSyncReturnStruct(
      val,
    );
  }

  late final _free_WireSyncReturnStructPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(WireSyncReturnStruct)>>('free_WireSyncReturnStruct');
  late final _free_WireSyncReturnStruct =
      _free_WireSyncReturnStructPtr.asFunction<void Function(WireSyncReturnStruct)>();
}

class wire_uint_8_list extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.Int32()
  external int len;
}

class wire_ElectrumConfig extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> url;

  external ffi.Pointer<wire_uint_8_list> socks5;

  @ffi.Uint8()
  external int retry;

  external ffi.Pointer<ffi.Uint8> timeout;

  @ffi.Uint64()
  external int stop_gap;
}

class wire_BlockchainConfig_Electrum extends ffi.Struct {
  external ffi.Pointer<wire_ElectrumConfig> config;
}

class wire_EsploraConfig extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> base_url;

  external ffi.Pointer<wire_uint_8_list> proxy;

  external ffi.Pointer<ffi.Uint8> concurrency;

  @ffi.Uint64()
  external int stop_gap;

  external ffi.Pointer<ffi.Uint64> timeout;
}

class wire_BlockchainConfig_Esplora extends ffi.Struct {
  external ffi.Pointer<wire_EsploraConfig> config;
}

class BlockchainConfigKind extends ffi.Union {
  external ffi.Pointer<wire_BlockchainConfig_Electrum> Electrum;

  external ffi.Pointer<wire_BlockchainConfig_Esplora> Esplora;
}

class wire_BlockchainConfig extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  external ffi.Pointer<BlockchainConfigKind> kind;
}

class wire_BlockchainInstance extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

class wire_WalletInstance extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;
}

class wire_ScriptAmount extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> script;

  @ffi.Uint64()
  external int amount;
}

class wire_list_script_amount extends ffi.Struct {
  external ffi.Pointer<wire_ScriptAmount> ptr;

  @ffi.Int32()
  external int len;
}

class wire_OutPoint extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> txid;

  @ffi.Uint32()
  external int vout;
}

class wire_list_out_point extends ffi.Struct {
  external ffi.Pointer<wire_OutPoint> ptr;

  @ffi.Int32()
  external int len;
}

class wire_DatabaseConfig_Memory extends ffi.Opaque {}

class wire_SqliteDbConfiguration extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> path;
}

class wire_DatabaseConfig_Sqlite extends ffi.Struct {
  external ffi.Pointer<wire_SqliteDbConfiguration> config;
}

class wire_SledDbConfiguration extends ffi.Struct {
  external ffi.Pointer<wire_uint_8_list> path;

  external ffi.Pointer<wire_uint_8_list> tree_name;
}

class wire_DatabaseConfig_Sled extends ffi.Struct {
  external ffi.Pointer<wire_SledDbConfiguration> config;
}

class DatabaseConfigKind extends ffi.Union {
  external ffi.Pointer<wire_DatabaseConfig_Memory> Memory;

  external ffi.Pointer<wire_DatabaseConfig_Sqlite> Sqlite;

  external ffi.Pointer<wire_DatabaseConfig_Sled> Sled;
}

class wire_DatabaseConfig extends ffi.Struct {
  @ffi.Int32()
  external int tag;

  external ffi.Pointer<DatabaseConfigKind> kind;
}

typedef DartPostCObjectFnType = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(DartPort, ffi.Pointer<ffi.Void>)>>;
typedef DartPort = ffi.Int64;
