// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'psbt.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `get_wallet`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

Future<(BdkPsbt, TransactionDetails)> finishBumpFeeTxBuilder(
        {required String txid,
        required double feeRate,
        BdkAddress? allowShrinking,
        required BdkWallet wallet,
        required bool enableRbf,
        int? nSequence}) =>
    core.instance.api.crateApiWalletFinishBumpFeeTxBuilder(
        txid: txid,
        feeRate: feeRate,
        allowShrinking: allowShrinking,
        wallet: wallet,
        enableRbf: enableRbf,
        nSequence: nSequence);

Future<(BdkPsbt, TransactionDetails)> txBuilderFinish(
        {required BdkWallet wallet,
        required List<ScriptAmount> recipients,
        required List<OutPoint> utxos,
        (OutPoint, Input, BigInt)? foreignUtxo,
        required List<OutPoint> unSpendable,
        required ChangeSpendPolicy changePolicy,
        required bool manuallySelectedOnly,
        double? feeRate,
        BigInt? feeAbsolute,
        required bool drainWallet,
        BdkScriptBuf? drainTo,
        RbfValue? rbf,
        required List<int> data}) =>
    core.instance.api.crateApiWalletTxBuilderFinish(
        wallet: wallet,
        recipients: recipients,
        utxos: utxos,
        foreignUtxo: foreignUtxo,
        unSpendable: unSpendable,
        changePolicy: changePolicy,
        manuallySelectedOnly: manuallySelectedOnly,
        feeRate: feeRate,
        feeAbsolute: feeAbsolute,
        drainWallet: drainWallet,
        drainTo: drainTo,
        rbf: rbf,
        data: data);

class BdkWallet {
  final MutexWalletAnyDatabase ptr;

  const BdkWallet({
    required this.ptr,
  });

  /// Return a derived address using the external descriptor, see AddressIndex for available address index selection
  /// strategies. If none of the keys in the descriptor are derivable (i.e. the descriptor does not end with a * character)
  /// then the same address will always be returned for any AddressIndex.
  static (BdkAddress, int) getAddress(
          {required BdkWallet ptr, required AddressIndex addressIndex}) =>
      core.instance.api.crateApiWalletBdkWalletGetAddress(
          ptr: ptr, addressIndex: addressIndex);

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Balance getBalance() => core.instance.api.crateApiWalletBdkWalletGetBalance(
        that: this,
      );

  ///Returns the descriptor used to create addresses for a particular keychain.
  static BdkDescriptor getDescriptorForKeychain(
          {required BdkWallet ptr, required KeychainKind keychain}) =>
      core.instance.api.crateApiWalletBdkWalletGetDescriptorForKeychain(
          ptr: ptr, keychain: keychain);

  /// Return a derived address using the internal (change) descriptor.
  ///
  /// If the wallet doesn't have an internal descriptor it will use the external descriptor.
  ///
  /// see [AddressIndex] for available address index selection strategies. If none of the keys
  /// in the descriptor are derivable (i.e. does not end with /*) then the same address will always
  /// be returned for any [AddressIndex].
  static (BdkAddress, int) getInternalAddress(
          {required BdkWallet ptr, required AddressIndex addressIndex}) =>
      core.instance.api.crateApiWalletBdkWalletGetInternalAddress(
          ptr: ptr, addressIndex: addressIndex);

  ///get the corresponding PSBT Input for a LocalUtxo
  Future<Input> getPsbtInput(
          {required LocalUtxo utxo,
          required bool onlyWitnessUtxo,
          PsbtSigHashType? sighashType}) =>
      core.instance.api.crateApiWalletBdkWalletGetPsbtInput(
          that: this,
          utxo: utxo,
          onlyWitnessUtxo: onlyWitnessUtxo,
          sighashType: sighashType);

  /// Return whether or not a script is part of this wallet (either internal or external).
  bool isMine({required BdkScriptBuf script}) => core.instance.api
      .crateApiWalletBdkWalletIsMine(that: this, script: script);

  /// Return the list of transactions made and received by the wallet. Note that this method only operate on the internal database, which first needs to be [Wallet.sync] manually.
  List<TransactionDetails> listTransactions({required bool includeRaw}) =>
      core.instance.api.crateApiWalletBdkWalletListTransactions(
          that: this, includeRaw: includeRaw);

  /// Return the list of unspent outputs of this wallet. Note that this method only operates on the internal database,
  /// which first needs to be Wallet.sync manually.
  List<LocalUtxo> listUnspent() =>
      core.instance.api.crateApiWalletBdkWalletListUnspent(
        that: this,
      );

  /// Get the Bitcoin network the wallet is using.
  Network network() => core.instance.api.crateApiWalletBdkWalletNetwork(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BdkWallet> newInstance(
          {required BdkDescriptor descriptor,
          BdkDescriptor? changeDescriptor,
          required Network network,
          required DatabaseConfig databaseConfig}) =>
      core.instance.api.crateApiWalletBdkWalletNew(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          databaseConfig: databaseConfig);

  /// Sign a transaction with all the wallet's signers. This function returns an encapsulated bool that
  /// has the value true if the PSBT was finalized, or false otherwise.
  ///
  /// The [SignOptions] can be used to tweak the behavior of the software signers, and the way
  /// the transaction is finalized at the end. Note that it can't be guaranteed that *every*
  /// signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
  /// in this library will.
  static Future<bool> sign(
          {required BdkWallet ptr,
          required BdkPsbt psbt,
          SignOptions? signOptions}) =>
      core.instance.api.crateApiWalletBdkWalletSign(
          ptr: ptr, psbt: psbt, signOptions: signOptions);

  /// Sync the internal database with the blockchain.
  static Future<void> sync(
          {required BdkWallet ptr, required BdkBlockchain blockchain}) =>
      core.instance.api
          .crateApiWalletBdkWalletSync(ptr: ptr, blockchain: blockchain);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkWallet &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
