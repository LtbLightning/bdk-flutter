// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'bitcoin.dart';
import 'descriptor.dart';
import 'electrum.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'store.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `get_wallet`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

class FfiWallet {
  final MutexPersistedWalletConnection opaque;

  const FfiWallet({
    required this.opaque,
  });

  Future<void> applyUpdate({required FfiUpdate update}) => core.instance.api
      .crateApiWalletFfiWalletApplyUpdate(that: this, update: update);

  Future<BigInt> calculateFee({required FfiTransaction tx}) =>
      core.instance.api.crateApiWalletFfiWalletCalculateFee(that: this, tx: tx);

  Future<FeeRate> calculateFeeRate({required FfiTransaction tx}) =>
      core.instance.api
          .crateApiWalletFfiWalletCalculateFeeRate(that: this, tx: tx);

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Balance getBalance() => core.instance.api.crateApiWalletFfiWalletGetBalance(
        that: this,
      );

  ///Get a single transaction from the wallet as a WalletTx (if the transaction exists).
  Future<FfiCanonicalTx?> getTx({required String txid}) =>
      core.instance.api.crateApiWalletFfiWalletGetTx(that: this, txid: txid);

  /// Return whether or not a script is part of this wallet (either internal or external).
  bool isMine({required FfiScriptBuf script}) => core.instance.api
      .crateApiWalletFfiWalletIsMine(that: this, script: script);

  ///List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
  Future<List<LocalOutput>> listOutput() =>
      core.instance.api.crateApiWalletFfiWalletListOutput(
        that: this,
      );

  /// Return the list of unspent outputs of this wallet.
  List<LocalOutput> listUnspent() =>
      core.instance.api.crateApiWalletFfiWalletListUnspent(
        that: this,
      );

  static Future<FfiWallet> load(
          {required FfiDescriptor descriptor,
          required FfiDescriptor changeDescriptor,
          required FfiConnection connection}) =>
      core.instance.api.crateApiWalletFfiWalletLoad(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          connection: connection);

  /// Get the Bitcoin network the wallet is using.
  Network network() => core.instance.api.crateApiWalletFfiWalletNetwork(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FfiWallet> newInstance(
          {required FfiDescriptor descriptor,
          required FfiDescriptor changeDescriptor,
          required Network network,
          required FfiConnection connection}) =>
      core.instance.api.crateApiWalletFfiWalletNew(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          connection: connection);

  Future<bool> persist({required FfiConnection connection}) => core.instance.api
      .crateApiWalletFfiWalletPersist(that: this, connection: connection);

  /// Attempt to reveal the next address of the given `keychain`.
  ///
  /// This will increment the keychain's derivation index. If the keychain's descriptor doesn't
  /// contain a wildcard or every address is already revealed up to the maximum derivation
  /// index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
  /// then the last revealed address will be returned.
  static AddressInfo revealNextAddress(
          {required FfiWallet opaque, required KeychainKind keychainKind}) =>
      core.instance.api.crateApiWalletFfiWalletRevealNextAddress(
          opaque: opaque, keychainKind: keychainKind);

  Future<bool> sign(
          {required FfiPsbt psbt, required SignOptions signOptions}) =>
      core.instance.api.crateApiWalletFfiWalletSign(
          that: this, psbt: psbt, signOptions: signOptions);

  Future<FfiFullScanRequestBuilder> startFullScan() =>
      core.instance.api.crateApiWalletFfiWalletStartFullScan(
        that: this,
      );

  Future<FfiSyncRequestBuilder> startSyncWithRevealedSpks() =>
      core.instance.api.crateApiWalletFfiWalletStartSyncWithRevealedSpks(
        that: this,
      );

  ///Iterate over the transactions in the wallet.
  List<FfiCanonicalTx> transactions() =>
      core.instance.api.crateApiWalletFfiWalletTransactions(
        that: this,
      );

  @override
  int get hashCode => opaque.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiWallet &&
          runtimeType == other.runtimeType &&
          opaque == other.opaque;
}
