// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'psbt.dart';
import 'types.dart';

Future<(BdkPsbt, TransactionDetails)> finishBumpFeeTxBuilder(
        {required String txid,
        required double feeRate,
        BdkAddress? allowShrinking,
        required BdkWallet wallet,
        required bool enableRbf,
        int? nSequence,
        dynamic hint}) =>
    BdkCore.instance.api.finishBumpFeeTxBuilder(
        txid: txid,
        feeRate: feeRate,
        allowShrinking: allowShrinking,
        wallet: wallet,
        enableRbf: enableRbf,
        nSequence: nSequence,
        hint: hint);

Future<(BdkPsbt, TransactionDetails)> txBuilderFinish(
        {required BdkWallet wallet,
        required List<ScriptAmount> recipients,
        required List<OutPoint> utxos,
        (OutPoint, Input, int)? foreignUtxo,
        required List<OutPoint> unSpendable,
        required ChangeSpendPolicy changePolicy,
        required bool manuallySelectedOnly,
        double? feeRate,
        int? feeAbsolute,
        required bool drainWallet,
        BdkScriptBuf? drainTo,
        RbfValue? rbf,
        required List<int> data,
        dynamic hint}) =>
    BdkCore.instance.api.txBuilderFinish(
        wallet: wallet,
        recipients: recipients,
        utxos: utxos,
        foreignUtxo: foreignUtxo,
        unSpendable: unSpendable,
        changePolicy: changePolicy,
        manuallySelectedOnly: manuallySelectedOnly,
        feeRate: feeRate,
        feeAbsolute: feeAbsolute,
        drainWallet: drainWallet,
        drainTo: drainTo,
        rbf: rbf,
        data: data,
        hint: hint);

// Rust type: RustOpaqueNom<Mutex < bdk :: Wallet < AnyDatabase > >>
@sealed
class MutexBdkWalletAnyDatabase extends RustOpaque {
  MutexBdkWalletAnyDatabase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexBdkWalletAnyDatabase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore
        .instance.api.rust_arc_increment_strong_count_MutexBdkWalletAnyDatabase,
    rustArcDecrementStrongCount: BdkCore
        .instance.api.rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabase,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabasePtr,
  );
}

class BdkWallet {
  final MutexBdkWalletAnyDatabase ptr;

  const BdkWallet({
    required this.ptr,
  });

  /// Return a derived address using the external descriptor, see AddressIndex for available address index selection
  /// strategies. If none of the keys in the descriptor are derivable (i.e. the descriptor does not end with a * character)
  /// then the same address will always be returned for any AddressIndex.
  static Future<(BdkAddress, int)> getAddress(
          {required BdkWallet ptr,
          required AddressIndex addressIndex,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletGetAddress(
          ptr: ptr, addressIndex: addressIndex, hint: hint);

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Future<Balance> getBalance({dynamic hint}) =>
      BdkCore.instance.api.bdkWalletGetBalance(that: this, hint: hint);

  ///Returns the descriptor used to create addresses for a particular keychain.
  static Future<BdkDescriptor> getDescriptorForKeychain(
          {required BdkWallet ptr,
          required KeychainKind keychain,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletGetDescriptorForKeychain(
          ptr: ptr, keychain: keychain, hint: hint);

  /// Return a derived address using the internal (change) descriptor.
  ///
  /// If the wallet doesn't have an internal descriptor it will use the external descriptor.
  ///
  /// see [AddressIndex] for available address index selection strategies. If none of the keys
  /// in the descriptor are derivable (i.e. does not end with /*) then the same address will always
  /// be returned for any [AddressIndex].
  static Future<(BdkAddress, int)> getInternalAddress(
          {required BdkWallet ptr,
          required AddressIndex addressIndex,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletGetInternalAddress(
          ptr: ptr, addressIndex: addressIndex, hint: hint);

  ///get the corresponding PSBT Input for a LocalUtxo
  Future<Input> getPsbtInput(
          {required LocalUtxo utxo,
          required bool onlyWitnessUtxo,
          PsbtSigHashType? sighashType,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletGetPsbtInput(
          that: this,
          utxo: utxo,
          onlyWitnessUtxo: onlyWitnessUtxo,
          sighashType: sighashType,
          hint: hint);

  /// Return whether or not a script is part of this wallet (either internal or external).
  Future<bool> isMine({required BdkScriptBuf script, dynamic hint}) =>
      BdkCore.instance.api
          .bdkWalletIsMine(that: this, script: script, hint: hint);

  /// Return the list of transactions made and received by the wallet. Note that this method only operate on the internal database, which first needs to be [Wallet.sync] manually.
  Future<List<TransactionDetails>> listTransactions(
          {required bool includeRaw, dynamic hint}) =>
      BdkCore.instance.api.bdkWalletListTransactions(
          that: this, includeRaw: includeRaw, hint: hint);

  /// Return the list of unspent outputs of this wallet. Note that this method only operates on the internal database,
  /// which first needs to be Wallet.sync manually.
  Future<List<LocalUtxo>> listUnspent({dynamic hint}) =>
      BdkCore.instance.api.bdkWalletListUnspent(that: this, hint: hint);

  /// Get the Bitcoin network the wallet is using.
  Future<Network> network({dynamic hint}) =>
      BdkCore.instance.api.bdkWalletNetwork(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BdkWallet> newInstance(
          {required BdkDescriptor descriptor,
          BdkDescriptor? changeDescriptor,
          required Network network,
          required DatabaseConfig databaseConfig,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletNew(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          databaseConfig: databaseConfig,
          hint: hint);

  /// Sign a transaction with all the wallet's signers. This function returns an encapsulated bool that
  /// has the value true if the PSBT was finalized, or false otherwise.
  ///
  /// The [SignOptions] can be used to tweak the behavior of the software signers, and the way
  /// the transaction is finalized at the end. Note that it can't be guaranteed that *every*
  /// signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
  /// in this library will.
  static Future<bool> sign(
          {required BdkWallet ptr,
          required BdkPsbt psbt,
          SignOptions? signOptions,
          dynamic hint}) =>
      BdkCore.instance.api.bdkWalletSign(
          ptr: ptr, psbt: psbt, signOptions: signOptions, hint: hint);

  /// Sync the internal database with the blockchain.
  static Future<void> sync(
          {required BdkWallet ptr,
          required BdkBlockchain blockchain,
          dynamic hint}) =>
      BdkCore.instance.api
          .bdkWalletSync(ptr: ptr, blockchain: blockchain, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkWallet &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
