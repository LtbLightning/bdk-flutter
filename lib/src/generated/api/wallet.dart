// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'bitcoin.dart';
import 'descriptor.dart';
import 'electrum.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'store.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `get_wallet`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

class FfiWallet {
  final MutexPersistedWalletConnection opaque;

  const FfiWallet({
    required this.opaque,
  });

  Future<void> applyUpdate({required FfiUpdate update}) => core.instance.api
      .crateApiWalletFfiWalletApplyUpdate(that: this, update: update);

  static Future<BigInt> calculateFee(
          {required FfiWallet opaque, required FfiTransaction tx}) =>
      core.instance.api
          .crateApiWalletFfiWalletCalculateFee(opaque: opaque, tx: tx);

  static Future<FeeRate> calculateFeeRate(
          {required FfiWallet opaque, required FfiTransaction tx}) =>
      core.instance.api
          .crateApiWalletFfiWalletCalculateFeeRate(opaque: opaque, tx: tx);

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Balance getBalance() => core.instance.api.crateApiWalletFfiWalletGetBalance(
        that: this,
      );

  ///Get a single transaction from the wallet as a WalletTx (if the transaction exists).
  FfiCanonicalTx? getTx({required String txid}) =>
      core.instance.api.crateApiWalletFfiWalletGetTx(that: this, txid: txid);

  bool isMine({required FfiScriptBuf script}) => core.instance.api
      .crateApiWalletFfiWalletIsMine(that: this, script: script);

  ///List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
  List<LocalOutput> listOutput() =>
      core.instance.api.crateApiWalletFfiWalletListOutput(
        that: this,
      );

  /// Return the list of unspent outputs of this wallet.
  List<LocalOutput> listUnspent() =>
      core.instance.api.crateApiWalletFfiWalletListUnspent(
        that: this,
      );

  static Future<FfiWallet> load(
          {required FfiDescriptor descriptor,
          required FfiDescriptor changeDescriptor,
          required FfiConnection connection}) =>
      core.instance.api.crateApiWalletFfiWalletLoad(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          connection: connection);

  /// Get the Bitcoin network the wallet is using.
  Network network() => core.instance.api.crateApiWalletFfiWalletNetwork(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FfiWallet> newInstance(
          {required FfiDescriptor descriptor,
          required FfiDescriptor changeDescriptor,
          required Network network,
          required FfiConnection connection}) =>
      core.instance.api.crateApiWalletFfiWalletNew(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          connection: connection);

  static Future<bool> persist(
          {required FfiWallet opaque, required FfiConnection connection}) =>
      core.instance.api.crateApiWalletFfiWalletPersist(
          opaque: opaque, connection: connection);

  static FfiPolicy? policies(
          {required FfiWallet opaque, required KeychainKind keychainKind}) =>
      core.instance.api.crateApiWalletFfiWalletPolicies(
          opaque: opaque, keychainKind: keychainKind);

  /// Attempt to reveal the next address of the given `keychain`.
  ///
  /// This will increment the keychain's derivation index. If the keychain's descriptor doesn't
  /// contain a wildcard or every address is already revealed up to the maximum derivation
  /// index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
  /// then the last revealed address will be returned.
  static AddressInfo revealNextAddress(
          {required FfiWallet opaque, required KeychainKind keychainKind}) =>
      core.instance.api.crateApiWalletFfiWalletRevealNextAddress(
          opaque: opaque, keychainKind: keychainKind);

  static Future<bool> sign(
          {required FfiWallet opaque,
          required FfiPsbt psbt,
          required SignOptions signOptions}) =>
      core.instance.api.crateApiWalletFfiWalletSign(
          opaque: opaque, psbt: psbt, signOptions: signOptions);

  Future<FfiFullScanRequestBuilder> startFullScan() =>
      core.instance.api.crateApiWalletFfiWalletStartFullScan(
        that: this,
      );

  Future<FfiSyncRequestBuilder> startSyncWithRevealedSpks() =>
      core.instance.api.crateApiWalletFfiWalletStartSyncWithRevealedSpks(
        that: this,
      );

  ///Iterate over the transactions in the wallet.
  List<FfiCanonicalTx> transactions() =>
      core.instance.api.crateApiWalletFfiWalletTransactions(
        that: this,
      );

  @override
  int get hashCode => opaque.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiWallet &&
          runtimeType == other.runtimeType &&
          opaque == other.opaque;
}
