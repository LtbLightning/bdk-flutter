// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'psbt.dart';
import 'types.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

Future<(BdkPsbt, BdkTransactionDetails)> finishBumpFeeTxBuilder({
  required String txid,
  required double feeRate,
  BdkAddress? allowShrinking,
  required BdkWallet wallet,
  required bool enableRbf,
  int? nSequence,
}) => core.instance.api.crateApiWalletFinishBumpFeeTxBuilder(
  txid: txid,
  feeRate: feeRate,
  allowShrinking: allowShrinking,
  wallet: wallet,
  enableRbf: enableRbf,
  nSequence: nSequence,
);

Future<(BdkPsbt, BdkTransactionDetails)> txBuilderFinish({
  required BdkWallet wallet,
  required List<ScriptAmount> recipients,
  required List<OutPoint> utxos,
  (OutPoint, Input, BigInt)? foreignUtxo,
  required List<OutPoint> unSpendable,
  required ChangeSpendPolicy changePolicy,
  required bool manuallySelectedOnly,
  double? feeRate,
  BigInt? feeAbsolute,
  required bool drainWallet,
  BdkScriptBuf? drainTo,
  RbfValue? rbf,
  Map<String, Uint32List>? internalPolicyPath,
  Map<String, Uint32List>? externalPolicyPath,
  required List<int> data,
}) => core.instance.api.crateApiWalletTxBuilderFinish(
  wallet: wallet,
  recipients: recipients,
  utxos: utxos,
  foreignUtxo: foreignUtxo,
  unSpendable: unSpendable,
  changePolicy: changePolicy,
  manuallySelectedOnly: manuallySelectedOnly,
  feeRate: feeRate,
  feeAbsolute: feeAbsolute,
  drainWallet: drainWallet,
  drainTo: drainTo,
  rbf: rbf,
  internalPolicyPath: internalPolicyPath,
  externalPolicyPath: externalPolicyPath,
  data: data,
);

class BdkWallet {
  final MutexWalletAnyDatabase ptr;

  const BdkWallet({required this.ptr});

  static Future<BdkWallet> create({
    required BdkDescriptor descriptor,
    BdkDescriptor? changeDescriptor,
    required Network network,
    required DatabaseConfig databaseConfig,
  }) => core.instance.api.crateApiWalletBdkWalletCreate(
    descriptor: descriptor,
    changeDescriptor: changeDescriptor,
    network: network,
    databaseConfig: databaseConfig,
  );

  /// Return a derived address using the external descriptor, see AddressIndex for available address index selection
  /// strategies. If none of the keys in the descriptor are derivable (i.e. the descriptor does not end with a * character)
  /// then the same address will always be returned for any AddressIndex.
  static (BdkAddress, int) getAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  }) => core.instance.api.crateApiWalletBdkWalletGetAddress(
    ptr: ptr,
    addressIndex: addressIndex,
  );

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Balance getBalance() =>
      core.instance.api.crateApiWalletBdkWalletGetBalance(that: this);

  ///Returns the descriptor used to create addresses for a particular keychain.
  static BdkDescriptor getDescriptorForKeychain({
    required BdkWallet ptr,
    required KeychainKind keychain,
  }) => core.instance.api.crateApiWalletBdkWalletGetDescriptorForKeychain(
    ptr: ptr,
    keychain: keychain,
  );

  /// Return a derived address using the internal (change) descriptor.
  ///
  /// If the wallet doesn't have an internal descriptor it will use the external descriptor.
  ///
  /// see [AddressIndex] for available address index selection strategies. If none of the keys
  /// in the descriptor are derivable (i.e. does not end with /*) then the same address will always
  /// be returned for any [AddressIndex].
  static (BdkAddress, int) getInternalAddress({
    required BdkWallet ptr,
    required AddressIndex addressIndex,
  }) => core.instance.api.crateApiWalletBdkWalletGetInternalAddress(
    ptr: ptr,
    addressIndex: addressIndex,
  );

  ///get the corresponding PSBT Input for a LocalUtxo
  Input getPsbtInput({
    required LocalUtxo utxo,
    required bool onlyWitnessUtxo,
    PsbtSigHashType? sighashType,
  }) => core.instance.api.crateApiWalletBdkWalletGetPsbtInput(
    that: this,
    utxo: utxo,
    onlyWitnessUtxo: onlyWitnessUtxo,
    sighashType: sighashType,
  );

  static bool isMine({required BdkWallet ptr, required BdkScriptBuf script}) =>
      core.instance.api.crateApiWalletBdkWalletIsMine(ptr: ptr, script: script);

  /// Return the list of transactions made and received by the wallet. Note that this method only operate on the internal database, which first needs to be [Wallet.sync] manually.
  List<BdkTransactionDetails> listTransactions({required bool includeRaw}) =>
      core.instance.api.crateApiWalletBdkWalletListTransactions(
        that: this,
        includeRaw: includeRaw,
      );

  /// Return the list of unspent outputs of this wallet. Note that this method only operates on the internal database,
  /// which first needs to be Wallet.sync manually.
  List<LocalUtxo> listUnspent() =>
      core.instance.api.crateApiWalletBdkWalletListUnspent(that: this);

  /// Get the Bitcoin network the wallet is using.
  Network network() =>
      core.instance.api.crateApiWalletBdkWalletNetwork(that: this);

  static BdkPolicy? policies({
    required BdkWallet ptr,
    required KeychainKind keychain,
  }) => core.instance.api.crateApiWalletBdkWalletPolicies(
    ptr: ptr,
    keychain: keychain,
  );

  /// Sign a transaction with all the wallet's signers. This function returns an encapsulated bool that
  /// has the value true if the PSBT was finalized, or false otherwise.
  ///
  /// The [SignOptions] can be used to tweak the behavior of the software signers, and the way
  /// the transaction is finalized at the end. Note that it can't be guaranteed that *every*
  /// signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
  /// in this library will.
  static bool sign({
    required BdkWallet ptr,
    required BdkPsbt psbt,
    SignOptions? signOptions,
  }) => core.instance.api.crateApiWalletBdkWalletSign(
    ptr: ptr,
    psbt: psbt,
    signOptions: signOptions,
  );

  /// Sync the internal database with the blockchain.
  static Future<void> sync_({
    required BdkWallet ptr,
    required BdkBlockchain blockchain,
  }) => core.instance.api.crateApiWalletBdkWalletSync(
    ptr: ptr,
    blockchain: blockchain,
  );

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkWallet &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
