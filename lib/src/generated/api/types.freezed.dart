// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AddressIndex {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressIndexCopyWith<$Res> {
  factory $AddressIndexCopyWith(
          AddressIndex value, $Res Function(AddressIndex) then) =
      _$AddressIndexCopyWithImpl<$Res, AddressIndex>;
}

/// @nodoc
class _$AddressIndexCopyWithImpl<$Res, $Val extends AddressIndex>
    implements $AddressIndexCopyWith<$Res> {
  _$AddressIndexCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AddressIndex_IncreaseImplCopyWith<$Res> {
  factory _$$AddressIndex_IncreaseImplCopyWith(
          _$AddressIndex_IncreaseImpl value,
          $Res Function(_$AddressIndex_IncreaseImpl) then) =
      __$$AddressIndex_IncreaseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_IncreaseImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_IncreaseImpl>
    implements _$$AddressIndex_IncreaseImplCopyWith<$Res> {
  __$$AddressIndex_IncreaseImplCopyWithImpl(_$AddressIndex_IncreaseImpl _value,
      $Res Function(_$AddressIndex_IncreaseImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_IncreaseImpl extends AddressIndex_Increase {
  const _$AddressIndex_IncreaseImpl() : super._();

  @override
  String toString() {
    return 'AddressIndex.increase()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_IncreaseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return increase();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return increase?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (increase != null) {
      return increase();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return increase(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return increase?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (increase != null) {
      return increase(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Increase extends AddressIndex {
  const factory AddressIndex_Increase() = _$AddressIndex_IncreaseImpl;
  const AddressIndex_Increase._() : super._();
}

/// @nodoc
abstract class _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  factory _$$AddressIndex_LastUnusedImplCopyWith(
          _$AddressIndex_LastUnusedImpl value,
          $Res Function(_$AddressIndex_LastUnusedImpl) then) =
      __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_LastUnusedImpl>
    implements _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  __$$AddressIndex_LastUnusedImplCopyWithImpl(
      _$AddressIndex_LastUnusedImpl _value,
      $Res Function(_$AddressIndex_LastUnusedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_LastUnusedImpl extends AddressIndex_LastUnused {
  const _$AddressIndex_LastUnusedImpl() : super._();

  @override
  String toString() {
    return 'AddressIndex.lastUnused()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_LastUnusedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return lastUnused();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return lastUnused?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return lastUnused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return lastUnused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_LastUnused extends AddressIndex {
  const factory AddressIndex_LastUnused() = _$AddressIndex_LastUnusedImpl;
  const AddressIndex_LastUnused._() : super._();
}

/// @nodoc
abstract class _$$AddressIndex_PeekImplCopyWith<$Res> {
  factory _$$AddressIndex_PeekImplCopyWith(_$AddressIndex_PeekImpl value,
          $Res Function(_$AddressIndex_PeekImpl) then) =
      __$$AddressIndex_PeekImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_PeekImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_PeekImpl>
    implements _$$AddressIndex_PeekImplCopyWith<$Res> {
  __$$AddressIndex_PeekImplCopyWithImpl(_$AddressIndex_PeekImpl _value,
      $Res Function(_$AddressIndex_PeekImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_PeekImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_PeekImpl extends AddressIndex_Peek {
  const _$AddressIndex_PeekImpl({required this.index}) : super._();

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.peek(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_PeekImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      __$$AddressIndex_PeekImplCopyWithImpl<_$AddressIndex_PeekImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return peek(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return peek?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return peek(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return peek?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Peek extends AddressIndex {
  const factory AddressIndex_Peek({required final int index}) =
      _$AddressIndex_PeekImpl;
  const AddressIndex_Peek._() : super._();

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddressIndex_ResetImplCopyWith<$Res> {
  factory _$$AddressIndex_ResetImplCopyWith(_$AddressIndex_ResetImpl value,
          $Res Function(_$AddressIndex_ResetImpl) then) =
      __$$AddressIndex_ResetImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_ResetImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_ResetImpl>
    implements _$$AddressIndex_ResetImplCopyWith<$Res> {
  __$$AddressIndex_ResetImplCopyWithImpl(_$AddressIndex_ResetImpl _value,
      $Res Function(_$AddressIndex_ResetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_ResetImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_ResetImpl extends AddressIndex_Reset {
  const _$AddressIndex_ResetImpl({required this.index}) : super._();

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.reset(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_ResetImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      __$$AddressIndex_ResetImplCopyWithImpl<_$AddressIndex_ResetImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return reset(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return reset?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Reset extends AddressIndex {
  const factory AddressIndex_Reset({required final int index}) =
      _$AddressIndex_ResetImpl;
  const AddressIndex_Reset._() : super._();

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DatabaseConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DatabaseConfigCopyWith<$Res> {
  factory $DatabaseConfigCopyWith(
          DatabaseConfig value, $Res Function(DatabaseConfig) then) =
      _$DatabaseConfigCopyWithImpl<$Res, DatabaseConfig>;
}

/// @nodoc
class _$DatabaseConfigCopyWithImpl<$Res, $Val extends DatabaseConfig>
    implements $DatabaseConfigCopyWith<$Res> {
  _$DatabaseConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  factory _$$DatabaseConfig_MemoryImplCopyWith(
          _$DatabaseConfig_MemoryImpl value,
          $Res Function(_$DatabaseConfig_MemoryImpl) then) =
      __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_MemoryImpl>
    implements _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  __$$DatabaseConfig_MemoryImplCopyWithImpl(_$DatabaseConfig_MemoryImpl _value,
      $Res Function(_$DatabaseConfig_MemoryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DatabaseConfig_MemoryImpl extends DatabaseConfig_Memory {
  const _$DatabaseConfig_MemoryImpl() : super._();

  @override
  String toString() {
    return 'DatabaseConfig.memory()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_MemoryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return memory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return memory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return memory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return memory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Memory extends DatabaseConfig {
  const factory DatabaseConfig_Memory() = _$DatabaseConfig_MemoryImpl;
  const DatabaseConfig_Memory._() : super._();
}

/// @nodoc
abstract class _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SqliteImplCopyWith(
          _$DatabaseConfig_SqliteImpl value,
          $Res Function(_$DatabaseConfig_SqliteImpl) then) =
      __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SqliteDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SqliteImpl>
    implements _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  __$$DatabaseConfig_SqliteImplCopyWithImpl(_$DatabaseConfig_SqliteImpl _value,
      $Res Function(_$DatabaseConfig_SqliteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SqliteImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SqliteDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SqliteImpl extends DatabaseConfig_Sqlite {
  const _$DatabaseConfig_SqliteImpl({required this.config}) : super._();

  @override
  final SqliteDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sqlite(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SqliteImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => __$$DatabaseConfig_SqliteImplCopyWithImpl<
          _$DatabaseConfig_SqliteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sqlite(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sqlite?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sqlite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sqlite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sqlite extends DatabaseConfig {
  const factory DatabaseConfig_Sqlite(
          {required final SqliteDbConfiguration config}) =
      _$DatabaseConfig_SqliteImpl;
  const DatabaseConfig_Sqlite._() : super._();

  SqliteDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DatabaseConfig_SledImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SledImplCopyWith(_$DatabaseConfig_SledImpl value,
          $Res Function(_$DatabaseConfig_SledImpl) then) =
      __$$DatabaseConfig_SledImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SledDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SledImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SledImpl>
    implements _$$DatabaseConfig_SledImplCopyWith<$Res> {
  __$$DatabaseConfig_SledImplCopyWithImpl(_$DatabaseConfig_SledImpl _value,
      $Res Function(_$DatabaseConfig_SledImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SledImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SledDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SledImpl extends DatabaseConfig_Sled {
  const _$DatabaseConfig_SledImpl({required this.config}) : super._();

  @override
  final SledDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sled(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SledImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      __$$DatabaseConfig_SledImplCopyWithImpl<_$DatabaseConfig_SledImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sled(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sled?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sled extends DatabaseConfig {
  const factory DatabaseConfig_Sled(
      {required final SledDbConfiguration config}) = _$DatabaseConfig_SledImpl;
  const DatabaseConfig_Sled._() : super._();

  SledDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LockTime {
  int get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LockTimeCopyWith<LockTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LockTimeCopyWith<$Res> {
  factory $LockTimeCopyWith(LockTime value, $Res Function(LockTime) then) =
      _$LockTimeCopyWithImpl<$Res, LockTime>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$LockTimeCopyWithImpl<$Res, $Val extends LockTime>
    implements $LockTimeCopyWith<$Res> {
  _$LockTimeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LockTime_BlocksImplCopyWith<$Res>
    implements $LockTimeCopyWith<$Res> {
  factory _$$LockTime_BlocksImplCopyWith(_$LockTime_BlocksImpl value,
          $Res Function(_$LockTime_BlocksImpl) then) =
      __$$LockTime_BlocksImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LockTime_BlocksImplCopyWithImpl<$Res>
    extends _$LockTimeCopyWithImpl<$Res, _$LockTime_BlocksImpl>
    implements _$$LockTime_BlocksImplCopyWith<$Res> {
  __$$LockTime_BlocksImplCopyWithImpl(
      _$LockTime_BlocksImpl _value, $Res Function(_$LockTime_BlocksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LockTime_BlocksImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LockTime_BlocksImpl extends LockTime_Blocks {
  const _$LockTime_BlocksImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'LockTime.blocks(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LockTime_BlocksImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LockTime_BlocksImplCopyWith<_$LockTime_BlocksImpl> get copyWith =>
      __$$LockTime_BlocksImplCopyWithImpl<_$LockTime_BlocksImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) {
    return blocks(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) {
    return blocks?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) {
    if (blocks != null) {
      return blocks(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) {
    return blocks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) {
    return blocks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) {
    if (blocks != null) {
      return blocks(this);
    }
    return orElse();
  }
}

abstract class LockTime_Blocks extends LockTime {
  const factory LockTime_Blocks(final int field0) = _$LockTime_BlocksImpl;
  const LockTime_Blocks._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$LockTime_BlocksImplCopyWith<_$LockTime_BlocksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LockTime_SecondsImplCopyWith<$Res>
    implements $LockTimeCopyWith<$Res> {
  factory _$$LockTime_SecondsImplCopyWith(_$LockTime_SecondsImpl value,
          $Res Function(_$LockTime_SecondsImpl) then) =
      __$$LockTime_SecondsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LockTime_SecondsImplCopyWithImpl<$Res>
    extends _$LockTimeCopyWithImpl<$Res, _$LockTime_SecondsImpl>
    implements _$$LockTime_SecondsImplCopyWith<$Res> {
  __$$LockTime_SecondsImplCopyWithImpl(_$LockTime_SecondsImpl _value,
      $Res Function(_$LockTime_SecondsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LockTime_SecondsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LockTime_SecondsImpl extends LockTime_Seconds {
  const _$LockTime_SecondsImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'LockTime.seconds(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LockTime_SecondsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LockTime_SecondsImplCopyWith<_$LockTime_SecondsImpl> get copyWith =>
      __$$LockTime_SecondsImplCopyWithImpl<_$LockTime_SecondsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) {
    return seconds(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) {
    return seconds?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) {
    if (seconds != null) {
      return seconds(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) {
    return seconds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) {
    return seconds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) {
    if (seconds != null) {
      return seconds(this);
    }
    return orElse();
  }
}

abstract class LockTime_Seconds extends LockTime {
  const factory LockTime_Seconds(final int field0) = _$LockTime_SecondsImpl;
  const LockTime_Seconds._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$LockTime_SecondsImplCopyWith<_$LockTime_SecondsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Payload {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PayloadCopyWith<$Res> {
  factory $PayloadCopyWith(Payload value, $Res Function(Payload) then) =
      _$PayloadCopyWithImpl<$Res, Payload>;
}

/// @nodoc
class _$PayloadCopyWithImpl<$Res, $Val extends Payload>
    implements $PayloadCopyWith<$Res> {
  _$PayloadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Payload_PubkeyHashImplCopyWith<$Res> {
  factory _$$Payload_PubkeyHashImplCopyWith(_$Payload_PubkeyHashImpl value,
          $Res Function(_$Payload_PubkeyHashImpl) then) =
      __$$Payload_PubkeyHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String pubkeyHash});
}

/// @nodoc
class __$$Payload_PubkeyHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_PubkeyHashImpl>
    implements _$$Payload_PubkeyHashImplCopyWith<$Res> {
  __$$Payload_PubkeyHashImplCopyWithImpl(_$Payload_PubkeyHashImpl _value,
      $Res Function(_$Payload_PubkeyHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pubkeyHash = null,
  }) {
    return _then(_$Payload_PubkeyHashImpl(
      pubkeyHash: null == pubkeyHash
          ? _value.pubkeyHash
          : pubkeyHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Payload_PubkeyHashImpl extends Payload_PubkeyHash {
  const _$Payload_PubkeyHashImpl({required this.pubkeyHash}) : super._();

  @override
  final String pubkeyHash;

  @override
  String toString() {
    return 'Payload.pubkeyHash(pubkeyHash: $pubkeyHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_PubkeyHashImpl &&
            (identical(other.pubkeyHash, pubkeyHash) ||
                other.pubkeyHash == pubkeyHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pubkeyHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      __$$Payload_PubkeyHashImplCopyWithImpl<_$Payload_PubkeyHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return pubkeyHash(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return pubkeyHash?.call(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this.pubkeyHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return pubkeyHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return pubkeyHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this);
    }
    return orElse();
  }
}

abstract class Payload_PubkeyHash extends Payload {
  const factory Payload_PubkeyHash({required final String pubkeyHash}) =
      _$Payload_PubkeyHashImpl;
  const Payload_PubkeyHash._() : super._();

  String get pubkeyHash;
  @JsonKey(ignore: true)
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_ScriptHashImplCopyWith<$Res> {
  factory _$$Payload_ScriptHashImplCopyWith(_$Payload_ScriptHashImpl value,
          $Res Function(_$Payload_ScriptHashImpl) then) =
      __$$Payload_ScriptHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String scriptHash});
}

/// @nodoc
class __$$Payload_ScriptHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_ScriptHashImpl>
    implements _$$Payload_ScriptHashImplCopyWith<$Res> {
  __$$Payload_ScriptHashImplCopyWithImpl(_$Payload_ScriptHashImpl _value,
      $Res Function(_$Payload_ScriptHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scriptHash = null,
  }) {
    return _then(_$Payload_ScriptHashImpl(
      scriptHash: null == scriptHash
          ? _value.scriptHash
          : scriptHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Payload_ScriptHashImpl extends Payload_ScriptHash {
  const _$Payload_ScriptHashImpl({required this.scriptHash}) : super._();

  @override
  final String scriptHash;

  @override
  String toString() {
    return 'Payload.scriptHash(scriptHash: $scriptHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_ScriptHashImpl &&
            (identical(other.scriptHash, scriptHash) ||
                other.scriptHash == scriptHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, scriptHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      __$$Payload_ScriptHashImplCopyWithImpl<_$Payload_ScriptHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return scriptHash(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return scriptHash?.call(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this.scriptHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return scriptHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return scriptHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this);
    }
    return orElse();
  }
}

abstract class Payload_ScriptHash extends Payload {
  const factory Payload_ScriptHash({required final String scriptHash}) =
      _$Payload_ScriptHashImpl;
  const Payload_ScriptHash._() : super._();

  String get scriptHash;
  @JsonKey(ignore: true)
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_WitnessProgramImplCopyWith<$Res> {
  factory _$$Payload_WitnessProgramImplCopyWith(
          _$Payload_WitnessProgramImpl value,
          $Res Function(_$Payload_WitnessProgramImpl) then) =
      __$$Payload_WitnessProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WitnessVersion version, Uint8List program});
}

/// @nodoc
class __$$Payload_WitnessProgramImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_WitnessProgramImpl>
    implements _$$Payload_WitnessProgramImplCopyWith<$Res> {
  __$$Payload_WitnessProgramImplCopyWithImpl(
      _$Payload_WitnessProgramImpl _value,
      $Res Function(_$Payload_WitnessProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? program = null,
  }) {
    return _then(_$Payload_WitnessProgramImpl(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as WitnessVersion,
      program: null == program
          ? _value.program
          : program // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Payload_WitnessProgramImpl extends Payload_WitnessProgram {
  const _$Payload_WitnessProgramImpl(
      {required this.version, required this.program})
      : super._();

  /// The witness program version.
  @override
  final WitnessVersion version;

  /// The witness program.
  @override
  final Uint8List program;

  @override
  String toString() {
    return 'Payload.witnessProgram(version: $version, program: $program)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_WitnessProgramImpl &&
            (identical(other.version, version) || other.version == version) &&
            const DeepCollectionEquality().equals(other.program, program));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, version, const DeepCollectionEquality().hash(program));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => __$$Payload_WitnessProgramImplCopyWithImpl<
          _$Payload_WitnessProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return witnessProgram(version, program);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return witnessProgram?.call(version, program);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(version, program);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return witnessProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return witnessProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(this);
    }
    return orElse();
  }
}

abstract class Payload_WitnessProgram extends Payload {
  const factory Payload_WitnessProgram(
      {required final WitnessVersion version,
      required final Uint8List program}) = _$Payload_WitnessProgramImpl;
  const Payload_WitnessProgram._() : super._();

  /// The witness program version.
  WitnessVersion get version;

  /// The witness program.
  Uint8List get program;
  @JsonKey(ignore: true)
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RbfValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RbfValueCopyWith<$Res> {
  factory $RbfValueCopyWith(RbfValue value, $Res Function(RbfValue) then) =
      _$RbfValueCopyWithImpl<$Res, RbfValue>;
}

/// @nodoc
class _$RbfValueCopyWithImpl<$Res, $Val extends RbfValue>
    implements $RbfValueCopyWith<$Res> {
  _$RbfValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  factory _$$RbfValue_RbfDefaultImplCopyWith(_$RbfValue_RbfDefaultImpl value,
          $Res Function(_$RbfValue_RbfDefaultImpl) then) =
      __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_RbfDefaultImpl>
    implements _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  __$$RbfValue_RbfDefaultImplCopyWithImpl(_$RbfValue_RbfDefaultImpl _value,
      $Res Function(_$RbfValue_RbfDefaultImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RbfValue_RbfDefaultImpl extends RbfValue_RbfDefault {
  const _$RbfValue_RbfDefaultImpl() : super._();

  @override
  String toString() {
    return 'RbfValue.rbfDefault()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_RbfDefaultImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return rbfDefault();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return rbfDefault?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return rbfDefault(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return rbfDefault?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault(this);
    }
    return orElse();
  }
}

abstract class RbfValue_RbfDefault extends RbfValue {
  const factory RbfValue_RbfDefault() = _$RbfValue_RbfDefaultImpl;
  const RbfValue_RbfDefault._() : super._();
}

/// @nodoc
abstract class _$$RbfValue_ValueImplCopyWith<$Res> {
  factory _$$RbfValue_ValueImplCopyWith(_$RbfValue_ValueImpl value,
          $Res Function(_$RbfValue_ValueImpl) then) =
      __$$RbfValue_ValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$RbfValue_ValueImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_ValueImpl>
    implements _$$RbfValue_ValueImplCopyWith<$Res> {
  __$$RbfValue_ValueImplCopyWithImpl(
      _$RbfValue_ValueImpl _value, $Res Function(_$RbfValue_ValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RbfValue_ValueImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RbfValue_ValueImpl extends RbfValue_Value {
  const _$RbfValue_ValueImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'RbfValue.value(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_ValueImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      __$$RbfValue_ValueImplCopyWithImpl<_$RbfValue_ValueImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return value(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return value?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return value(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return value?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(this);
    }
    return orElse();
  }
}

abstract class RbfValue_Value extends RbfValue {
  const factory RbfValue_Value(final int field0) = _$RbfValue_ValueImpl;
  const RbfValue_Value._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
