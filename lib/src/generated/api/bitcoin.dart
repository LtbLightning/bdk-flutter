// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `try_from`, `try_from`

class FeeRate {
  ///Constructs FeeRate from satoshis per 1000 weight units.
  final BigInt satKwu;

  const FeeRate({
    required this.satKwu,
  });

  @override
  int get hashCode => satKwu.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FeeRate &&
          runtimeType == other.runtimeType &&
          satKwu == other.satKwu;
}

class FfiAddress {
  final Address field0;

  const FfiAddress({
    required this.field0,
  });

  String asString() => core.instance.api.crateApiBitcoinFfiAddressAsString(
        that: this,
      );

  static Future<FfiAddress> fromScript(
          {required FfiScriptBuf script, required Network network}) =>
      core.instance.api.crateApiBitcoinFfiAddressFromScript(
          script: script, network: network);

  static Future<FfiAddress> fromString(
          {required String address, required Network network}) =>
      core.instance.api.crateApiBitcoinFfiAddressFromString(
          address: address, network: network);

  bool isValidForNetwork({required Network network}) => core.instance.api
      .crateApiBitcoinFfiAddressIsValidForNetwork(that: this, network: network);

  static FfiScriptBuf script({required FfiAddress opaque}) =>
      core.instance.api.crateApiBitcoinFfiAddressScript(opaque: opaque);

  String toQrUri() => core.instance.api.crateApiBitcoinFfiAddressToQrUri(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiAddress &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiPsbt {
  final MutexPsbt opaque;

  const FfiPsbt({
    required this.opaque,
  });

  String asString() => core.instance.api.crateApiBitcoinFfiPsbtAsString(
        that: this,
      );

  /// Combines this PartiallySignedTransaction with other PSBT as described by BIP 174.
  ///
  /// In accordance with BIP 174 this function is commutative i.e., `A.combine(B) == B.combine(A)`
  static Future<FfiPsbt> combine(
          {required FfiPsbt opaque, required FfiPsbt other}) =>
      core.instance.api
          .crateApiBitcoinFfiPsbtCombine(opaque: opaque, other: other);

  /// Return the transaction.
  static FfiTransaction extractTx({required FfiPsbt opaque}) =>
      core.instance.api.crateApiBitcoinFfiPsbtExtractTx(opaque: opaque);

  /// The total transaction fee amount, sum of input amounts minus sum of output amounts, in Sats.
  /// If the PSBT is missing a TxOut for an input returns None.
  BigInt? feeAmount() => core.instance.api.crateApiBitcoinFfiPsbtFeeAmount(
        that: this,
      );

  static Future<FfiPsbt> fromStr({required String psbtBase64}) =>
      core.instance.api.crateApiBitcoinFfiPsbtFromStr(psbtBase64: psbtBase64);

  /// Serialize the PSBT data structure as a String of JSON.
  String jsonSerialize() =>
      core.instance.api.crateApiBitcoinFfiPsbtJsonSerialize(
        that: this,
      );

  ///Serialize as raw binary data
  Uint8List serialize() => core.instance.api.crateApiBitcoinFfiPsbtSerialize(
        that: this,
      );

  @override
  int get hashCode => opaque.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiPsbt &&
          runtimeType == other.runtimeType &&
          opaque == other.opaque;
}

class FfiScriptBuf {
  final Uint8List bytes;

  const FfiScriptBuf({
    required this.bytes,
  });

  String asString() => core.instance.api.crateApiBitcoinFfiScriptBufAsString(
        that: this,
      );

  ///Creates a new empty script.
  static FfiScriptBuf empty() =>
      core.instance.api.crateApiBitcoinFfiScriptBufEmpty();

  ///Creates a new empty script with pre-allocated capacity.
  static Future<FfiScriptBuf> withCapacity({required BigInt capacity}) =>
      core.instance.api
          .crateApiBitcoinFfiScriptBufWithCapacity(capacity: capacity);

  @override
  int get hashCode => bytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiScriptBuf &&
          runtimeType == other.runtimeType &&
          bytes == other.bytes;
}

class FfiTransaction {
  final Transaction opaque;

  const FfiTransaction({
    required this.opaque,
  });

  /// Computes the [`Txid`].
  ///
  /// Hashes the transaction **excluding** the segwit data (i.e. the marker, flag bytes, and the
  /// witness fields themselves). For non-segwit transactions which do not have any segwit data,
  Future<String> computeTxid() =>
      core.instance.api.crateApiBitcoinFfiTransactionComputeTxid(
        that: this,
      );

  static Future<FfiTransaction> fromBytes(
          {required List<int> transactionBytes}) =>
      core.instance.api.crateApiBitcoinFfiTransactionFromBytes(
          transactionBytes: transactionBytes);

  ///List of transaction inputs.
  Future<List<TxIn>> input() =>
      core.instance.api.crateApiBitcoinFfiTransactionInput(
        that: this,
      );

  ///Is this a coin base transaction?
  Future<bool> isCoinbase() =>
      core.instance.api.crateApiBitcoinFfiTransactionIsCoinbase(
        that: this,
      );

  ///Returns true if the transaction itself opted in to be BIP-125-replaceable (RBF).
  /// This does not cover the case where a transaction becomes replaceable due to ancestors being RBF.
  Future<bool> isExplicitlyRbf() =>
      core.instance.api.crateApiBitcoinFfiTransactionIsExplicitlyRbf(
        that: this,
      );

  ///Returns true if this transactions nLockTime is enabled (BIP-65 ).
  Future<bool> isLockTimeEnabled() =>
      core.instance.api.crateApiBitcoinFfiTransactionIsLockTimeEnabled(
        that: this,
      );

  ///Block height or timestamp. Transaction cannot be included in a block until this height/time.
  Future<LockTime> lockTime() =>
      core.instance.api.crateApiBitcoinFfiTransactionLockTime(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FfiTransaction> newInstance(
          {required int version,
          required LockTime lockTime,
          required List<TxIn> input,
          required List<TxOut> output}) =>
      core.instance.api.crateApiBitcoinFfiTransactionNew(
          version: version, lockTime: lockTime, input: input, output: output);

  ///List of transaction outputs.
  Future<List<TxOut>> output() =>
      core.instance.api.crateApiBitcoinFfiTransactionOutput(
        that: this,
      );

  ///Encodes an object into a vector.
  Future<Uint8List> serialize() =>
      core.instance.api.crateApiBitcoinFfiTransactionSerialize(
        that: this,
      );

  ///The protocol version, is currently expected to be 1 or 2 (BIP 68).
  Future<int> version() =>
      core.instance.api.crateApiBitcoinFfiTransactionVersion(
        that: this,
      );

  ///Returns the “virtual size” (vsize) of this transaction.
  ///
  Future<BigInt> vsize() =>
      core.instance.api.crateApiBitcoinFfiTransactionVsize(
        that: this,
      );

  ///Returns the regular byte-wise consensus-serialized size of this transaction.
  Future<BigInt> weight() =>
      core.instance.api.crateApiBitcoinFfiTransactionWeight(
        that: this,
      );

  @override
  int get hashCode => opaque.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiTransaction &&
          runtimeType == other.runtimeType &&
          opaque == other.opaque;
}

class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

class TxIn {
  final OutPoint previousOutput;
  final FfiScriptBuf scriptSig;
  final int sequence;
  final List<Uint8List> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });

  @override
  int get hashCode =>
      previousOutput.hashCode ^
      scriptSig.hashCode ^
      sequence.hashCode ^
      witness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxIn &&
          runtimeType == other.runtimeType &&
          previousOutput == other.previousOutput &&
          scriptSig == other.scriptSig &&
          sequence == other.sequence &&
          witness == other.witness;
}

///A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final BigInt value;

  /// The address of the output.
  final FfiScriptBuf scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}
