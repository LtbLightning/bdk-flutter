// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<bitcoin :: bip32 :: DerivationPath>
@sealed
class BitcoinBip32DerivationPath extends RustOpaque {
  BitcoinBip32DerivationPath.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BitcoinBip32DerivationPath.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore.instance.api
        .rust_arc_increment_strong_count_BitcoinBip32DerivationPath,
    rustArcDecrementStrongCount: BdkCore.instance.api
        .rust_arc_decrement_strong_count_BitcoinBip32DerivationPath,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_BitcoinBip32DerivationPathPtr,
  );
}

// Rust type: RustOpaqueNom<keys :: bip39 :: Mnemonic>
@sealed
class KeysBip39Mnemonic extends RustOpaque {
  KeysBip39Mnemonic.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  KeysBip39Mnemonic.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        BdkCore.instance.api.rust_arc_increment_strong_count_KeysBip39Mnemonic,
    rustArcDecrementStrongCount:
        BdkCore.instance.api.rust_arc_decrement_strong_count_KeysBip39Mnemonic,
    rustArcDecrementStrongCountPtr: BdkCore
        .instance.api.rust_arc_decrement_strong_count_KeysBip39MnemonicPtr,
  );
}

class BdkDerivationPath {
  final BitcoinBip32DerivationPath ptr;

  const BdkDerivationPath({
    required this.ptr,
  });

  static Future<BdkDerivationPath> fromString(
          {required String path, dynamic hint}) =>
      BdkCore.instance.api.bdkDerivationPathFromString(path: path, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkDerivationPath &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class BdkDescriptorPublicKey {
  final KeysDescriptorPublicKey ptr;

  const BdkDescriptorPublicKey({
    required this.ptr,
  });

  Future<String> asString({dynamic hint}) => BdkCore.instance.api
      .bdkDescriptorPublicKeyAsString(that: this, hint: hint);

  static Future<BdkDescriptorPublicKey> derive(
          {required BdkDescriptorPublicKey ptr,
          required BdkDerivationPath path,
          dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorPublicKeyDerive(ptr: ptr, path: path, hint: hint);

  static Future<BdkDescriptorPublicKey> extend(
          {required BdkDescriptorPublicKey ptr,
          required BdkDerivationPath path,
          dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorPublicKeyExtend(ptr: ptr, path: path, hint: hint);

  static Future<BdkDescriptorPublicKey> fromString(
          {required String publicKey, dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorPublicKeyFromString(publicKey: publicKey, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkDescriptorPublicKey &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class BdkDescriptorSecretKey {
  final KeysDescriptorSecretKey ptr;

  const BdkDescriptorSecretKey({
    required this.ptr,
  });

  static Future<BdkDescriptorPublicKey> asPublic(
          {required BdkDescriptorSecretKey ptr, dynamic hint}) =>
      BdkCore.instance.api.bdkDescriptorSecretKeyAsPublic(ptr: ptr, hint: hint);

  Future<String> asString({dynamic hint}) => BdkCore.instance.api
      .bdkDescriptorSecretKeyAsString(that: this, hint: hint);

  static Future<BdkDescriptorSecretKey> create(
          {required Network network,
          required BdkMnemonic mnemonic,
          String? password,
          dynamic hint}) =>
      BdkCore.instance.api.bdkDescriptorSecretKeyCreate(
          network: network, mnemonic: mnemonic, password: password, hint: hint);

  static Future<BdkDescriptorSecretKey> derive(
          {required BdkDescriptorSecretKey ptr,
          required BdkDerivationPath path,
          dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorSecretKeyDerive(ptr: ptr, path: path, hint: hint);

  static Future<BdkDescriptorSecretKey> extend(
          {required BdkDescriptorSecretKey ptr,
          required BdkDerivationPath path,
          dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorSecretKeyExtend(ptr: ptr, path: path, hint: hint);

  static Future<BdkDescriptorSecretKey> fromString(
          {required String secretKey, dynamic hint}) =>
      BdkCore.instance.api
          .bdkDescriptorSecretKeyFromString(secretKey: secretKey, hint: hint);

  /// Get the private key as bytes.
  Future<Uint8List> secretBytes({dynamic hint}) => BdkCore.instance.api
      .bdkDescriptorSecretKeySecretBytes(that: this, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkDescriptorSecretKey &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class BdkMnemonic {
  final KeysBip39Mnemonic ptr;

  const BdkMnemonic({
    required this.ptr,
  });

  /// Returns Mnemonic as string
  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.bdkMnemonicAsString(that: this, hint: hint);

  /// Create a new Mnemonic in the specified language from the given entropy.
  /// Entropy must be a multiple of 32 bits (4 bytes) and 128-256 bits in length.
  static Future<BdkMnemonic> fromEntropy(
          {required List<int> entropy, dynamic hint}) =>
      BdkCore.instance.api.bdkMnemonicFromEntropy(entropy: entropy, hint: hint);

  /// Parse a Mnemonic with given string
  static Future<BdkMnemonic> fromString(
          {required String mnemonic, dynamic hint}) =>
      BdkCore.instance.api
          .bdkMnemonicFromString(mnemonic: mnemonic, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Generates Mnemonic with a random entropy
  static Future<BdkMnemonic> newInstance(
          {required WordCount wordCount, dynamic hint}) =>
      BdkCore.instance.api.bdkMnemonicNew(wordCount: wordCount, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkMnemonic &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
