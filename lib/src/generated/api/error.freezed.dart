// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddressParseError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressParseErrorCopyWith<$Res> {
  factory $AddressParseErrorCopyWith(
          AddressParseError value, $Res Function(AddressParseError) then) =
      _$AddressParseErrorCopyWithImpl<$Res, AddressParseError>;
}

/// @nodoc
class _$AddressParseErrorCopyWithImpl<$Res, $Val extends AddressParseError>
    implements $AddressParseErrorCopyWith<$Res> {
  _$AddressParseErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AddressParseError_Base58ImplCopyWith<$Res> {
  factory _$$AddressParseError_Base58ImplCopyWith(
          _$AddressParseError_Base58Impl value,
          $Res Function(_$AddressParseError_Base58Impl) then) =
      __$$AddressParseError_Base58ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_Base58ImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_Base58Impl>
    implements _$$AddressParseError_Base58ImplCopyWith<$Res> {
  __$$AddressParseError_Base58ImplCopyWithImpl(
      _$AddressParseError_Base58Impl _value,
      $Res Function(_$AddressParseError_Base58Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_Base58Impl extends AddressParseError_Base58 {
  const _$AddressParseError_Base58Impl() : super._();

  @override
  String toString() {
    return 'AddressParseError.base58()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_Base58Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return base58();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return base58?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return base58(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return base58?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_Base58 extends AddressParseError {
  const factory AddressParseError_Base58() = _$AddressParseError_Base58Impl;
  const AddressParseError_Base58._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_Bech32ImplCopyWith<$Res> {
  factory _$$AddressParseError_Bech32ImplCopyWith(
          _$AddressParseError_Bech32Impl value,
          $Res Function(_$AddressParseError_Bech32Impl) then) =
      __$$AddressParseError_Bech32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_Bech32ImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_Bech32Impl>
    implements _$$AddressParseError_Bech32ImplCopyWith<$Res> {
  __$$AddressParseError_Bech32ImplCopyWithImpl(
      _$AddressParseError_Bech32Impl _value,
      $Res Function(_$AddressParseError_Bech32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_Bech32Impl extends AddressParseError_Bech32 {
  const _$AddressParseError_Bech32Impl() : super._();

  @override
  String toString() {
    return 'AddressParseError.bech32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_Bech32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return bech32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return bech32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (bech32 != null) {
      return bech32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return bech32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return bech32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (bech32 != null) {
      return bech32(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_Bech32 extends AddressParseError {
  const factory AddressParseError_Bech32() = _$AddressParseError_Bech32Impl;
  const AddressParseError_Bech32._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_WitnessVersionImplCopyWith<$Res> {
  factory _$$AddressParseError_WitnessVersionImplCopyWith(
          _$AddressParseError_WitnessVersionImpl value,
          $Res Function(_$AddressParseError_WitnessVersionImpl) then) =
      __$$AddressParseError_WitnessVersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$AddressParseError_WitnessVersionImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_WitnessVersionImpl>
    implements _$$AddressParseError_WitnessVersionImplCopyWith<$Res> {
  __$$AddressParseError_WitnessVersionImplCopyWithImpl(
      _$AddressParseError_WitnessVersionImpl _value,
      $Res Function(_$AddressParseError_WitnessVersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$AddressParseError_WitnessVersionImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AddressParseError_WitnessVersionImpl
    extends AddressParseError_WitnessVersion {
  const _$AddressParseError_WitnessVersionImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'AddressParseError.witnessVersion(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_WitnessVersionImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressParseError_WitnessVersionImplCopyWith<
          _$AddressParseError_WitnessVersionImpl>
      get copyWith => __$$AddressParseError_WitnessVersionImplCopyWithImpl<
          _$AddressParseError_WitnessVersionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return witnessVersion(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return witnessVersion?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (witnessVersion != null) {
      return witnessVersion(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return witnessVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return witnessVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (witnessVersion != null) {
      return witnessVersion(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_WitnessVersion extends AddressParseError {
  const factory AddressParseError_WitnessVersion(
          {required final String errorMessage}) =
      _$AddressParseError_WitnessVersionImpl;
  const AddressParseError_WitnessVersion._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$AddressParseError_WitnessVersionImplCopyWith<
          _$AddressParseError_WitnessVersionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddressParseError_WitnessProgramImplCopyWith<$Res> {
  factory _$$AddressParseError_WitnessProgramImplCopyWith(
          _$AddressParseError_WitnessProgramImpl value,
          $Res Function(_$AddressParseError_WitnessProgramImpl) then) =
      __$$AddressParseError_WitnessProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$AddressParseError_WitnessProgramImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_WitnessProgramImpl>
    implements _$$AddressParseError_WitnessProgramImplCopyWith<$Res> {
  __$$AddressParseError_WitnessProgramImplCopyWithImpl(
      _$AddressParseError_WitnessProgramImpl _value,
      $Res Function(_$AddressParseError_WitnessProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$AddressParseError_WitnessProgramImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AddressParseError_WitnessProgramImpl
    extends AddressParseError_WitnessProgram {
  const _$AddressParseError_WitnessProgramImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'AddressParseError.witnessProgram(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_WitnessProgramImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressParseError_WitnessProgramImplCopyWith<
          _$AddressParseError_WitnessProgramImpl>
      get copyWith => __$$AddressParseError_WitnessProgramImplCopyWithImpl<
          _$AddressParseError_WitnessProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return witnessProgram(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return witnessProgram?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return witnessProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return witnessProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_WitnessProgram extends AddressParseError {
  const factory AddressParseError_WitnessProgram(
          {required final String errorMessage}) =
      _$AddressParseError_WitnessProgramImpl;
  const AddressParseError_WitnessProgram._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$AddressParseError_WitnessProgramImplCopyWith<
          _$AddressParseError_WitnessProgramImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddressParseError_UnknownHrpImplCopyWith<$Res> {
  factory _$$AddressParseError_UnknownHrpImplCopyWith(
          _$AddressParseError_UnknownHrpImpl value,
          $Res Function(_$AddressParseError_UnknownHrpImpl) then) =
      __$$AddressParseError_UnknownHrpImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_UnknownHrpImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_UnknownHrpImpl>
    implements _$$AddressParseError_UnknownHrpImplCopyWith<$Res> {
  __$$AddressParseError_UnknownHrpImplCopyWithImpl(
      _$AddressParseError_UnknownHrpImpl _value,
      $Res Function(_$AddressParseError_UnknownHrpImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_UnknownHrpImpl extends AddressParseError_UnknownHrp {
  const _$AddressParseError_UnknownHrpImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.unknownHrp()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_UnknownHrpImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return unknownHrp();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return unknownHrp?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (unknownHrp != null) {
      return unknownHrp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return unknownHrp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return unknownHrp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (unknownHrp != null) {
      return unknownHrp(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_UnknownHrp extends AddressParseError {
  const factory AddressParseError_UnknownHrp() =
      _$AddressParseError_UnknownHrpImpl;
  const AddressParseError_UnknownHrp._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_LegacyAddressTooLongImplCopyWith<$Res> {
  factory _$$AddressParseError_LegacyAddressTooLongImplCopyWith(
          _$AddressParseError_LegacyAddressTooLongImpl value,
          $Res Function(_$AddressParseError_LegacyAddressTooLongImpl) then) =
      __$$AddressParseError_LegacyAddressTooLongImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_LegacyAddressTooLongImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_LegacyAddressTooLongImpl>
    implements _$$AddressParseError_LegacyAddressTooLongImplCopyWith<$Res> {
  __$$AddressParseError_LegacyAddressTooLongImplCopyWithImpl(
      _$AddressParseError_LegacyAddressTooLongImpl _value,
      $Res Function(_$AddressParseError_LegacyAddressTooLongImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_LegacyAddressTooLongImpl
    extends AddressParseError_LegacyAddressTooLong {
  const _$AddressParseError_LegacyAddressTooLongImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.legacyAddressTooLong()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_LegacyAddressTooLongImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return legacyAddressTooLong();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return legacyAddressTooLong?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (legacyAddressTooLong != null) {
      return legacyAddressTooLong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return legacyAddressTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return legacyAddressTooLong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (legacyAddressTooLong != null) {
      return legacyAddressTooLong(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_LegacyAddressTooLong
    extends AddressParseError {
  const factory AddressParseError_LegacyAddressTooLong() =
      _$AddressParseError_LegacyAddressTooLongImpl;
  const AddressParseError_LegacyAddressTooLong._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_InvalidBase58PayloadLengthImplCopyWith<
    $Res> {
  factory _$$AddressParseError_InvalidBase58PayloadLengthImplCopyWith(
          _$AddressParseError_InvalidBase58PayloadLengthImpl value,
          $Res Function(_$AddressParseError_InvalidBase58PayloadLengthImpl)
              then) =
      __$$AddressParseError_InvalidBase58PayloadLengthImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_InvalidBase58PayloadLengthImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_InvalidBase58PayloadLengthImpl>
    implements
        _$$AddressParseError_InvalidBase58PayloadLengthImplCopyWith<$Res> {
  __$$AddressParseError_InvalidBase58PayloadLengthImplCopyWithImpl(
      _$AddressParseError_InvalidBase58PayloadLengthImpl _value,
      $Res Function(_$AddressParseError_InvalidBase58PayloadLengthImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_InvalidBase58PayloadLengthImpl
    extends AddressParseError_InvalidBase58PayloadLength {
  const _$AddressParseError_InvalidBase58PayloadLengthImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.invalidBase58PayloadLength()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_InvalidBase58PayloadLengthImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return invalidBase58PayloadLength();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return invalidBase58PayloadLength?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (invalidBase58PayloadLength != null) {
      return invalidBase58PayloadLength();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return invalidBase58PayloadLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return invalidBase58PayloadLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (invalidBase58PayloadLength != null) {
      return invalidBase58PayloadLength(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_InvalidBase58PayloadLength
    extends AddressParseError {
  const factory AddressParseError_InvalidBase58PayloadLength() =
      _$AddressParseError_InvalidBase58PayloadLengthImpl;
  const AddressParseError_InvalidBase58PayloadLength._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_InvalidLegacyPrefixImplCopyWith<$Res> {
  factory _$$AddressParseError_InvalidLegacyPrefixImplCopyWith(
          _$AddressParseError_InvalidLegacyPrefixImpl value,
          $Res Function(_$AddressParseError_InvalidLegacyPrefixImpl) then) =
      __$$AddressParseError_InvalidLegacyPrefixImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_InvalidLegacyPrefixImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_InvalidLegacyPrefixImpl>
    implements _$$AddressParseError_InvalidLegacyPrefixImplCopyWith<$Res> {
  __$$AddressParseError_InvalidLegacyPrefixImplCopyWithImpl(
      _$AddressParseError_InvalidLegacyPrefixImpl _value,
      $Res Function(_$AddressParseError_InvalidLegacyPrefixImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_InvalidLegacyPrefixImpl
    extends AddressParseError_InvalidLegacyPrefix {
  const _$AddressParseError_InvalidLegacyPrefixImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.invalidLegacyPrefix()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_InvalidLegacyPrefixImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return invalidLegacyPrefix();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return invalidLegacyPrefix?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (invalidLegacyPrefix != null) {
      return invalidLegacyPrefix();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return invalidLegacyPrefix(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return invalidLegacyPrefix?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (invalidLegacyPrefix != null) {
      return invalidLegacyPrefix(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_InvalidLegacyPrefix extends AddressParseError {
  const factory AddressParseError_InvalidLegacyPrefix() =
      _$AddressParseError_InvalidLegacyPrefixImpl;
  const AddressParseError_InvalidLegacyPrefix._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_NetworkValidationImplCopyWith<$Res> {
  factory _$$AddressParseError_NetworkValidationImplCopyWith(
          _$AddressParseError_NetworkValidationImpl value,
          $Res Function(_$AddressParseError_NetworkValidationImpl) then) =
      __$$AddressParseError_NetworkValidationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_NetworkValidationImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_NetworkValidationImpl>
    implements _$$AddressParseError_NetworkValidationImplCopyWith<$Res> {
  __$$AddressParseError_NetworkValidationImplCopyWithImpl(
      _$AddressParseError_NetworkValidationImpl _value,
      $Res Function(_$AddressParseError_NetworkValidationImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_NetworkValidationImpl
    extends AddressParseError_NetworkValidation {
  const _$AddressParseError_NetworkValidationImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.networkValidation()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_NetworkValidationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return networkValidation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return networkValidation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (networkValidation != null) {
      return networkValidation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return networkValidation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return networkValidation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (networkValidation != null) {
      return networkValidation(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_NetworkValidation extends AddressParseError {
  const factory AddressParseError_NetworkValidation() =
      _$AddressParseError_NetworkValidationImpl;
  const AddressParseError_NetworkValidation._() : super._();
}

/// @nodoc
abstract class _$$AddressParseError_OtherAddressParseErrImplCopyWith<$Res> {
  factory _$$AddressParseError_OtherAddressParseErrImplCopyWith(
          _$AddressParseError_OtherAddressParseErrImpl value,
          $Res Function(_$AddressParseError_OtherAddressParseErrImpl) then) =
      __$$AddressParseError_OtherAddressParseErrImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressParseError_OtherAddressParseErrImplCopyWithImpl<$Res>
    extends _$AddressParseErrorCopyWithImpl<$Res,
        _$AddressParseError_OtherAddressParseErrImpl>
    implements _$$AddressParseError_OtherAddressParseErrImplCopyWith<$Res> {
  __$$AddressParseError_OtherAddressParseErrImplCopyWithImpl(
      _$AddressParseError_OtherAddressParseErrImpl _value,
      $Res Function(_$AddressParseError_OtherAddressParseErrImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressParseError_OtherAddressParseErrImpl
    extends AddressParseError_OtherAddressParseErr {
  const _$AddressParseError_OtherAddressParseErrImpl() : super._();

  @override
  String toString() {
    return 'AddressParseError.otherAddressParseErr()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressParseError_OtherAddressParseErrImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() base58,
    required TResult Function() bech32,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function() unknownHrp,
    required TResult Function() legacyAddressTooLong,
    required TResult Function() invalidBase58PayloadLength,
    required TResult Function() invalidLegacyPrefix,
    required TResult Function() networkValidation,
    required TResult Function() otherAddressParseErr,
  }) {
    return otherAddressParseErr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? base58,
    TResult? Function()? bech32,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function()? unknownHrp,
    TResult? Function()? legacyAddressTooLong,
    TResult? Function()? invalidBase58PayloadLength,
    TResult? Function()? invalidLegacyPrefix,
    TResult? Function()? networkValidation,
    TResult? Function()? otherAddressParseErr,
  }) {
    return otherAddressParseErr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? base58,
    TResult Function()? bech32,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function()? unknownHrp,
    TResult Function()? legacyAddressTooLong,
    TResult Function()? invalidBase58PayloadLength,
    TResult Function()? invalidLegacyPrefix,
    TResult Function()? networkValidation,
    TResult Function()? otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (otherAddressParseErr != null) {
      return otherAddressParseErr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressParseError_Base58 value) base58,
    required TResult Function(AddressParseError_Bech32 value) bech32,
    required TResult Function(AddressParseError_WitnessVersion value)
        witnessVersion,
    required TResult Function(AddressParseError_WitnessProgram value)
        witnessProgram,
    required TResult Function(AddressParseError_UnknownHrp value) unknownHrp,
    required TResult Function(AddressParseError_LegacyAddressTooLong value)
        legacyAddressTooLong,
    required TResult Function(
            AddressParseError_InvalidBase58PayloadLength value)
        invalidBase58PayloadLength,
    required TResult Function(AddressParseError_InvalidLegacyPrefix value)
        invalidLegacyPrefix,
    required TResult Function(AddressParseError_NetworkValidation value)
        networkValidation,
    required TResult Function(AddressParseError_OtherAddressParseErr value)
        otherAddressParseErr,
  }) {
    return otherAddressParseErr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressParseError_Base58 value)? base58,
    TResult? Function(AddressParseError_Bech32 value)? bech32,
    TResult? Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult? Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult? Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult? Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult? Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult? Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult? Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult? Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
  }) {
    return otherAddressParseErr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressParseError_Base58 value)? base58,
    TResult Function(AddressParseError_Bech32 value)? bech32,
    TResult Function(AddressParseError_WitnessVersion value)? witnessVersion,
    TResult Function(AddressParseError_WitnessProgram value)? witnessProgram,
    TResult Function(AddressParseError_UnknownHrp value)? unknownHrp,
    TResult Function(AddressParseError_LegacyAddressTooLong value)?
        legacyAddressTooLong,
    TResult Function(AddressParseError_InvalidBase58PayloadLength value)?
        invalidBase58PayloadLength,
    TResult Function(AddressParseError_InvalidLegacyPrefix value)?
        invalidLegacyPrefix,
    TResult Function(AddressParseError_NetworkValidation value)?
        networkValidation,
    TResult Function(AddressParseError_OtherAddressParseErr value)?
        otherAddressParseErr,
    required TResult orElse(),
  }) {
    if (otherAddressParseErr != null) {
      return otherAddressParseErr(this);
    }
    return orElse();
  }
}

abstract class AddressParseError_OtherAddressParseErr
    extends AddressParseError {
  const factory AddressParseError_OtherAddressParseErr() =
      _$AddressParseError_OtherAddressParseErrImpl;
  const AddressParseError_OtherAddressParseErr._() : super._();
}

/// @nodoc
mixin _$Bip32Error {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Bip32ErrorCopyWith<$Res> {
  factory $Bip32ErrorCopyWith(
          Bip32Error value, $Res Function(Bip32Error) then) =
      _$Bip32ErrorCopyWithImpl<$Res, Bip32Error>;
}

/// @nodoc
class _$Bip32ErrorCopyWithImpl<$Res, $Val extends Bip32Error>
    implements $Bip32ErrorCopyWith<$Res> {
  _$Bip32ErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWith<$Res> {
  factory _$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWith(
          _$Bip32Error_CannotDeriveFromHardenedKeyImpl value,
          $Res Function(_$Bip32Error_CannotDeriveFromHardenedKeyImpl) then) =
      __$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res,
        _$Bip32Error_CannotDeriveFromHardenedKeyImpl>
    implements _$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWith<$Res> {
  __$$Bip32Error_CannotDeriveFromHardenedKeyImplCopyWithImpl(
      _$Bip32Error_CannotDeriveFromHardenedKeyImpl _value,
      $Res Function(_$Bip32Error_CannotDeriveFromHardenedKeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Bip32Error_CannotDeriveFromHardenedKeyImpl
    extends Bip32Error_CannotDeriveFromHardenedKey {
  const _$Bip32Error_CannotDeriveFromHardenedKeyImpl() : super._();

  @override
  String toString() {
    return 'Bip32Error.cannotDeriveFromHardenedKey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_CannotDeriveFromHardenedKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return cannotDeriveFromHardenedKey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return cannotDeriveFromHardenedKey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (cannotDeriveFromHardenedKey != null) {
      return cannotDeriveFromHardenedKey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return cannotDeriveFromHardenedKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return cannotDeriveFromHardenedKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (cannotDeriveFromHardenedKey != null) {
      return cannotDeriveFromHardenedKey(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_CannotDeriveFromHardenedKey extends Bip32Error {
  const factory Bip32Error_CannotDeriveFromHardenedKey() =
      _$Bip32Error_CannotDeriveFromHardenedKeyImpl;
  const Bip32Error_CannotDeriveFromHardenedKey._() : super._();
}

/// @nodoc
abstract class _$$Bip32Error_Secp256k1ImplCopyWith<$Res> {
  factory _$$Bip32Error_Secp256k1ImplCopyWith(_$Bip32Error_Secp256k1Impl value,
          $Res Function(_$Bip32Error_Secp256k1Impl) then) =
      __$$Bip32Error_Secp256k1ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$Bip32Error_Secp256k1ImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_Secp256k1Impl>
    implements _$$Bip32Error_Secp256k1ImplCopyWith<$Res> {
  __$$Bip32Error_Secp256k1ImplCopyWithImpl(_$Bip32Error_Secp256k1Impl _value,
      $Res Function(_$Bip32Error_Secp256k1Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$Bip32Error_Secp256k1Impl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip32Error_Secp256k1Impl extends Bip32Error_Secp256k1 {
  const _$Bip32Error_Secp256k1Impl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'Bip32Error.secp256K1(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_Secp256k1Impl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_Secp256k1ImplCopyWith<_$Bip32Error_Secp256k1Impl>
      get copyWith =>
          __$$Bip32Error_Secp256k1ImplCopyWithImpl<_$Bip32Error_Secp256k1Impl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return secp256K1(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return secp256K1?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (secp256K1 != null) {
      return secp256K1(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return secp256K1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return secp256K1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (secp256K1 != null) {
      return secp256K1(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_Secp256k1 extends Bip32Error {
  const factory Bip32Error_Secp256k1({required final String errorMessage}) =
      _$Bip32Error_Secp256k1Impl;
  const Bip32Error_Secp256k1._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$Bip32Error_Secp256k1ImplCopyWith<_$Bip32Error_Secp256k1Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_InvalidChildNumberImplCopyWith<$Res> {
  factory _$$Bip32Error_InvalidChildNumberImplCopyWith(
          _$Bip32Error_InvalidChildNumberImpl value,
          $Res Function(_$Bip32Error_InvalidChildNumberImpl) then) =
      __$$Bip32Error_InvalidChildNumberImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int childNumber});
}

/// @nodoc
class __$$Bip32Error_InvalidChildNumberImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_InvalidChildNumberImpl>
    implements _$$Bip32Error_InvalidChildNumberImplCopyWith<$Res> {
  __$$Bip32Error_InvalidChildNumberImplCopyWithImpl(
      _$Bip32Error_InvalidChildNumberImpl _value,
      $Res Function(_$Bip32Error_InvalidChildNumberImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? childNumber = null,
  }) {
    return _then(_$Bip32Error_InvalidChildNumberImpl(
      childNumber: null == childNumber
          ? _value.childNumber
          : childNumber // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Bip32Error_InvalidChildNumberImpl
    extends Bip32Error_InvalidChildNumber {
  const _$Bip32Error_InvalidChildNumberImpl({required this.childNumber})
      : super._();

  @override
  final int childNumber;

  @override
  String toString() {
    return 'Bip32Error.invalidChildNumber(childNumber: $childNumber)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_InvalidChildNumberImpl &&
            (identical(other.childNumber, childNumber) ||
                other.childNumber == childNumber));
  }

  @override
  int get hashCode => Object.hash(runtimeType, childNumber);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_InvalidChildNumberImplCopyWith<
          _$Bip32Error_InvalidChildNumberImpl>
      get copyWith => __$$Bip32Error_InvalidChildNumberImplCopyWithImpl<
          _$Bip32Error_InvalidChildNumberImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return invalidChildNumber(childNumber);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return invalidChildNumber?.call(childNumber);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidChildNumber != null) {
      return invalidChildNumber(childNumber);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return invalidChildNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return invalidChildNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidChildNumber != null) {
      return invalidChildNumber(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_InvalidChildNumber extends Bip32Error {
  const factory Bip32Error_InvalidChildNumber(
      {required final int childNumber}) = _$Bip32Error_InvalidChildNumberImpl;
  const Bip32Error_InvalidChildNumber._() : super._();

  int get childNumber;
  @JsonKey(ignore: true)
  _$$Bip32Error_InvalidChildNumberImplCopyWith<
          _$Bip32Error_InvalidChildNumberImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_InvalidChildNumberFormatImplCopyWith<$Res> {
  factory _$$Bip32Error_InvalidChildNumberFormatImplCopyWith(
          _$Bip32Error_InvalidChildNumberFormatImpl value,
          $Res Function(_$Bip32Error_InvalidChildNumberFormatImpl) then) =
      __$$Bip32Error_InvalidChildNumberFormatImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Bip32Error_InvalidChildNumberFormatImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res,
        _$Bip32Error_InvalidChildNumberFormatImpl>
    implements _$$Bip32Error_InvalidChildNumberFormatImplCopyWith<$Res> {
  __$$Bip32Error_InvalidChildNumberFormatImplCopyWithImpl(
      _$Bip32Error_InvalidChildNumberFormatImpl _value,
      $Res Function(_$Bip32Error_InvalidChildNumberFormatImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Bip32Error_InvalidChildNumberFormatImpl
    extends Bip32Error_InvalidChildNumberFormat {
  const _$Bip32Error_InvalidChildNumberFormatImpl() : super._();

  @override
  String toString() {
    return 'Bip32Error.invalidChildNumberFormat()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_InvalidChildNumberFormatImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return invalidChildNumberFormat();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return invalidChildNumberFormat?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidChildNumberFormat != null) {
      return invalidChildNumberFormat();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return invalidChildNumberFormat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return invalidChildNumberFormat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidChildNumberFormat != null) {
      return invalidChildNumberFormat(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_InvalidChildNumberFormat extends Bip32Error {
  const factory Bip32Error_InvalidChildNumberFormat() =
      _$Bip32Error_InvalidChildNumberFormatImpl;
  const Bip32Error_InvalidChildNumberFormat._() : super._();
}

/// @nodoc
abstract class _$$Bip32Error_InvalidDerivationPathFormatImplCopyWith<$Res> {
  factory _$$Bip32Error_InvalidDerivationPathFormatImplCopyWith(
          _$Bip32Error_InvalidDerivationPathFormatImpl value,
          $Res Function(_$Bip32Error_InvalidDerivationPathFormatImpl) then) =
      __$$Bip32Error_InvalidDerivationPathFormatImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Bip32Error_InvalidDerivationPathFormatImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res,
        _$Bip32Error_InvalidDerivationPathFormatImpl>
    implements _$$Bip32Error_InvalidDerivationPathFormatImplCopyWith<$Res> {
  __$$Bip32Error_InvalidDerivationPathFormatImplCopyWithImpl(
      _$Bip32Error_InvalidDerivationPathFormatImpl _value,
      $Res Function(_$Bip32Error_InvalidDerivationPathFormatImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Bip32Error_InvalidDerivationPathFormatImpl
    extends Bip32Error_InvalidDerivationPathFormat {
  const _$Bip32Error_InvalidDerivationPathFormatImpl() : super._();

  @override
  String toString() {
    return 'Bip32Error.invalidDerivationPathFormat()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_InvalidDerivationPathFormatImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return invalidDerivationPathFormat();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return invalidDerivationPathFormat?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidDerivationPathFormat != null) {
      return invalidDerivationPathFormat();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return invalidDerivationPathFormat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return invalidDerivationPathFormat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidDerivationPathFormat != null) {
      return invalidDerivationPathFormat(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_InvalidDerivationPathFormat extends Bip32Error {
  const factory Bip32Error_InvalidDerivationPathFormat() =
      _$Bip32Error_InvalidDerivationPathFormatImpl;
  const Bip32Error_InvalidDerivationPathFormat._() : super._();
}

/// @nodoc
abstract class _$$Bip32Error_UnknownVersionImplCopyWith<$Res> {
  factory _$$Bip32Error_UnknownVersionImplCopyWith(
          _$Bip32Error_UnknownVersionImpl value,
          $Res Function(_$Bip32Error_UnknownVersionImpl) then) =
      __$$Bip32Error_UnknownVersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String version});
}

/// @nodoc
class __$$Bip32Error_UnknownVersionImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_UnknownVersionImpl>
    implements _$$Bip32Error_UnknownVersionImplCopyWith<$Res> {
  __$$Bip32Error_UnknownVersionImplCopyWithImpl(
      _$Bip32Error_UnknownVersionImpl _value,
      $Res Function(_$Bip32Error_UnknownVersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
  }) {
    return _then(_$Bip32Error_UnknownVersionImpl(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip32Error_UnknownVersionImpl extends Bip32Error_UnknownVersion {
  const _$Bip32Error_UnknownVersionImpl({required this.version}) : super._();

  @override
  final String version;

  @override
  String toString() {
    return 'Bip32Error.unknownVersion(version: $version)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_UnknownVersionImpl &&
            (identical(other.version, version) || other.version == version));
  }

  @override
  int get hashCode => Object.hash(runtimeType, version);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_UnknownVersionImplCopyWith<_$Bip32Error_UnknownVersionImpl>
      get copyWith => __$$Bip32Error_UnknownVersionImplCopyWithImpl<
          _$Bip32Error_UnknownVersionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return unknownVersion(version);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return unknownVersion?.call(version);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownVersion != null) {
      return unknownVersion(version);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return unknownVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return unknownVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownVersion != null) {
      return unknownVersion(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_UnknownVersion extends Bip32Error {
  const factory Bip32Error_UnknownVersion({required final String version}) =
      _$Bip32Error_UnknownVersionImpl;
  const Bip32Error_UnknownVersion._() : super._();

  String get version;
  @JsonKey(ignore: true)
  _$$Bip32Error_UnknownVersionImplCopyWith<_$Bip32Error_UnknownVersionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_WrongExtendedKeyLengthImplCopyWith<$Res> {
  factory _$$Bip32Error_WrongExtendedKeyLengthImplCopyWith(
          _$Bip32Error_WrongExtendedKeyLengthImpl value,
          $Res Function(_$Bip32Error_WrongExtendedKeyLengthImpl) then) =
      __$$Bip32Error_WrongExtendedKeyLengthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int length});
}

/// @nodoc
class __$$Bip32Error_WrongExtendedKeyLengthImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res,
        _$Bip32Error_WrongExtendedKeyLengthImpl>
    implements _$$Bip32Error_WrongExtendedKeyLengthImplCopyWith<$Res> {
  __$$Bip32Error_WrongExtendedKeyLengthImplCopyWithImpl(
      _$Bip32Error_WrongExtendedKeyLengthImpl _value,
      $Res Function(_$Bip32Error_WrongExtendedKeyLengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
  }) {
    return _then(_$Bip32Error_WrongExtendedKeyLengthImpl(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Bip32Error_WrongExtendedKeyLengthImpl
    extends Bip32Error_WrongExtendedKeyLength {
  const _$Bip32Error_WrongExtendedKeyLengthImpl({required this.length})
      : super._();

  @override
  final int length;

  @override
  String toString() {
    return 'Bip32Error.wrongExtendedKeyLength(length: $length)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_WrongExtendedKeyLengthImpl &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_WrongExtendedKeyLengthImplCopyWith<
          _$Bip32Error_WrongExtendedKeyLengthImpl>
      get copyWith => __$$Bip32Error_WrongExtendedKeyLengthImplCopyWithImpl<
          _$Bip32Error_WrongExtendedKeyLengthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return wrongExtendedKeyLength(length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return wrongExtendedKeyLength?.call(length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (wrongExtendedKeyLength != null) {
      return wrongExtendedKeyLength(length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return wrongExtendedKeyLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return wrongExtendedKeyLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (wrongExtendedKeyLength != null) {
      return wrongExtendedKeyLength(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_WrongExtendedKeyLength extends Bip32Error {
  const factory Bip32Error_WrongExtendedKeyLength({required final int length}) =
      _$Bip32Error_WrongExtendedKeyLengthImpl;
  const Bip32Error_WrongExtendedKeyLength._() : super._();

  int get length;
  @JsonKey(ignore: true)
  _$$Bip32Error_WrongExtendedKeyLengthImplCopyWith<
          _$Bip32Error_WrongExtendedKeyLengthImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_Base58ImplCopyWith<$Res> {
  factory _$$Bip32Error_Base58ImplCopyWith(_$Bip32Error_Base58Impl value,
          $Res Function(_$Bip32Error_Base58Impl) then) =
      __$$Bip32Error_Base58ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$Bip32Error_Base58ImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_Base58Impl>
    implements _$$Bip32Error_Base58ImplCopyWith<$Res> {
  __$$Bip32Error_Base58ImplCopyWithImpl(_$Bip32Error_Base58Impl _value,
      $Res Function(_$Bip32Error_Base58Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$Bip32Error_Base58Impl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip32Error_Base58Impl extends Bip32Error_Base58 {
  const _$Bip32Error_Base58Impl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'Bip32Error.base58(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_Base58Impl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_Base58ImplCopyWith<_$Bip32Error_Base58Impl> get copyWith =>
      __$$Bip32Error_Base58ImplCopyWithImpl<_$Bip32Error_Base58Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return base58(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return base58?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return base58(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return base58?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_Base58 extends Bip32Error {
  const factory Bip32Error_Base58({required final String errorMessage}) =
      _$Bip32Error_Base58Impl;
  const Bip32Error_Base58._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$Bip32Error_Base58ImplCopyWith<_$Bip32Error_Base58Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_HexImplCopyWith<$Res> {
  factory _$$Bip32Error_HexImplCopyWith(_$Bip32Error_HexImpl value,
          $Res Function(_$Bip32Error_HexImpl) then) =
      __$$Bip32Error_HexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$Bip32Error_HexImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_HexImpl>
    implements _$$Bip32Error_HexImplCopyWith<$Res> {
  __$$Bip32Error_HexImplCopyWithImpl(
      _$Bip32Error_HexImpl _value, $Res Function(_$Bip32Error_HexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$Bip32Error_HexImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip32Error_HexImpl extends Bip32Error_Hex {
  const _$Bip32Error_HexImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'Bip32Error.hex(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_HexImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_HexImplCopyWith<_$Bip32Error_HexImpl> get copyWith =>
      __$$Bip32Error_HexImplCopyWithImpl<_$Bip32Error_HexImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return hex(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return hex?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return hex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return hex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_Hex extends Bip32Error {
  const factory Bip32Error_Hex({required final String errorMessage}) =
      _$Bip32Error_HexImpl;
  const Bip32Error_Hex._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$Bip32Error_HexImplCopyWith<_$Bip32Error_HexImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWith<$Res> {
  factory _$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWith(
          _$Bip32Error_InvalidPublicKeyHexLengthImpl value,
          $Res Function(_$Bip32Error_InvalidPublicKeyHexLengthImpl) then) =
      __$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int length});
}

/// @nodoc
class __$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res,
        _$Bip32Error_InvalidPublicKeyHexLengthImpl>
    implements _$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWith<$Res> {
  __$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWithImpl(
      _$Bip32Error_InvalidPublicKeyHexLengthImpl _value,
      $Res Function(_$Bip32Error_InvalidPublicKeyHexLengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
  }) {
    return _then(_$Bip32Error_InvalidPublicKeyHexLengthImpl(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Bip32Error_InvalidPublicKeyHexLengthImpl
    extends Bip32Error_InvalidPublicKeyHexLength {
  const _$Bip32Error_InvalidPublicKeyHexLengthImpl({required this.length})
      : super._();

  @override
  final int length;

  @override
  String toString() {
    return 'Bip32Error.invalidPublicKeyHexLength(length: $length)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_InvalidPublicKeyHexLengthImpl &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWith<
          _$Bip32Error_InvalidPublicKeyHexLengthImpl>
      get copyWith => __$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWithImpl<
          _$Bip32Error_InvalidPublicKeyHexLengthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return invalidPublicKeyHexLength(length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return invalidPublicKeyHexLength?.call(length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidPublicKeyHexLength != null) {
      return invalidPublicKeyHexLength(length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return invalidPublicKeyHexLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return invalidPublicKeyHexLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (invalidPublicKeyHexLength != null) {
      return invalidPublicKeyHexLength(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_InvalidPublicKeyHexLength extends Bip32Error {
  const factory Bip32Error_InvalidPublicKeyHexLength(
      {required final int length}) = _$Bip32Error_InvalidPublicKeyHexLengthImpl;
  const Bip32Error_InvalidPublicKeyHexLength._() : super._();

  int get length;
  @JsonKey(ignore: true)
  _$$Bip32Error_InvalidPublicKeyHexLengthImplCopyWith<
          _$Bip32Error_InvalidPublicKeyHexLengthImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip32Error_UnknownErrorImplCopyWith<$Res> {
  factory _$$Bip32Error_UnknownErrorImplCopyWith(
          _$Bip32Error_UnknownErrorImpl value,
          $Res Function(_$Bip32Error_UnknownErrorImpl) then) =
      __$$Bip32Error_UnknownErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$Bip32Error_UnknownErrorImplCopyWithImpl<$Res>
    extends _$Bip32ErrorCopyWithImpl<$Res, _$Bip32Error_UnknownErrorImpl>
    implements _$$Bip32Error_UnknownErrorImplCopyWith<$Res> {
  __$$Bip32Error_UnknownErrorImplCopyWithImpl(
      _$Bip32Error_UnknownErrorImpl _value,
      $Res Function(_$Bip32Error_UnknownErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$Bip32Error_UnknownErrorImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip32Error_UnknownErrorImpl extends Bip32Error_UnknownError {
  const _$Bip32Error_UnknownErrorImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'Bip32Error.unknownError(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip32Error_UnknownErrorImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip32Error_UnknownErrorImplCopyWith<_$Bip32Error_UnknownErrorImpl>
      get copyWith => __$$Bip32Error_UnknownErrorImplCopyWithImpl<
          _$Bip32Error_UnknownErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cannotDeriveFromHardenedKey,
    required TResult Function(String errorMessage) secp256K1,
    required TResult Function(int childNumber) invalidChildNumber,
    required TResult Function() invalidChildNumberFormat,
    required TResult Function() invalidDerivationPathFormat,
    required TResult Function(String version) unknownVersion,
    required TResult Function(int length) wrongExtendedKeyLength,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) hex,
    required TResult Function(int length) invalidPublicKeyHexLength,
    required TResult Function(String errorMessage) unknownError,
  }) {
    return unknownError(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cannotDeriveFromHardenedKey,
    TResult? Function(String errorMessage)? secp256K1,
    TResult? Function(int childNumber)? invalidChildNumber,
    TResult? Function()? invalidChildNumberFormat,
    TResult? Function()? invalidDerivationPathFormat,
    TResult? Function(String version)? unknownVersion,
    TResult? Function(int length)? wrongExtendedKeyLength,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(int length)? invalidPublicKeyHexLength,
    TResult? Function(String errorMessage)? unknownError,
  }) {
    return unknownError?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cannotDeriveFromHardenedKey,
    TResult Function(String errorMessage)? secp256K1,
    TResult Function(int childNumber)? invalidChildNumber,
    TResult Function()? invalidChildNumberFormat,
    TResult Function()? invalidDerivationPathFormat,
    TResult Function(String version)? unknownVersion,
    TResult Function(int length)? wrongExtendedKeyLength,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? hex,
    TResult Function(int length)? invalidPublicKeyHexLength,
    TResult Function(String errorMessage)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)
        cannotDeriveFromHardenedKey,
    required TResult Function(Bip32Error_Secp256k1 value) secp256K1,
    required TResult Function(Bip32Error_InvalidChildNumber value)
        invalidChildNumber,
    required TResult Function(Bip32Error_InvalidChildNumberFormat value)
        invalidChildNumberFormat,
    required TResult Function(Bip32Error_InvalidDerivationPathFormat value)
        invalidDerivationPathFormat,
    required TResult Function(Bip32Error_UnknownVersion value) unknownVersion,
    required TResult Function(Bip32Error_WrongExtendedKeyLength value)
        wrongExtendedKeyLength,
    required TResult Function(Bip32Error_Base58 value) base58,
    required TResult Function(Bip32Error_Hex value) hex,
    required TResult Function(Bip32Error_InvalidPublicKeyHexLength value)
        invalidPublicKeyHexLength,
    required TResult Function(Bip32Error_UnknownError value) unknownError,
  }) {
    return unknownError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult? Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult? Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult? Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult? Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult? Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult? Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult? Function(Bip32Error_Base58 value)? base58,
    TResult? Function(Bip32Error_Hex value)? hex,
    TResult? Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult? Function(Bip32Error_UnknownError value)? unknownError,
  }) {
    return unknownError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip32Error_CannotDeriveFromHardenedKey value)?
        cannotDeriveFromHardenedKey,
    TResult Function(Bip32Error_Secp256k1 value)? secp256K1,
    TResult Function(Bip32Error_InvalidChildNumber value)? invalidChildNumber,
    TResult Function(Bip32Error_InvalidChildNumberFormat value)?
        invalidChildNumberFormat,
    TResult Function(Bip32Error_InvalidDerivationPathFormat value)?
        invalidDerivationPathFormat,
    TResult Function(Bip32Error_UnknownVersion value)? unknownVersion,
    TResult Function(Bip32Error_WrongExtendedKeyLength value)?
        wrongExtendedKeyLength,
    TResult Function(Bip32Error_Base58 value)? base58,
    TResult Function(Bip32Error_Hex value)? hex,
    TResult Function(Bip32Error_InvalidPublicKeyHexLength value)?
        invalidPublicKeyHexLength,
    TResult Function(Bip32Error_UnknownError value)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(this);
    }
    return orElse();
  }
}

abstract class Bip32Error_UnknownError extends Bip32Error {
  const factory Bip32Error_UnknownError({required final String errorMessage}) =
      _$Bip32Error_UnknownErrorImpl;
  const Bip32Error_UnknownError._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$Bip32Error_UnknownErrorImplCopyWith<_$Bip32Error_UnknownErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Bip39Error {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Bip39ErrorCopyWith<$Res> {
  factory $Bip39ErrorCopyWith(
          Bip39Error value, $Res Function(Bip39Error) then) =
      _$Bip39ErrorCopyWithImpl<$Res, Bip39Error>;
}

/// @nodoc
class _$Bip39ErrorCopyWithImpl<$Res, $Val extends Bip39Error>
    implements $Bip39ErrorCopyWith<$Res> {
  _$Bip39ErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Bip39Error_BadWordCountImplCopyWith<$Res> {
  factory _$$Bip39Error_BadWordCountImplCopyWith(
          _$Bip39Error_BadWordCountImpl value,
          $Res Function(_$Bip39Error_BadWordCountImpl) then) =
      __$$Bip39Error_BadWordCountImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt wordCount});
}

/// @nodoc
class __$$Bip39Error_BadWordCountImplCopyWithImpl<$Res>
    extends _$Bip39ErrorCopyWithImpl<$Res, _$Bip39Error_BadWordCountImpl>
    implements _$$Bip39Error_BadWordCountImplCopyWith<$Res> {
  __$$Bip39Error_BadWordCountImplCopyWithImpl(
      _$Bip39Error_BadWordCountImpl _value,
      $Res Function(_$Bip39Error_BadWordCountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wordCount = null,
  }) {
    return _then(_$Bip39Error_BadWordCountImpl(
      wordCount: null == wordCount
          ? _value.wordCount
          : wordCount // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Bip39Error_BadWordCountImpl extends Bip39Error_BadWordCount {
  const _$Bip39Error_BadWordCountImpl({required this.wordCount}) : super._();

  @override
  final BigInt wordCount;

  @override
  String toString() {
    return 'Bip39Error.badWordCount(wordCount: $wordCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip39Error_BadWordCountImpl &&
            (identical(other.wordCount, wordCount) ||
                other.wordCount == wordCount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, wordCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip39Error_BadWordCountImplCopyWith<_$Bip39Error_BadWordCountImpl>
      get copyWith => __$$Bip39Error_BadWordCountImplCopyWithImpl<
          _$Bip39Error_BadWordCountImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) {
    return badWordCount(wordCount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) {
    return badWordCount?.call(wordCount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (badWordCount != null) {
      return badWordCount(wordCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) {
    return badWordCount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) {
    return badWordCount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (badWordCount != null) {
      return badWordCount(this);
    }
    return orElse();
  }
}

abstract class Bip39Error_BadWordCount extends Bip39Error {
  const factory Bip39Error_BadWordCount({required final BigInt wordCount}) =
      _$Bip39Error_BadWordCountImpl;
  const Bip39Error_BadWordCount._() : super._();

  BigInt get wordCount;
  @JsonKey(ignore: true)
  _$$Bip39Error_BadWordCountImplCopyWith<_$Bip39Error_BadWordCountImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip39Error_UnknownWordImplCopyWith<$Res> {
  factory _$$Bip39Error_UnknownWordImplCopyWith(
          _$Bip39Error_UnknownWordImpl value,
          $Res Function(_$Bip39Error_UnknownWordImpl) then) =
      __$$Bip39Error_UnknownWordImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt index});
}

/// @nodoc
class __$$Bip39Error_UnknownWordImplCopyWithImpl<$Res>
    extends _$Bip39ErrorCopyWithImpl<$Res, _$Bip39Error_UnknownWordImpl>
    implements _$$Bip39Error_UnknownWordImplCopyWith<$Res> {
  __$$Bip39Error_UnknownWordImplCopyWithImpl(
      _$Bip39Error_UnknownWordImpl _value,
      $Res Function(_$Bip39Error_UnknownWordImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$Bip39Error_UnknownWordImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Bip39Error_UnknownWordImpl extends Bip39Error_UnknownWord {
  const _$Bip39Error_UnknownWordImpl({required this.index}) : super._();

  @override
  final BigInt index;

  @override
  String toString() {
    return 'Bip39Error.unknownWord(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip39Error_UnknownWordImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip39Error_UnknownWordImplCopyWith<_$Bip39Error_UnknownWordImpl>
      get copyWith => __$$Bip39Error_UnknownWordImplCopyWithImpl<
          _$Bip39Error_UnknownWordImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) {
    return unknownWord(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) {
    return unknownWord?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (unknownWord != null) {
      return unknownWord(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) {
    return unknownWord(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) {
    return unknownWord?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (unknownWord != null) {
      return unknownWord(this);
    }
    return orElse();
  }
}

abstract class Bip39Error_UnknownWord extends Bip39Error {
  const factory Bip39Error_UnknownWord({required final BigInt index}) =
      _$Bip39Error_UnknownWordImpl;
  const Bip39Error_UnknownWord._() : super._();

  BigInt get index;
  @JsonKey(ignore: true)
  _$$Bip39Error_UnknownWordImplCopyWith<_$Bip39Error_UnknownWordImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip39Error_BadEntropyBitCountImplCopyWith<$Res> {
  factory _$$Bip39Error_BadEntropyBitCountImplCopyWith(
          _$Bip39Error_BadEntropyBitCountImpl value,
          $Res Function(_$Bip39Error_BadEntropyBitCountImpl) then) =
      __$$Bip39Error_BadEntropyBitCountImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt bitCount});
}

/// @nodoc
class __$$Bip39Error_BadEntropyBitCountImplCopyWithImpl<$Res>
    extends _$Bip39ErrorCopyWithImpl<$Res, _$Bip39Error_BadEntropyBitCountImpl>
    implements _$$Bip39Error_BadEntropyBitCountImplCopyWith<$Res> {
  __$$Bip39Error_BadEntropyBitCountImplCopyWithImpl(
      _$Bip39Error_BadEntropyBitCountImpl _value,
      $Res Function(_$Bip39Error_BadEntropyBitCountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bitCount = null,
  }) {
    return _then(_$Bip39Error_BadEntropyBitCountImpl(
      bitCount: null == bitCount
          ? _value.bitCount
          : bitCount // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Bip39Error_BadEntropyBitCountImpl
    extends Bip39Error_BadEntropyBitCount {
  const _$Bip39Error_BadEntropyBitCountImpl({required this.bitCount})
      : super._();

  @override
  final BigInt bitCount;

  @override
  String toString() {
    return 'Bip39Error.badEntropyBitCount(bitCount: $bitCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip39Error_BadEntropyBitCountImpl &&
            (identical(other.bitCount, bitCount) ||
                other.bitCount == bitCount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bitCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip39Error_BadEntropyBitCountImplCopyWith<
          _$Bip39Error_BadEntropyBitCountImpl>
      get copyWith => __$$Bip39Error_BadEntropyBitCountImplCopyWithImpl<
          _$Bip39Error_BadEntropyBitCountImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) {
    return badEntropyBitCount(bitCount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) {
    return badEntropyBitCount?.call(bitCount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (badEntropyBitCount != null) {
      return badEntropyBitCount(bitCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) {
    return badEntropyBitCount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) {
    return badEntropyBitCount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (badEntropyBitCount != null) {
      return badEntropyBitCount(this);
    }
    return orElse();
  }
}

abstract class Bip39Error_BadEntropyBitCount extends Bip39Error {
  const factory Bip39Error_BadEntropyBitCount(
      {required final BigInt bitCount}) = _$Bip39Error_BadEntropyBitCountImpl;
  const Bip39Error_BadEntropyBitCount._() : super._();

  BigInt get bitCount;
  @JsonKey(ignore: true)
  _$$Bip39Error_BadEntropyBitCountImplCopyWith<
          _$Bip39Error_BadEntropyBitCountImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Bip39Error_InvalidChecksumImplCopyWith<$Res> {
  factory _$$Bip39Error_InvalidChecksumImplCopyWith(
          _$Bip39Error_InvalidChecksumImpl value,
          $Res Function(_$Bip39Error_InvalidChecksumImpl) then) =
      __$$Bip39Error_InvalidChecksumImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Bip39Error_InvalidChecksumImplCopyWithImpl<$Res>
    extends _$Bip39ErrorCopyWithImpl<$Res, _$Bip39Error_InvalidChecksumImpl>
    implements _$$Bip39Error_InvalidChecksumImplCopyWith<$Res> {
  __$$Bip39Error_InvalidChecksumImplCopyWithImpl(
      _$Bip39Error_InvalidChecksumImpl _value,
      $Res Function(_$Bip39Error_InvalidChecksumImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Bip39Error_InvalidChecksumImpl extends Bip39Error_InvalidChecksum {
  const _$Bip39Error_InvalidChecksumImpl() : super._();

  @override
  String toString() {
    return 'Bip39Error.invalidChecksum()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip39Error_InvalidChecksumImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) {
    return invalidChecksum();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) {
    return invalidChecksum?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) {
    return invalidChecksum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) {
    return invalidChecksum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum(this);
    }
    return orElse();
  }
}

abstract class Bip39Error_InvalidChecksum extends Bip39Error {
  const factory Bip39Error_InvalidChecksum() = _$Bip39Error_InvalidChecksumImpl;
  const Bip39Error_InvalidChecksum._() : super._();
}

/// @nodoc
abstract class _$$Bip39Error_AmbiguousLanguagesImplCopyWith<$Res> {
  factory _$$Bip39Error_AmbiguousLanguagesImplCopyWith(
          _$Bip39Error_AmbiguousLanguagesImpl value,
          $Res Function(_$Bip39Error_AmbiguousLanguagesImpl) then) =
      __$$Bip39Error_AmbiguousLanguagesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String languages});
}

/// @nodoc
class __$$Bip39Error_AmbiguousLanguagesImplCopyWithImpl<$Res>
    extends _$Bip39ErrorCopyWithImpl<$Res, _$Bip39Error_AmbiguousLanguagesImpl>
    implements _$$Bip39Error_AmbiguousLanguagesImplCopyWith<$Res> {
  __$$Bip39Error_AmbiguousLanguagesImplCopyWithImpl(
      _$Bip39Error_AmbiguousLanguagesImpl _value,
      $Res Function(_$Bip39Error_AmbiguousLanguagesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? languages = null,
  }) {
    return _then(_$Bip39Error_AmbiguousLanguagesImpl(
      languages: null == languages
          ? _value.languages
          : languages // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Bip39Error_AmbiguousLanguagesImpl
    extends Bip39Error_AmbiguousLanguages {
  const _$Bip39Error_AmbiguousLanguagesImpl({required this.languages})
      : super._();

  @override
  final String languages;

  @override
  String toString() {
    return 'Bip39Error.ambiguousLanguages(languages: $languages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Bip39Error_AmbiguousLanguagesImpl &&
            (identical(other.languages, languages) ||
                other.languages == languages));
  }

  @override
  int get hashCode => Object.hash(runtimeType, languages);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Bip39Error_AmbiguousLanguagesImplCopyWith<
          _$Bip39Error_AmbiguousLanguagesImpl>
      get copyWith => __$$Bip39Error_AmbiguousLanguagesImplCopyWithImpl<
          _$Bip39Error_AmbiguousLanguagesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt wordCount) badWordCount,
    required TResult Function(BigInt index) unknownWord,
    required TResult Function(BigInt bitCount) badEntropyBitCount,
    required TResult Function() invalidChecksum,
    required TResult Function(String languages) ambiguousLanguages,
  }) {
    return ambiguousLanguages(languages);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt wordCount)? badWordCount,
    TResult? Function(BigInt index)? unknownWord,
    TResult? Function(BigInt bitCount)? badEntropyBitCount,
    TResult? Function()? invalidChecksum,
    TResult? Function(String languages)? ambiguousLanguages,
  }) {
    return ambiguousLanguages?.call(languages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt wordCount)? badWordCount,
    TResult Function(BigInt index)? unknownWord,
    TResult Function(BigInt bitCount)? badEntropyBitCount,
    TResult Function()? invalidChecksum,
    TResult Function(String languages)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (ambiguousLanguages != null) {
      return ambiguousLanguages(languages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bip39Error_BadWordCount value) badWordCount,
    required TResult Function(Bip39Error_UnknownWord value) unknownWord,
    required TResult Function(Bip39Error_BadEntropyBitCount value)
        badEntropyBitCount,
    required TResult Function(Bip39Error_InvalidChecksum value) invalidChecksum,
    required TResult Function(Bip39Error_AmbiguousLanguages value)
        ambiguousLanguages,
  }) {
    return ambiguousLanguages(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult? Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult? Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult? Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult? Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
  }) {
    return ambiguousLanguages?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bip39Error_BadWordCount value)? badWordCount,
    TResult Function(Bip39Error_UnknownWord value)? unknownWord,
    TResult Function(Bip39Error_BadEntropyBitCount value)? badEntropyBitCount,
    TResult Function(Bip39Error_InvalidChecksum value)? invalidChecksum,
    TResult Function(Bip39Error_AmbiguousLanguages value)? ambiguousLanguages,
    required TResult orElse(),
  }) {
    if (ambiguousLanguages != null) {
      return ambiguousLanguages(this);
    }
    return orElse();
  }
}

abstract class Bip39Error_AmbiguousLanguages extends Bip39Error {
  const factory Bip39Error_AmbiguousLanguages(
      {required final String languages}) = _$Bip39Error_AmbiguousLanguagesImpl;
  const Bip39Error_AmbiguousLanguages._() : super._();

  String get languages;
  @JsonKey(ignore: true)
  _$$Bip39Error_AmbiguousLanguagesImplCopyWith<
          _$Bip39Error_AmbiguousLanguagesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CalculateFeeError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(List<OutPoint> outPoints) missingTxOut,
    required TResult Function(String amount) negativeFee,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(List<OutPoint> outPoints)? missingTxOut,
    TResult? Function(String amount)? negativeFee,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(List<OutPoint> outPoints)? missingTxOut,
    TResult Function(String amount)? negativeFee,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateFeeError_Generic value) generic,
    required TResult Function(CalculateFeeError_MissingTxOut value)
        missingTxOut,
    required TResult Function(CalculateFeeError_NegativeFee value) negativeFee,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateFeeError_Generic value)? generic,
    TResult? Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult? Function(CalculateFeeError_NegativeFee value)? negativeFee,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateFeeError_Generic value)? generic,
    TResult Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult Function(CalculateFeeError_NegativeFee value)? negativeFee,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculateFeeErrorCopyWith<$Res> {
  factory $CalculateFeeErrorCopyWith(
          CalculateFeeError value, $Res Function(CalculateFeeError) then) =
      _$CalculateFeeErrorCopyWithImpl<$Res, CalculateFeeError>;
}

/// @nodoc
class _$CalculateFeeErrorCopyWithImpl<$Res, $Val extends CalculateFeeError>
    implements $CalculateFeeErrorCopyWith<$Res> {
  _$CalculateFeeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CalculateFeeError_GenericImplCopyWith<$Res> {
  factory _$$CalculateFeeError_GenericImplCopyWith(
          _$CalculateFeeError_GenericImpl value,
          $Res Function(_$CalculateFeeError_GenericImpl) then) =
      __$$CalculateFeeError_GenericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CalculateFeeError_GenericImplCopyWithImpl<$Res>
    extends _$CalculateFeeErrorCopyWithImpl<$Res,
        _$CalculateFeeError_GenericImpl>
    implements _$$CalculateFeeError_GenericImplCopyWith<$Res> {
  __$$CalculateFeeError_GenericImplCopyWithImpl(
      _$CalculateFeeError_GenericImpl _value,
      $Res Function(_$CalculateFeeError_GenericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CalculateFeeError_GenericImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CalculateFeeError_GenericImpl extends CalculateFeeError_Generic {
  const _$CalculateFeeError_GenericImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CalculateFeeError.generic(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalculateFeeError_GenericImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalculateFeeError_GenericImplCopyWith<_$CalculateFeeError_GenericImpl>
      get copyWith => __$$CalculateFeeError_GenericImplCopyWithImpl<
          _$CalculateFeeError_GenericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(List<OutPoint> outPoints) missingTxOut,
    required TResult Function(String amount) negativeFee,
  }) {
    return generic(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(List<OutPoint> outPoints)? missingTxOut,
    TResult? Function(String amount)? negativeFee,
  }) {
    return generic?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(List<OutPoint> outPoints)? missingTxOut,
    TResult Function(String amount)? negativeFee,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateFeeError_Generic value) generic,
    required TResult Function(CalculateFeeError_MissingTxOut value)
        missingTxOut,
    required TResult Function(CalculateFeeError_NegativeFee value) negativeFee,
  }) {
    return generic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateFeeError_Generic value)? generic,
    TResult? Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult? Function(CalculateFeeError_NegativeFee value)? negativeFee,
  }) {
    return generic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateFeeError_Generic value)? generic,
    TResult Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult Function(CalculateFeeError_NegativeFee value)? negativeFee,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(this);
    }
    return orElse();
  }
}

abstract class CalculateFeeError_Generic extends CalculateFeeError {
  const factory CalculateFeeError_Generic(
      {required final String errorMessage}) = _$CalculateFeeError_GenericImpl;
  const CalculateFeeError_Generic._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CalculateFeeError_GenericImplCopyWith<_$CalculateFeeError_GenericImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalculateFeeError_MissingTxOutImplCopyWith<$Res> {
  factory _$$CalculateFeeError_MissingTxOutImplCopyWith(
          _$CalculateFeeError_MissingTxOutImpl value,
          $Res Function(_$CalculateFeeError_MissingTxOutImpl) then) =
      __$$CalculateFeeError_MissingTxOutImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<OutPoint> outPoints});
}

/// @nodoc
class __$$CalculateFeeError_MissingTxOutImplCopyWithImpl<$Res>
    extends _$CalculateFeeErrorCopyWithImpl<$Res,
        _$CalculateFeeError_MissingTxOutImpl>
    implements _$$CalculateFeeError_MissingTxOutImplCopyWith<$Res> {
  __$$CalculateFeeError_MissingTxOutImplCopyWithImpl(
      _$CalculateFeeError_MissingTxOutImpl _value,
      $Res Function(_$CalculateFeeError_MissingTxOutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? outPoints = null,
  }) {
    return _then(_$CalculateFeeError_MissingTxOutImpl(
      outPoints: null == outPoints
          ? _value._outPoints
          : outPoints // ignore: cast_nullable_to_non_nullable
              as List<OutPoint>,
    ));
  }
}

/// @nodoc

class _$CalculateFeeError_MissingTxOutImpl
    extends CalculateFeeError_MissingTxOut {
  const _$CalculateFeeError_MissingTxOutImpl(
      {required final List<OutPoint> outPoints})
      : _outPoints = outPoints,
        super._();

  final List<OutPoint> _outPoints;
  @override
  List<OutPoint> get outPoints {
    if (_outPoints is EqualUnmodifiableListView) return _outPoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outPoints);
  }

  @override
  String toString() {
    return 'CalculateFeeError.missingTxOut(outPoints: $outPoints)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalculateFeeError_MissingTxOutImpl &&
            const DeepCollectionEquality()
                .equals(other._outPoints, _outPoints));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_outPoints));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalculateFeeError_MissingTxOutImplCopyWith<
          _$CalculateFeeError_MissingTxOutImpl>
      get copyWith => __$$CalculateFeeError_MissingTxOutImplCopyWithImpl<
          _$CalculateFeeError_MissingTxOutImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(List<OutPoint> outPoints) missingTxOut,
    required TResult Function(String amount) negativeFee,
  }) {
    return missingTxOut(outPoints);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(List<OutPoint> outPoints)? missingTxOut,
    TResult? Function(String amount)? negativeFee,
  }) {
    return missingTxOut?.call(outPoints);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(List<OutPoint> outPoints)? missingTxOut,
    TResult Function(String amount)? negativeFee,
    required TResult orElse(),
  }) {
    if (missingTxOut != null) {
      return missingTxOut(outPoints);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateFeeError_Generic value) generic,
    required TResult Function(CalculateFeeError_MissingTxOut value)
        missingTxOut,
    required TResult Function(CalculateFeeError_NegativeFee value) negativeFee,
  }) {
    return missingTxOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateFeeError_Generic value)? generic,
    TResult? Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult? Function(CalculateFeeError_NegativeFee value)? negativeFee,
  }) {
    return missingTxOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateFeeError_Generic value)? generic,
    TResult Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult Function(CalculateFeeError_NegativeFee value)? negativeFee,
    required TResult orElse(),
  }) {
    if (missingTxOut != null) {
      return missingTxOut(this);
    }
    return orElse();
  }
}

abstract class CalculateFeeError_MissingTxOut extends CalculateFeeError {
  const factory CalculateFeeError_MissingTxOut(
          {required final List<OutPoint> outPoints}) =
      _$CalculateFeeError_MissingTxOutImpl;
  const CalculateFeeError_MissingTxOut._() : super._();

  List<OutPoint> get outPoints;
  @JsonKey(ignore: true)
  _$$CalculateFeeError_MissingTxOutImplCopyWith<
          _$CalculateFeeError_MissingTxOutImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalculateFeeError_NegativeFeeImplCopyWith<$Res> {
  factory _$$CalculateFeeError_NegativeFeeImplCopyWith(
          _$CalculateFeeError_NegativeFeeImpl value,
          $Res Function(_$CalculateFeeError_NegativeFeeImpl) then) =
      __$$CalculateFeeError_NegativeFeeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String amount});
}

/// @nodoc
class __$$CalculateFeeError_NegativeFeeImplCopyWithImpl<$Res>
    extends _$CalculateFeeErrorCopyWithImpl<$Res,
        _$CalculateFeeError_NegativeFeeImpl>
    implements _$$CalculateFeeError_NegativeFeeImplCopyWith<$Res> {
  __$$CalculateFeeError_NegativeFeeImplCopyWithImpl(
      _$CalculateFeeError_NegativeFeeImpl _value,
      $Res Function(_$CalculateFeeError_NegativeFeeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = null,
  }) {
    return _then(_$CalculateFeeError_NegativeFeeImpl(
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CalculateFeeError_NegativeFeeImpl
    extends CalculateFeeError_NegativeFee {
  const _$CalculateFeeError_NegativeFeeImpl({required this.amount}) : super._();

  @override
  final String amount;

  @override
  String toString() {
    return 'CalculateFeeError.negativeFee(amount: $amount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalculateFeeError_NegativeFeeImpl &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalculateFeeError_NegativeFeeImplCopyWith<
          _$CalculateFeeError_NegativeFeeImpl>
      get copyWith => __$$CalculateFeeError_NegativeFeeImplCopyWithImpl<
          _$CalculateFeeError_NegativeFeeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(List<OutPoint> outPoints) missingTxOut,
    required TResult Function(String amount) negativeFee,
  }) {
    return negativeFee(amount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(List<OutPoint> outPoints)? missingTxOut,
    TResult? Function(String amount)? negativeFee,
  }) {
    return negativeFee?.call(amount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(List<OutPoint> outPoints)? missingTxOut,
    TResult Function(String amount)? negativeFee,
    required TResult orElse(),
  }) {
    if (negativeFee != null) {
      return negativeFee(amount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateFeeError_Generic value) generic,
    required TResult Function(CalculateFeeError_MissingTxOut value)
        missingTxOut,
    required TResult Function(CalculateFeeError_NegativeFee value) negativeFee,
  }) {
    return negativeFee(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateFeeError_Generic value)? generic,
    TResult? Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult? Function(CalculateFeeError_NegativeFee value)? negativeFee,
  }) {
    return negativeFee?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateFeeError_Generic value)? generic,
    TResult Function(CalculateFeeError_MissingTxOut value)? missingTxOut,
    TResult Function(CalculateFeeError_NegativeFee value)? negativeFee,
    required TResult orElse(),
  }) {
    if (negativeFee != null) {
      return negativeFee(this);
    }
    return orElse();
  }
}

abstract class CalculateFeeError_NegativeFee extends CalculateFeeError {
  const factory CalculateFeeError_NegativeFee({required final String amount}) =
      _$CalculateFeeError_NegativeFeeImpl;
  const CalculateFeeError_NegativeFee._() : super._();

  String get amount;
  @JsonKey(ignore: true)
  _$$CalculateFeeError_NegativeFeeImplCopyWith<
          _$CalculateFeeError_NegativeFeeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CannotConnectError {
  int get height => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int height) include,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int height)? include,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int height)? include,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CannotConnectError_Include value) include,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CannotConnectError_Include value)? include,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CannotConnectError_Include value)? include,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CannotConnectErrorCopyWith<CannotConnectError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CannotConnectErrorCopyWith<$Res> {
  factory $CannotConnectErrorCopyWith(
          CannotConnectError value, $Res Function(CannotConnectError) then) =
      _$CannotConnectErrorCopyWithImpl<$Res, CannotConnectError>;
  @useResult
  $Res call({int height});
}

/// @nodoc
class _$CannotConnectErrorCopyWithImpl<$Res, $Val extends CannotConnectError>
    implements $CannotConnectErrorCopyWith<$Res> {
  _$CannotConnectErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = null,
  }) {
    return _then(_value.copyWith(
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CannotConnectError_IncludeImplCopyWith<$Res>
    implements $CannotConnectErrorCopyWith<$Res> {
  factory _$$CannotConnectError_IncludeImplCopyWith(
          _$CannotConnectError_IncludeImpl value,
          $Res Function(_$CannotConnectError_IncludeImpl) then) =
      __$$CannotConnectError_IncludeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int height});
}

/// @nodoc
class __$$CannotConnectError_IncludeImplCopyWithImpl<$Res>
    extends _$CannotConnectErrorCopyWithImpl<$Res,
        _$CannotConnectError_IncludeImpl>
    implements _$$CannotConnectError_IncludeImplCopyWith<$Res> {
  __$$CannotConnectError_IncludeImplCopyWithImpl(
      _$CannotConnectError_IncludeImpl _value,
      $Res Function(_$CannotConnectError_IncludeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = null,
  }) {
    return _then(_$CannotConnectError_IncludeImpl(
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CannotConnectError_IncludeImpl extends CannotConnectError_Include {
  const _$CannotConnectError_IncludeImpl({required this.height}) : super._();

  @override
  final int height;

  @override
  String toString() {
    return 'CannotConnectError.include(height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CannotConnectError_IncludeImpl &&
            (identical(other.height, height) || other.height == height));
  }

  @override
  int get hashCode => Object.hash(runtimeType, height);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CannotConnectError_IncludeImplCopyWith<_$CannotConnectError_IncludeImpl>
      get copyWith => __$$CannotConnectError_IncludeImplCopyWithImpl<
          _$CannotConnectError_IncludeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int height) include,
  }) {
    return include(height);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int height)? include,
  }) {
    return include?.call(height);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int height)? include,
    required TResult orElse(),
  }) {
    if (include != null) {
      return include(height);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CannotConnectError_Include value) include,
  }) {
    return include(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CannotConnectError_Include value)? include,
  }) {
    return include?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CannotConnectError_Include value)? include,
    required TResult orElse(),
  }) {
    if (include != null) {
      return include(this);
    }
    return orElse();
  }
}

abstract class CannotConnectError_Include extends CannotConnectError {
  const factory CannotConnectError_Include({required final int height}) =
      _$CannotConnectError_IncludeImpl;
  const CannotConnectError_Include._() : super._();

  @override
  int get height;
  @override
  @JsonKey(ignore: true)
  _$$CannotConnectError_IncludeImplCopyWith<_$CannotConnectError_IncludeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CreateTxError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateTxErrorCopyWith<$Res> {
  factory $CreateTxErrorCopyWith(
          CreateTxError value, $Res Function(CreateTxError) then) =
      _$CreateTxErrorCopyWithImpl<$Res, CreateTxError>;
}

/// @nodoc
class _$CreateTxErrorCopyWithImpl<$Res, $Val extends CreateTxError>
    implements $CreateTxErrorCopyWith<$Res> {
  _$CreateTxErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateTxError_GenericImplCopyWith<$Res> {
  factory _$$CreateTxError_GenericImplCopyWith(
          _$CreateTxError_GenericImpl value,
          $Res Function(_$CreateTxError_GenericImpl) then) =
      __$$CreateTxError_GenericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_GenericImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_GenericImpl>
    implements _$$CreateTxError_GenericImplCopyWith<$Res> {
  __$$CreateTxError_GenericImplCopyWithImpl(_$CreateTxError_GenericImpl _value,
      $Res Function(_$CreateTxError_GenericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_GenericImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_GenericImpl extends CreateTxError_Generic {
  const _$CreateTxError_GenericImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.generic(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_GenericImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_GenericImplCopyWith<_$CreateTxError_GenericImpl>
      get copyWith => __$$CreateTxError_GenericImplCopyWithImpl<
          _$CreateTxError_GenericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return generic(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return generic?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return generic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return generic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Generic extends CreateTxError {
  const factory CreateTxError_Generic({required final String errorMessage}) =
      _$CreateTxError_GenericImpl;
  const CreateTxError_Generic._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_GenericImplCopyWith<_$CreateTxError_GenericImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_DescriptorImplCopyWith<$Res> {
  factory _$$CreateTxError_DescriptorImplCopyWith(
          _$CreateTxError_DescriptorImpl value,
          $Res Function(_$CreateTxError_DescriptorImpl) then) =
      __$$CreateTxError_DescriptorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_DescriptorImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_DescriptorImpl>
    implements _$$CreateTxError_DescriptorImplCopyWith<$Res> {
  __$$CreateTxError_DescriptorImplCopyWithImpl(
      _$CreateTxError_DescriptorImpl _value,
      $Res Function(_$CreateTxError_DescriptorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_DescriptorImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_DescriptorImpl extends CreateTxError_Descriptor {
  const _$CreateTxError_DescriptorImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.descriptor(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_DescriptorImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_DescriptorImplCopyWith<_$CreateTxError_DescriptorImpl>
      get copyWith => __$$CreateTxError_DescriptorImplCopyWithImpl<
          _$CreateTxError_DescriptorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return descriptor(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return descriptor?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (descriptor != null) {
      return descriptor(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return descriptor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return descriptor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (descriptor != null) {
      return descriptor(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Descriptor extends CreateTxError {
  const factory CreateTxError_Descriptor({required final String errorMessage}) =
      _$CreateTxError_DescriptorImpl;
  const CreateTxError_Descriptor._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_DescriptorImplCopyWith<_$CreateTxError_DescriptorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_PolicyImplCopyWith<$Res> {
  factory _$$CreateTxError_PolicyImplCopyWith(_$CreateTxError_PolicyImpl value,
          $Res Function(_$CreateTxError_PolicyImpl) then) =
      __$$CreateTxError_PolicyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_PolicyImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_PolicyImpl>
    implements _$$CreateTxError_PolicyImplCopyWith<$Res> {
  __$$CreateTxError_PolicyImplCopyWithImpl(_$CreateTxError_PolicyImpl _value,
      $Res Function(_$CreateTxError_PolicyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_PolicyImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_PolicyImpl extends CreateTxError_Policy {
  const _$CreateTxError_PolicyImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.policy(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_PolicyImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_PolicyImplCopyWith<_$CreateTxError_PolicyImpl>
      get copyWith =>
          __$$CreateTxError_PolicyImplCopyWithImpl<_$CreateTxError_PolicyImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return policy(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return policy?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (policy != null) {
      return policy(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return policy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return policy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (policy != null) {
      return policy(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Policy extends CreateTxError {
  const factory CreateTxError_Policy({required final String errorMessage}) =
      _$CreateTxError_PolicyImpl;
  const CreateTxError_Policy._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_PolicyImplCopyWith<_$CreateTxError_PolicyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_SpendingPolicyRequiredImplCopyWith<$Res> {
  factory _$$CreateTxError_SpendingPolicyRequiredImplCopyWith(
          _$CreateTxError_SpendingPolicyRequiredImpl value,
          $Res Function(_$CreateTxError_SpendingPolicyRequiredImpl) then) =
      __$$CreateTxError_SpendingPolicyRequiredImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String kind});
}

/// @nodoc
class __$$CreateTxError_SpendingPolicyRequiredImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_SpendingPolicyRequiredImpl>
    implements _$$CreateTxError_SpendingPolicyRequiredImplCopyWith<$Res> {
  __$$CreateTxError_SpendingPolicyRequiredImplCopyWithImpl(
      _$CreateTxError_SpendingPolicyRequiredImpl _value,
      $Res Function(_$CreateTxError_SpendingPolicyRequiredImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kind = null,
  }) {
    return _then(_$CreateTxError_SpendingPolicyRequiredImpl(
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_SpendingPolicyRequiredImpl
    extends CreateTxError_SpendingPolicyRequired {
  const _$CreateTxError_SpendingPolicyRequiredImpl({required this.kind})
      : super._();

  @override
  final String kind;

  @override
  String toString() {
    return 'CreateTxError.spendingPolicyRequired(kind: $kind)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_SpendingPolicyRequiredImpl &&
            (identical(other.kind, kind) || other.kind == kind));
  }

  @override
  int get hashCode => Object.hash(runtimeType, kind);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_SpendingPolicyRequiredImplCopyWith<
          _$CreateTxError_SpendingPolicyRequiredImpl>
      get copyWith => __$$CreateTxError_SpendingPolicyRequiredImplCopyWithImpl<
          _$CreateTxError_SpendingPolicyRequiredImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return spendingPolicyRequired(kind);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return spendingPolicyRequired?.call(kind);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (spendingPolicyRequired != null) {
      return spendingPolicyRequired(kind);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return spendingPolicyRequired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return spendingPolicyRequired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (spendingPolicyRequired != null) {
      return spendingPolicyRequired(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_SpendingPolicyRequired extends CreateTxError {
  const factory CreateTxError_SpendingPolicyRequired(
          {required final String kind}) =
      _$CreateTxError_SpendingPolicyRequiredImpl;
  const CreateTxError_SpendingPolicyRequired._() : super._();

  String get kind;
  @JsonKey(ignore: true)
  _$$CreateTxError_SpendingPolicyRequiredImplCopyWith<
          _$CreateTxError_SpendingPolicyRequiredImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_Version0ImplCopyWith<$Res> {
  factory _$$CreateTxError_Version0ImplCopyWith(
          _$CreateTxError_Version0Impl value,
          $Res Function(_$CreateTxError_Version0Impl) then) =
      __$$CreateTxError_Version0ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_Version0ImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_Version0Impl>
    implements _$$CreateTxError_Version0ImplCopyWith<$Res> {
  __$$CreateTxError_Version0ImplCopyWithImpl(
      _$CreateTxError_Version0Impl _value,
      $Res Function(_$CreateTxError_Version0Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_Version0Impl extends CreateTxError_Version0 {
  const _$CreateTxError_Version0Impl() : super._();

  @override
  String toString() {
    return 'CreateTxError.version0()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_Version0Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return version0();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return version0?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (version0 != null) {
      return version0();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return version0(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return version0?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (version0 != null) {
      return version0(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Version0 extends CreateTxError {
  const factory CreateTxError_Version0() = _$CreateTxError_Version0Impl;
  const CreateTxError_Version0._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_Version1CsvImplCopyWith<$Res> {
  factory _$$CreateTxError_Version1CsvImplCopyWith(
          _$CreateTxError_Version1CsvImpl value,
          $Res Function(_$CreateTxError_Version1CsvImpl) then) =
      __$$CreateTxError_Version1CsvImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_Version1CsvImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_Version1CsvImpl>
    implements _$$CreateTxError_Version1CsvImplCopyWith<$Res> {
  __$$CreateTxError_Version1CsvImplCopyWithImpl(
      _$CreateTxError_Version1CsvImpl _value,
      $Res Function(_$CreateTxError_Version1CsvImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_Version1CsvImpl extends CreateTxError_Version1Csv {
  const _$CreateTxError_Version1CsvImpl() : super._();

  @override
  String toString() {
    return 'CreateTxError.version1Csv()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_Version1CsvImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return version1Csv();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return version1Csv?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (version1Csv != null) {
      return version1Csv();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return version1Csv(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return version1Csv?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (version1Csv != null) {
      return version1Csv(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Version1Csv extends CreateTxError {
  const factory CreateTxError_Version1Csv() = _$CreateTxError_Version1CsvImpl;
  const CreateTxError_Version1Csv._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_LockTimeImplCopyWith<$Res> {
  factory _$$CreateTxError_LockTimeImplCopyWith(
          _$CreateTxError_LockTimeImpl value,
          $Res Function(_$CreateTxError_LockTimeImpl) then) =
      __$$CreateTxError_LockTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String requested, String required_});
}

/// @nodoc
class __$$CreateTxError_LockTimeImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_LockTimeImpl>
    implements _$$CreateTxError_LockTimeImplCopyWith<$Res> {
  __$$CreateTxError_LockTimeImplCopyWithImpl(
      _$CreateTxError_LockTimeImpl _value,
      $Res Function(_$CreateTxError_LockTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requested = null,
    Object? required_ = null,
  }) {
    return _then(_$CreateTxError_LockTimeImpl(
      requested: null == requested
          ? _value.requested
          : requested // ignore: cast_nullable_to_non_nullable
              as String,
      required_: null == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_LockTimeImpl extends CreateTxError_LockTime {
  const _$CreateTxError_LockTimeImpl(
      {required this.requested, required this.required_})
      : super._();

  @override
  final String requested;
  @override
  final String required_;

  @override
  String toString() {
    return 'CreateTxError.lockTime(requested: $requested, required_: $required_)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_LockTimeImpl &&
            (identical(other.requested, requested) ||
                other.requested == requested) &&
            (identical(other.required_, required_) ||
                other.required_ == required_));
  }

  @override
  int get hashCode => Object.hash(runtimeType, requested, required_);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_LockTimeImplCopyWith<_$CreateTxError_LockTimeImpl>
      get copyWith => __$$CreateTxError_LockTimeImplCopyWithImpl<
          _$CreateTxError_LockTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return lockTime(requested, required_);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return lockTime?.call(requested, required_);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (lockTime != null) {
      return lockTime(requested, required_);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return lockTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return lockTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (lockTime != null) {
      return lockTime(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_LockTime extends CreateTxError {
  const factory CreateTxError_LockTime(
      {required final String requested,
      required final String required_}) = _$CreateTxError_LockTimeImpl;
  const CreateTxError_LockTime._() : super._();

  String get requested;
  String get required_;
  @JsonKey(ignore: true)
  _$$CreateTxError_LockTimeImplCopyWith<_$CreateTxError_LockTimeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_RbfSequenceImplCopyWith<$Res> {
  factory _$$CreateTxError_RbfSequenceImplCopyWith(
          _$CreateTxError_RbfSequenceImpl value,
          $Res Function(_$CreateTxError_RbfSequenceImpl) then) =
      __$$CreateTxError_RbfSequenceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_RbfSequenceImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_RbfSequenceImpl>
    implements _$$CreateTxError_RbfSequenceImplCopyWith<$Res> {
  __$$CreateTxError_RbfSequenceImplCopyWithImpl(
      _$CreateTxError_RbfSequenceImpl _value,
      $Res Function(_$CreateTxError_RbfSequenceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_RbfSequenceImpl extends CreateTxError_RbfSequence {
  const _$CreateTxError_RbfSequenceImpl() : super._();

  @override
  String toString() {
    return 'CreateTxError.rbfSequence()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_RbfSequenceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return rbfSequence();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return rbfSequence?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (rbfSequence != null) {
      return rbfSequence();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return rbfSequence(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return rbfSequence?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (rbfSequence != null) {
      return rbfSequence(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_RbfSequence extends CreateTxError {
  const factory CreateTxError_RbfSequence() = _$CreateTxError_RbfSequenceImpl;
  const CreateTxError_RbfSequence._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_RbfSequenceCsvImplCopyWith<$Res> {
  factory _$$CreateTxError_RbfSequenceCsvImplCopyWith(
          _$CreateTxError_RbfSequenceCsvImpl value,
          $Res Function(_$CreateTxError_RbfSequenceCsvImpl) then) =
      __$$CreateTxError_RbfSequenceCsvImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String rbf, String csv});
}

/// @nodoc
class __$$CreateTxError_RbfSequenceCsvImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_RbfSequenceCsvImpl>
    implements _$$CreateTxError_RbfSequenceCsvImplCopyWith<$Res> {
  __$$CreateTxError_RbfSequenceCsvImplCopyWithImpl(
      _$CreateTxError_RbfSequenceCsvImpl _value,
      $Res Function(_$CreateTxError_RbfSequenceCsvImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rbf = null,
    Object? csv = null,
  }) {
    return _then(_$CreateTxError_RbfSequenceCsvImpl(
      rbf: null == rbf
          ? _value.rbf
          : rbf // ignore: cast_nullable_to_non_nullable
              as String,
      csv: null == csv
          ? _value.csv
          : csv // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_RbfSequenceCsvImpl extends CreateTxError_RbfSequenceCsv {
  const _$CreateTxError_RbfSequenceCsvImpl(
      {required this.rbf, required this.csv})
      : super._();

  @override
  final String rbf;
  @override
  final String csv;

  @override
  String toString() {
    return 'CreateTxError.rbfSequenceCsv(rbf: $rbf, csv: $csv)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_RbfSequenceCsvImpl &&
            (identical(other.rbf, rbf) || other.rbf == rbf) &&
            (identical(other.csv, csv) || other.csv == csv));
  }

  @override
  int get hashCode => Object.hash(runtimeType, rbf, csv);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_RbfSequenceCsvImplCopyWith<
          _$CreateTxError_RbfSequenceCsvImpl>
      get copyWith => __$$CreateTxError_RbfSequenceCsvImplCopyWithImpl<
          _$CreateTxError_RbfSequenceCsvImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return rbfSequenceCsv(rbf, csv);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return rbfSequenceCsv?.call(rbf, csv);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (rbfSequenceCsv != null) {
      return rbfSequenceCsv(rbf, csv);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return rbfSequenceCsv(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return rbfSequenceCsv?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (rbfSequenceCsv != null) {
      return rbfSequenceCsv(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_RbfSequenceCsv extends CreateTxError {
  const factory CreateTxError_RbfSequenceCsv(
      {required final String rbf,
      required final String csv}) = _$CreateTxError_RbfSequenceCsvImpl;
  const CreateTxError_RbfSequenceCsv._() : super._();

  String get rbf;
  String get csv;
  @JsonKey(ignore: true)
  _$$CreateTxError_RbfSequenceCsvImplCopyWith<
          _$CreateTxError_RbfSequenceCsvImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_FeeTooLowImplCopyWith<$Res> {
  factory _$$CreateTxError_FeeTooLowImplCopyWith(
          _$CreateTxError_FeeTooLowImpl value,
          $Res Function(_$CreateTxError_FeeTooLowImpl) then) =
      __$$CreateTxError_FeeTooLowImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String required_});
}

/// @nodoc
class __$$CreateTxError_FeeTooLowImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_FeeTooLowImpl>
    implements _$$CreateTxError_FeeTooLowImplCopyWith<$Res> {
  __$$CreateTxError_FeeTooLowImplCopyWithImpl(
      _$CreateTxError_FeeTooLowImpl _value,
      $Res Function(_$CreateTxError_FeeTooLowImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? required_ = null,
  }) {
    return _then(_$CreateTxError_FeeTooLowImpl(
      required_: null == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_FeeTooLowImpl extends CreateTxError_FeeTooLow {
  const _$CreateTxError_FeeTooLowImpl({required this.required_}) : super._();

  @override
  final String required_;

  @override
  String toString() {
    return 'CreateTxError.feeTooLow(required_: $required_)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_FeeTooLowImpl &&
            (identical(other.required_, required_) ||
                other.required_ == required_));
  }

  @override
  int get hashCode => Object.hash(runtimeType, required_);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_FeeTooLowImplCopyWith<_$CreateTxError_FeeTooLowImpl>
      get copyWith => __$$CreateTxError_FeeTooLowImplCopyWithImpl<
          _$CreateTxError_FeeTooLowImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return feeTooLow(required_);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return feeTooLow?.call(required_);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (feeTooLow != null) {
      return feeTooLow(required_);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return feeTooLow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return feeTooLow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (feeTooLow != null) {
      return feeTooLow(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_FeeTooLow extends CreateTxError {
  const factory CreateTxError_FeeTooLow({required final String required_}) =
      _$CreateTxError_FeeTooLowImpl;
  const CreateTxError_FeeTooLow._() : super._();

  String get required_;
  @JsonKey(ignore: true)
  _$$CreateTxError_FeeTooLowImplCopyWith<_$CreateTxError_FeeTooLowImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_FeeRateTooLowImplCopyWith<$Res> {
  factory _$$CreateTxError_FeeRateTooLowImplCopyWith(
          _$CreateTxError_FeeRateTooLowImpl value,
          $Res Function(_$CreateTxError_FeeRateTooLowImpl) then) =
      __$$CreateTxError_FeeRateTooLowImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String required_});
}

/// @nodoc
class __$$CreateTxError_FeeRateTooLowImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_FeeRateTooLowImpl>
    implements _$$CreateTxError_FeeRateTooLowImplCopyWith<$Res> {
  __$$CreateTxError_FeeRateTooLowImplCopyWithImpl(
      _$CreateTxError_FeeRateTooLowImpl _value,
      $Res Function(_$CreateTxError_FeeRateTooLowImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? required_ = null,
  }) {
    return _then(_$CreateTxError_FeeRateTooLowImpl(
      required_: null == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_FeeRateTooLowImpl extends CreateTxError_FeeRateTooLow {
  const _$CreateTxError_FeeRateTooLowImpl({required this.required_})
      : super._();

  @override
  final String required_;

  @override
  String toString() {
    return 'CreateTxError.feeRateTooLow(required_: $required_)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_FeeRateTooLowImpl &&
            (identical(other.required_, required_) ||
                other.required_ == required_));
  }

  @override
  int get hashCode => Object.hash(runtimeType, required_);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_FeeRateTooLowImplCopyWith<_$CreateTxError_FeeRateTooLowImpl>
      get copyWith => __$$CreateTxError_FeeRateTooLowImplCopyWithImpl<
          _$CreateTxError_FeeRateTooLowImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return feeRateTooLow(required_);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return feeRateTooLow?.call(required_);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (feeRateTooLow != null) {
      return feeRateTooLow(required_);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return feeRateTooLow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return feeRateTooLow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (feeRateTooLow != null) {
      return feeRateTooLow(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_FeeRateTooLow extends CreateTxError {
  const factory CreateTxError_FeeRateTooLow({required final String required_}) =
      _$CreateTxError_FeeRateTooLowImpl;
  const CreateTxError_FeeRateTooLow._() : super._();

  String get required_;
  @JsonKey(ignore: true)
  _$$CreateTxError_FeeRateTooLowImplCopyWith<_$CreateTxError_FeeRateTooLowImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_NoUtxosSelectedImplCopyWith<$Res> {
  factory _$$CreateTxError_NoUtxosSelectedImplCopyWith(
          _$CreateTxError_NoUtxosSelectedImpl value,
          $Res Function(_$CreateTxError_NoUtxosSelectedImpl) then) =
      __$$CreateTxError_NoUtxosSelectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_NoUtxosSelectedImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_NoUtxosSelectedImpl>
    implements _$$CreateTxError_NoUtxosSelectedImplCopyWith<$Res> {
  __$$CreateTxError_NoUtxosSelectedImplCopyWithImpl(
      _$CreateTxError_NoUtxosSelectedImpl _value,
      $Res Function(_$CreateTxError_NoUtxosSelectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_NoUtxosSelectedImpl
    extends CreateTxError_NoUtxosSelected {
  const _$CreateTxError_NoUtxosSelectedImpl() : super._();

  @override
  String toString() {
    return 'CreateTxError.noUtxosSelected()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_NoUtxosSelectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return noUtxosSelected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return noUtxosSelected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (noUtxosSelected != null) {
      return noUtxosSelected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return noUtxosSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return noUtxosSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (noUtxosSelected != null) {
      return noUtxosSelected(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_NoUtxosSelected extends CreateTxError {
  const factory CreateTxError_NoUtxosSelected() =
      _$CreateTxError_NoUtxosSelectedImpl;
  const CreateTxError_NoUtxosSelected._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_OutputBelowDustLimitImplCopyWith<$Res> {
  factory _$$CreateTxError_OutputBelowDustLimitImplCopyWith(
          _$CreateTxError_OutputBelowDustLimitImpl value,
          $Res Function(_$CreateTxError_OutputBelowDustLimitImpl) then) =
      __$$CreateTxError_OutputBelowDustLimitImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt index});
}

/// @nodoc
class __$$CreateTxError_OutputBelowDustLimitImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_OutputBelowDustLimitImpl>
    implements _$$CreateTxError_OutputBelowDustLimitImplCopyWith<$Res> {
  __$$CreateTxError_OutputBelowDustLimitImplCopyWithImpl(
      _$CreateTxError_OutputBelowDustLimitImpl _value,
      $Res Function(_$CreateTxError_OutputBelowDustLimitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$CreateTxError_OutputBelowDustLimitImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$CreateTxError_OutputBelowDustLimitImpl
    extends CreateTxError_OutputBelowDustLimit {
  const _$CreateTxError_OutputBelowDustLimitImpl({required this.index})
      : super._();

  @override
  final BigInt index;

  @override
  String toString() {
    return 'CreateTxError.outputBelowDustLimit(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_OutputBelowDustLimitImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_OutputBelowDustLimitImplCopyWith<
          _$CreateTxError_OutputBelowDustLimitImpl>
      get copyWith => __$$CreateTxError_OutputBelowDustLimitImplCopyWithImpl<
          _$CreateTxError_OutputBelowDustLimitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return outputBelowDustLimit(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return outputBelowDustLimit?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (outputBelowDustLimit != null) {
      return outputBelowDustLimit(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return outputBelowDustLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return outputBelowDustLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (outputBelowDustLimit != null) {
      return outputBelowDustLimit(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_OutputBelowDustLimit extends CreateTxError {
  const factory CreateTxError_OutputBelowDustLimit(
      {required final BigInt index}) = _$CreateTxError_OutputBelowDustLimitImpl;
  const CreateTxError_OutputBelowDustLimit._() : super._();

  BigInt get index;
  @JsonKey(ignore: true)
  _$$CreateTxError_OutputBelowDustLimitImplCopyWith<
          _$CreateTxError_OutputBelowDustLimitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_ChangePolicyDescriptorImplCopyWith<$Res> {
  factory _$$CreateTxError_ChangePolicyDescriptorImplCopyWith(
          _$CreateTxError_ChangePolicyDescriptorImpl value,
          $Res Function(_$CreateTxError_ChangePolicyDescriptorImpl) then) =
      __$$CreateTxError_ChangePolicyDescriptorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_ChangePolicyDescriptorImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_ChangePolicyDescriptorImpl>
    implements _$$CreateTxError_ChangePolicyDescriptorImplCopyWith<$Res> {
  __$$CreateTxError_ChangePolicyDescriptorImplCopyWithImpl(
      _$CreateTxError_ChangePolicyDescriptorImpl _value,
      $Res Function(_$CreateTxError_ChangePolicyDescriptorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_ChangePolicyDescriptorImpl
    extends CreateTxError_ChangePolicyDescriptor {
  const _$CreateTxError_ChangePolicyDescriptorImpl() : super._();

  @override
  String toString() {
    return 'CreateTxError.changePolicyDescriptor()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_ChangePolicyDescriptorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return changePolicyDescriptor();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return changePolicyDescriptor?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (changePolicyDescriptor != null) {
      return changePolicyDescriptor();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return changePolicyDescriptor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return changePolicyDescriptor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (changePolicyDescriptor != null) {
      return changePolicyDescriptor(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_ChangePolicyDescriptor extends CreateTxError {
  const factory CreateTxError_ChangePolicyDescriptor() =
      _$CreateTxError_ChangePolicyDescriptorImpl;
  const CreateTxError_ChangePolicyDescriptor._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_CoinSelectionImplCopyWith<$Res> {
  factory _$$CreateTxError_CoinSelectionImplCopyWith(
          _$CreateTxError_CoinSelectionImpl value,
          $Res Function(_$CreateTxError_CoinSelectionImpl) then) =
      __$$CreateTxError_CoinSelectionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_CoinSelectionImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_CoinSelectionImpl>
    implements _$$CreateTxError_CoinSelectionImplCopyWith<$Res> {
  __$$CreateTxError_CoinSelectionImplCopyWithImpl(
      _$CreateTxError_CoinSelectionImpl _value,
      $Res Function(_$CreateTxError_CoinSelectionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_CoinSelectionImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_CoinSelectionImpl extends CreateTxError_CoinSelection {
  const _$CreateTxError_CoinSelectionImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.coinSelection(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_CoinSelectionImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_CoinSelectionImplCopyWith<_$CreateTxError_CoinSelectionImpl>
      get copyWith => __$$CreateTxError_CoinSelectionImplCopyWithImpl<
          _$CreateTxError_CoinSelectionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return coinSelection(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return coinSelection?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (coinSelection != null) {
      return coinSelection(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return coinSelection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return coinSelection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (coinSelection != null) {
      return coinSelection(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_CoinSelection extends CreateTxError {
  const factory CreateTxError_CoinSelection(
      {required final String errorMessage}) = _$CreateTxError_CoinSelectionImpl;
  const CreateTxError_CoinSelection._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_CoinSelectionImplCopyWith<_$CreateTxError_CoinSelectionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_InsufficientFundsImplCopyWith<$Res> {
  factory _$$CreateTxError_InsufficientFundsImplCopyWith(
          _$CreateTxError_InsufficientFundsImpl value,
          $Res Function(_$CreateTxError_InsufficientFundsImpl) then) =
      __$$CreateTxError_InsufficientFundsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt needed, BigInt available});
}

/// @nodoc
class __$$CreateTxError_InsufficientFundsImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_InsufficientFundsImpl>
    implements _$$CreateTxError_InsufficientFundsImplCopyWith<$Res> {
  __$$CreateTxError_InsufficientFundsImplCopyWithImpl(
      _$CreateTxError_InsufficientFundsImpl _value,
      $Res Function(_$CreateTxError_InsufficientFundsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? needed = null,
    Object? available = null,
  }) {
    return _then(_$CreateTxError_InsufficientFundsImpl(
      needed: null == needed
          ? _value.needed
          : needed // ignore: cast_nullable_to_non_nullable
              as BigInt,
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$CreateTxError_InsufficientFundsImpl
    extends CreateTxError_InsufficientFunds {
  const _$CreateTxError_InsufficientFundsImpl(
      {required this.needed, required this.available})
      : super._();

  @override
  final BigInt needed;
  @override
  final BigInt available;

  @override
  String toString() {
    return 'CreateTxError.insufficientFunds(needed: $needed, available: $available)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_InsufficientFundsImpl &&
            (identical(other.needed, needed) || other.needed == needed) &&
            (identical(other.available, available) ||
                other.available == available));
  }

  @override
  int get hashCode => Object.hash(runtimeType, needed, available);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_InsufficientFundsImplCopyWith<
          _$CreateTxError_InsufficientFundsImpl>
      get copyWith => __$$CreateTxError_InsufficientFundsImplCopyWithImpl<
          _$CreateTxError_InsufficientFundsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return insufficientFunds(needed, available);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return insufficientFunds?.call(needed, available);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(needed, available);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_InsufficientFunds extends CreateTxError {
  const factory CreateTxError_InsufficientFunds(
      {required final BigInt needed,
      required final BigInt available}) = _$CreateTxError_InsufficientFundsImpl;
  const CreateTxError_InsufficientFunds._() : super._();

  BigInt get needed;
  BigInt get available;
  @JsonKey(ignore: true)
  _$$CreateTxError_InsufficientFundsImplCopyWith<
          _$CreateTxError_InsufficientFundsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_NoRecipientsImplCopyWith<$Res> {
  factory _$$CreateTxError_NoRecipientsImplCopyWith(
          _$CreateTxError_NoRecipientsImpl value,
          $Res Function(_$CreateTxError_NoRecipientsImpl) then) =
      __$$CreateTxError_NoRecipientsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateTxError_NoRecipientsImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_NoRecipientsImpl>
    implements _$$CreateTxError_NoRecipientsImplCopyWith<$Res> {
  __$$CreateTxError_NoRecipientsImplCopyWithImpl(
      _$CreateTxError_NoRecipientsImpl _value,
      $Res Function(_$CreateTxError_NoRecipientsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateTxError_NoRecipientsImpl extends CreateTxError_NoRecipients {
  const _$CreateTxError_NoRecipientsImpl() : super._();

  @override
  String toString() {
    return 'CreateTxError.noRecipients()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_NoRecipientsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return noRecipients();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return noRecipients?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (noRecipients != null) {
      return noRecipients();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return noRecipients(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return noRecipients?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (noRecipients != null) {
      return noRecipients(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_NoRecipients extends CreateTxError {
  const factory CreateTxError_NoRecipients() = _$CreateTxError_NoRecipientsImpl;
  const CreateTxError_NoRecipients._() : super._();
}

/// @nodoc
abstract class _$$CreateTxError_PsbtImplCopyWith<$Res> {
  factory _$$CreateTxError_PsbtImplCopyWith(_$CreateTxError_PsbtImpl value,
          $Res Function(_$CreateTxError_PsbtImpl) then) =
      __$$CreateTxError_PsbtImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_PsbtImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_PsbtImpl>
    implements _$$CreateTxError_PsbtImplCopyWith<$Res> {
  __$$CreateTxError_PsbtImplCopyWithImpl(_$CreateTxError_PsbtImpl _value,
      $Res Function(_$CreateTxError_PsbtImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_PsbtImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_PsbtImpl extends CreateTxError_Psbt {
  const _$CreateTxError_PsbtImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.psbt(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_PsbtImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_PsbtImplCopyWith<_$CreateTxError_PsbtImpl> get copyWith =>
      __$$CreateTxError_PsbtImplCopyWithImpl<_$CreateTxError_PsbtImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return psbt(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return psbt?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (psbt != null) {
      return psbt(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return psbt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return psbt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (psbt != null) {
      return psbt(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_Psbt extends CreateTxError {
  const factory CreateTxError_Psbt({required final String errorMessage}) =
      _$CreateTxError_PsbtImpl;
  const CreateTxError_Psbt._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_PsbtImplCopyWith<_$CreateTxError_PsbtImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_MissingKeyOriginImplCopyWith<$Res> {
  factory _$$CreateTxError_MissingKeyOriginImplCopyWith(
          _$CreateTxError_MissingKeyOriginImpl value,
          $Res Function(_$CreateTxError_MissingKeyOriginImpl) then) =
      __$$CreateTxError_MissingKeyOriginImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$CreateTxError_MissingKeyOriginImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_MissingKeyOriginImpl>
    implements _$$CreateTxError_MissingKeyOriginImplCopyWith<$Res> {
  __$$CreateTxError_MissingKeyOriginImplCopyWithImpl(
      _$CreateTxError_MissingKeyOriginImpl _value,
      $Res Function(_$CreateTxError_MissingKeyOriginImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$CreateTxError_MissingKeyOriginImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_MissingKeyOriginImpl
    extends CreateTxError_MissingKeyOrigin {
  const _$CreateTxError_MissingKeyOriginImpl({required this.key}) : super._();

  @override
  final String key;

  @override
  String toString() {
    return 'CreateTxError.missingKeyOrigin(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_MissingKeyOriginImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_MissingKeyOriginImplCopyWith<
          _$CreateTxError_MissingKeyOriginImpl>
      get copyWith => __$$CreateTxError_MissingKeyOriginImplCopyWithImpl<
          _$CreateTxError_MissingKeyOriginImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return missingKeyOrigin(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return missingKeyOrigin?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (missingKeyOrigin != null) {
      return missingKeyOrigin(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return missingKeyOrigin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return missingKeyOrigin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (missingKeyOrigin != null) {
      return missingKeyOrigin(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_MissingKeyOrigin extends CreateTxError {
  const factory CreateTxError_MissingKeyOrigin({required final String key}) =
      _$CreateTxError_MissingKeyOriginImpl;
  const CreateTxError_MissingKeyOrigin._() : super._();

  String get key;
  @JsonKey(ignore: true)
  _$$CreateTxError_MissingKeyOriginImplCopyWith<
          _$CreateTxError_MissingKeyOriginImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_UnknownUtxoImplCopyWith<$Res> {
  factory _$$CreateTxError_UnknownUtxoImplCopyWith(
          _$CreateTxError_UnknownUtxoImpl value,
          $Res Function(_$CreateTxError_UnknownUtxoImpl) then) =
      __$$CreateTxError_UnknownUtxoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String outpoint});
}

/// @nodoc
class __$$CreateTxError_UnknownUtxoImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res, _$CreateTxError_UnknownUtxoImpl>
    implements _$$CreateTxError_UnknownUtxoImplCopyWith<$Res> {
  __$$CreateTxError_UnknownUtxoImplCopyWithImpl(
      _$CreateTxError_UnknownUtxoImpl _value,
      $Res Function(_$CreateTxError_UnknownUtxoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? outpoint = null,
  }) {
    return _then(_$CreateTxError_UnknownUtxoImpl(
      outpoint: null == outpoint
          ? _value.outpoint
          : outpoint // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_UnknownUtxoImpl extends CreateTxError_UnknownUtxo {
  const _$CreateTxError_UnknownUtxoImpl({required this.outpoint}) : super._();

  @override
  final String outpoint;

  @override
  String toString() {
    return 'CreateTxError.unknownUtxo(outpoint: $outpoint)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_UnknownUtxoImpl &&
            (identical(other.outpoint, outpoint) ||
                other.outpoint == outpoint));
  }

  @override
  int get hashCode => Object.hash(runtimeType, outpoint);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_UnknownUtxoImplCopyWith<_$CreateTxError_UnknownUtxoImpl>
      get copyWith => __$$CreateTxError_UnknownUtxoImplCopyWithImpl<
          _$CreateTxError_UnknownUtxoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return unknownUtxo(outpoint);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return unknownUtxo?.call(outpoint);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (unknownUtxo != null) {
      return unknownUtxo(outpoint);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return unknownUtxo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return unknownUtxo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (unknownUtxo != null) {
      return unknownUtxo(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_UnknownUtxo extends CreateTxError {
  const factory CreateTxError_UnknownUtxo({required final String outpoint}) =
      _$CreateTxError_UnknownUtxoImpl;
  const CreateTxError_UnknownUtxo._() : super._();

  String get outpoint;
  @JsonKey(ignore: true)
  _$$CreateTxError_UnknownUtxoImplCopyWith<_$CreateTxError_UnknownUtxoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_MissingNonWitnessUtxoImplCopyWith<$Res> {
  factory _$$CreateTxError_MissingNonWitnessUtxoImplCopyWith(
          _$CreateTxError_MissingNonWitnessUtxoImpl value,
          $Res Function(_$CreateTxError_MissingNonWitnessUtxoImpl) then) =
      __$$CreateTxError_MissingNonWitnessUtxoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String outpoint});
}

/// @nodoc
class __$$CreateTxError_MissingNonWitnessUtxoImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_MissingNonWitnessUtxoImpl>
    implements _$$CreateTxError_MissingNonWitnessUtxoImplCopyWith<$Res> {
  __$$CreateTxError_MissingNonWitnessUtxoImplCopyWithImpl(
      _$CreateTxError_MissingNonWitnessUtxoImpl _value,
      $Res Function(_$CreateTxError_MissingNonWitnessUtxoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? outpoint = null,
  }) {
    return _then(_$CreateTxError_MissingNonWitnessUtxoImpl(
      outpoint: null == outpoint
          ? _value.outpoint
          : outpoint // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_MissingNonWitnessUtxoImpl
    extends CreateTxError_MissingNonWitnessUtxo {
  const _$CreateTxError_MissingNonWitnessUtxoImpl({required this.outpoint})
      : super._();

  @override
  final String outpoint;

  @override
  String toString() {
    return 'CreateTxError.missingNonWitnessUtxo(outpoint: $outpoint)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_MissingNonWitnessUtxoImpl &&
            (identical(other.outpoint, outpoint) ||
                other.outpoint == outpoint));
  }

  @override
  int get hashCode => Object.hash(runtimeType, outpoint);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_MissingNonWitnessUtxoImplCopyWith<
          _$CreateTxError_MissingNonWitnessUtxoImpl>
      get copyWith => __$$CreateTxError_MissingNonWitnessUtxoImplCopyWithImpl<
          _$CreateTxError_MissingNonWitnessUtxoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return missingNonWitnessUtxo(outpoint);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return missingNonWitnessUtxo?.call(outpoint);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (missingNonWitnessUtxo != null) {
      return missingNonWitnessUtxo(outpoint);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return missingNonWitnessUtxo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return missingNonWitnessUtxo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (missingNonWitnessUtxo != null) {
      return missingNonWitnessUtxo(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_MissingNonWitnessUtxo extends CreateTxError {
  const factory CreateTxError_MissingNonWitnessUtxo(
          {required final String outpoint}) =
      _$CreateTxError_MissingNonWitnessUtxoImpl;
  const CreateTxError_MissingNonWitnessUtxo._() : super._();

  String get outpoint;
  @JsonKey(ignore: true)
  _$$CreateTxError_MissingNonWitnessUtxoImplCopyWith<
          _$CreateTxError_MissingNonWitnessUtxoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTxError_MiniscriptPsbtImplCopyWith<$Res> {
  factory _$$CreateTxError_MiniscriptPsbtImplCopyWith(
          _$CreateTxError_MiniscriptPsbtImpl value,
          $Res Function(_$CreateTxError_MiniscriptPsbtImpl) then) =
      __$$CreateTxError_MiniscriptPsbtImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateTxError_MiniscriptPsbtImplCopyWithImpl<$Res>
    extends _$CreateTxErrorCopyWithImpl<$Res,
        _$CreateTxError_MiniscriptPsbtImpl>
    implements _$$CreateTxError_MiniscriptPsbtImplCopyWith<$Res> {
  __$$CreateTxError_MiniscriptPsbtImplCopyWithImpl(
      _$CreateTxError_MiniscriptPsbtImpl _value,
      $Res Function(_$CreateTxError_MiniscriptPsbtImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateTxError_MiniscriptPsbtImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateTxError_MiniscriptPsbtImpl extends CreateTxError_MiniscriptPsbt {
  const _$CreateTxError_MiniscriptPsbtImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateTxError.miniscriptPsbt(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTxError_MiniscriptPsbtImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTxError_MiniscriptPsbtImplCopyWith<
          _$CreateTxError_MiniscriptPsbtImpl>
      get copyWith => __$$CreateTxError_MiniscriptPsbtImplCopyWithImpl<
          _$CreateTxError_MiniscriptPsbtImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) descriptor,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String kind) spendingPolicyRequired,
    required TResult Function() version0,
    required TResult Function() version1Csv,
    required TResult Function(String requested, String required_) lockTime,
    required TResult Function() rbfSequence,
    required TResult Function(String rbf, String csv) rbfSequenceCsv,
    required TResult Function(String required_) feeTooLow,
    required TResult Function(String required_) feeRateTooLow,
    required TResult Function() noUtxosSelected,
    required TResult Function(BigInt index) outputBelowDustLimit,
    required TResult Function() changePolicyDescriptor,
    required TResult Function(String errorMessage) coinSelection,
    required TResult Function(BigInt needed, BigInt available)
        insufficientFunds,
    required TResult Function() noRecipients,
    required TResult Function(String errorMessage) psbt,
    required TResult Function(String key) missingKeyOrigin,
    required TResult Function(String outpoint) unknownUtxo,
    required TResult Function(String outpoint) missingNonWitnessUtxo,
    required TResult Function(String errorMessage) miniscriptPsbt,
  }) {
    return miniscriptPsbt(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? descriptor,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String kind)? spendingPolicyRequired,
    TResult? Function()? version0,
    TResult? Function()? version1Csv,
    TResult? Function(String requested, String required_)? lockTime,
    TResult? Function()? rbfSequence,
    TResult? Function(String rbf, String csv)? rbfSequenceCsv,
    TResult? Function(String required_)? feeTooLow,
    TResult? Function(String required_)? feeRateTooLow,
    TResult? Function()? noUtxosSelected,
    TResult? Function(BigInt index)? outputBelowDustLimit,
    TResult? Function()? changePolicyDescriptor,
    TResult? Function(String errorMessage)? coinSelection,
    TResult? Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult? Function()? noRecipients,
    TResult? Function(String errorMessage)? psbt,
    TResult? Function(String key)? missingKeyOrigin,
    TResult? Function(String outpoint)? unknownUtxo,
    TResult? Function(String outpoint)? missingNonWitnessUtxo,
    TResult? Function(String errorMessage)? miniscriptPsbt,
  }) {
    return miniscriptPsbt?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? descriptor,
    TResult Function(String errorMessage)? policy,
    TResult Function(String kind)? spendingPolicyRequired,
    TResult Function()? version0,
    TResult Function()? version1Csv,
    TResult Function(String requested, String required_)? lockTime,
    TResult Function()? rbfSequence,
    TResult Function(String rbf, String csv)? rbfSequenceCsv,
    TResult Function(String required_)? feeTooLow,
    TResult Function(String required_)? feeRateTooLow,
    TResult Function()? noUtxosSelected,
    TResult Function(BigInt index)? outputBelowDustLimit,
    TResult Function()? changePolicyDescriptor,
    TResult Function(String errorMessage)? coinSelection,
    TResult Function(BigInt needed, BigInt available)? insufficientFunds,
    TResult Function()? noRecipients,
    TResult Function(String errorMessage)? psbt,
    TResult Function(String key)? missingKeyOrigin,
    TResult Function(String outpoint)? unknownUtxo,
    TResult Function(String outpoint)? missingNonWitnessUtxo,
    TResult Function(String errorMessage)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (miniscriptPsbt != null) {
      return miniscriptPsbt(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateTxError_Generic value) generic,
    required TResult Function(CreateTxError_Descriptor value) descriptor,
    required TResult Function(CreateTxError_Policy value) policy,
    required TResult Function(CreateTxError_SpendingPolicyRequired value)
        spendingPolicyRequired,
    required TResult Function(CreateTxError_Version0 value) version0,
    required TResult Function(CreateTxError_Version1Csv value) version1Csv,
    required TResult Function(CreateTxError_LockTime value) lockTime,
    required TResult Function(CreateTxError_RbfSequence value) rbfSequence,
    required TResult Function(CreateTxError_RbfSequenceCsv value)
        rbfSequenceCsv,
    required TResult Function(CreateTxError_FeeTooLow value) feeTooLow,
    required TResult Function(CreateTxError_FeeRateTooLow value) feeRateTooLow,
    required TResult Function(CreateTxError_NoUtxosSelected value)
        noUtxosSelected,
    required TResult Function(CreateTxError_OutputBelowDustLimit value)
        outputBelowDustLimit,
    required TResult Function(CreateTxError_ChangePolicyDescriptor value)
        changePolicyDescriptor,
    required TResult Function(CreateTxError_CoinSelection value) coinSelection,
    required TResult Function(CreateTxError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(CreateTxError_NoRecipients value) noRecipients,
    required TResult Function(CreateTxError_Psbt value) psbt,
    required TResult Function(CreateTxError_MissingKeyOrigin value)
        missingKeyOrigin,
    required TResult Function(CreateTxError_UnknownUtxo value) unknownUtxo,
    required TResult Function(CreateTxError_MissingNonWitnessUtxo value)
        missingNonWitnessUtxo,
    required TResult Function(CreateTxError_MiniscriptPsbt value)
        miniscriptPsbt,
  }) {
    return miniscriptPsbt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateTxError_Generic value)? generic,
    TResult? Function(CreateTxError_Descriptor value)? descriptor,
    TResult? Function(CreateTxError_Policy value)? policy,
    TResult? Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult? Function(CreateTxError_Version0 value)? version0,
    TResult? Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult? Function(CreateTxError_LockTime value)? lockTime,
    TResult? Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult? Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult? Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult? Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult? Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult? Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult? Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult? Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult? Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult? Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult? Function(CreateTxError_Psbt value)? psbt,
    TResult? Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult? Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult? Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
  }) {
    return miniscriptPsbt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateTxError_Generic value)? generic,
    TResult Function(CreateTxError_Descriptor value)? descriptor,
    TResult Function(CreateTxError_Policy value)? policy,
    TResult Function(CreateTxError_SpendingPolicyRequired value)?
        spendingPolicyRequired,
    TResult Function(CreateTxError_Version0 value)? version0,
    TResult Function(CreateTxError_Version1Csv value)? version1Csv,
    TResult Function(CreateTxError_LockTime value)? lockTime,
    TResult Function(CreateTxError_RbfSequence value)? rbfSequence,
    TResult Function(CreateTxError_RbfSequenceCsv value)? rbfSequenceCsv,
    TResult Function(CreateTxError_FeeTooLow value)? feeTooLow,
    TResult Function(CreateTxError_FeeRateTooLow value)? feeRateTooLow,
    TResult Function(CreateTxError_NoUtxosSelected value)? noUtxosSelected,
    TResult Function(CreateTxError_OutputBelowDustLimit value)?
        outputBelowDustLimit,
    TResult Function(CreateTxError_ChangePolicyDescriptor value)?
        changePolicyDescriptor,
    TResult Function(CreateTxError_CoinSelection value)? coinSelection,
    TResult Function(CreateTxError_InsufficientFunds value)? insufficientFunds,
    TResult Function(CreateTxError_NoRecipients value)? noRecipients,
    TResult Function(CreateTxError_Psbt value)? psbt,
    TResult Function(CreateTxError_MissingKeyOrigin value)? missingKeyOrigin,
    TResult Function(CreateTxError_UnknownUtxo value)? unknownUtxo,
    TResult Function(CreateTxError_MissingNonWitnessUtxo value)?
        missingNonWitnessUtxo,
    TResult Function(CreateTxError_MiniscriptPsbt value)? miniscriptPsbt,
    required TResult orElse(),
  }) {
    if (miniscriptPsbt != null) {
      return miniscriptPsbt(this);
    }
    return orElse();
  }
}

abstract class CreateTxError_MiniscriptPsbt extends CreateTxError {
  const factory CreateTxError_MiniscriptPsbt(
          {required final String errorMessage}) =
      _$CreateTxError_MiniscriptPsbtImpl;
  const CreateTxError_MiniscriptPsbt._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateTxError_MiniscriptPsbtImplCopyWith<
          _$CreateTxError_MiniscriptPsbtImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CreateWithPersistError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function() dataAlreadyExists,
    required TResult Function(String errorMessage) descriptor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function()? dataAlreadyExists,
    TResult? Function(String errorMessage)? descriptor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function()? dataAlreadyExists,
    TResult Function(String errorMessage)? descriptor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateWithPersistError_Persist value) persist,
    required TResult Function(CreateWithPersistError_DataAlreadyExists value)
        dataAlreadyExists,
    required TResult Function(CreateWithPersistError_Descriptor value)
        descriptor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateWithPersistError_Persist value)? persist,
    TResult? Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult? Function(CreateWithPersistError_Descriptor value)? descriptor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateWithPersistError_Persist value)? persist,
    TResult Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult Function(CreateWithPersistError_Descriptor value)? descriptor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateWithPersistErrorCopyWith<$Res> {
  factory $CreateWithPersistErrorCopyWith(CreateWithPersistError value,
          $Res Function(CreateWithPersistError) then) =
      _$CreateWithPersistErrorCopyWithImpl<$Res, CreateWithPersistError>;
}

/// @nodoc
class _$CreateWithPersistErrorCopyWithImpl<$Res,
        $Val extends CreateWithPersistError>
    implements $CreateWithPersistErrorCopyWith<$Res> {
  _$CreateWithPersistErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateWithPersistError_PersistImplCopyWith<$Res> {
  factory _$$CreateWithPersistError_PersistImplCopyWith(
          _$CreateWithPersistError_PersistImpl value,
          $Res Function(_$CreateWithPersistError_PersistImpl) then) =
      __$$CreateWithPersistError_PersistImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateWithPersistError_PersistImplCopyWithImpl<$Res>
    extends _$CreateWithPersistErrorCopyWithImpl<$Res,
        _$CreateWithPersistError_PersistImpl>
    implements _$$CreateWithPersistError_PersistImplCopyWith<$Res> {
  __$$CreateWithPersistError_PersistImplCopyWithImpl(
      _$CreateWithPersistError_PersistImpl _value,
      $Res Function(_$CreateWithPersistError_PersistImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateWithPersistError_PersistImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateWithPersistError_PersistImpl
    extends CreateWithPersistError_Persist {
  const _$CreateWithPersistError_PersistImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateWithPersistError.persist(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateWithPersistError_PersistImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateWithPersistError_PersistImplCopyWith<
          _$CreateWithPersistError_PersistImpl>
      get copyWith => __$$CreateWithPersistError_PersistImplCopyWithImpl<
          _$CreateWithPersistError_PersistImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function() dataAlreadyExists,
    required TResult Function(String errorMessage) descriptor,
  }) {
    return persist(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function()? dataAlreadyExists,
    TResult? Function(String errorMessage)? descriptor,
  }) {
    return persist?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function()? dataAlreadyExists,
    TResult Function(String errorMessage)? descriptor,
    required TResult orElse(),
  }) {
    if (persist != null) {
      return persist(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateWithPersistError_Persist value) persist,
    required TResult Function(CreateWithPersistError_DataAlreadyExists value)
        dataAlreadyExists,
    required TResult Function(CreateWithPersistError_Descriptor value)
        descriptor,
  }) {
    return persist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateWithPersistError_Persist value)? persist,
    TResult? Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult? Function(CreateWithPersistError_Descriptor value)? descriptor,
  }) {
    return persist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateWithPersistError_Persist value)? persist,
    TResult Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult Function(CreateWithPersistError_Descriptor value)? descriptor,
    required TResult orElse(),
  }) {
    if (persist != null) {
      return persist(this);
    }
    return orElse();
  }
}

abstract class CreateWithPersistError_Persist extends CreateWithPersistError {
  const factory CreateWithPersistError_Persist(
          {required final String errorMessage}) =
      _$CreateWithPersistError_PersistImpl;
  const CreateWithPersistError_Persist._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateWithPersistError_PersistImplCopyWith<
          _$CreateWithPersistError_PersistImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateWithPersistError_DataAlreadyExistsImplCopyWith<$Res> {
  factory _$$CreateWithPersistError_DataAlreadyExistsImplCopyWith(
          _$CreateWithPersistError_DataAlreadyExistsImpl value,
          $Res Function(_$CreateWithPersistError_DataAlreadyExistsImpl) then) =
      __$$CreateWithPersistError_DataAlreadyExistsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateWithPersistError_DataAlreadyExistsImplCopyWithImpl<$Res>
    extends _$CreateWithPersistErrorCopyWithImpl<$Res,
        _$CreateWithPersistError_DataAlreadyExistsImpl>
    implements _$$CreateWithPersistError_DataAlreadyExistsImplCopyWith<$Res> {
  __$$CreateWithPersistError_DataAlreadyExistsImplCopyWithImpl(
      _$CreateWithPersistError_DataAlreadyExistsImpl _value,
      $Res Function(_$CreateWithPersistError_DataAlreadyExistsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateWithPersistError_DataAlreadyExistsImpl
    extends CreateWithPersistError_DataAlreadyExists {
  const _$CreateWithPersistError_DataAlreadyExistsImpl() : super._();

  @override
  String toString() {
    return 'CreateWithPersistError.dataAlreadyExists()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateWithPersistError_DataAlreadyExistsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function() dataAlreadyExists,
    required TResult Function(String errorMessage) descriptor,
  }) {
    return dataAlreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function()? dataAlreadyExists,
    TResult? Function(String errorMessage)? descriptor,
  }) {
    return dataAlreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function()? dataAlreadyExists,
    TResult Function(String errorMessage)? descriptor,
    required TResult orElse(),
  }) {
    if (dataAlreadyExists != null) {
      return dataAlreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateWithPersistError_Persist value) persist,
    required TResult Function(CreateWithPersistError_DataAlreadyExists value)
        dataAlreadyExists,
    required TResult Function(CreateWithPersistError_Descriptor value)
        descriptor,
  }) {
    return dataAlreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateWithPersistError_Persist value)? persist,
    TResult? Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult? Function(CreateWithPersistError_Descriptor value)? descriptor,
  }) {
    return dataAlreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateWithPersistError_Persist value)? persist,
    TResult Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult Function(CreateWithPersistError_Descriptor value)? descriptor,
    required TResult orElse(),
  }) {
    if (dataAlreadyExists != null) {
      return dataAlreadyExists(this);
    }
    return orElse();
  }
}

abstract class CreateWithPersistError_DataAlreadyExists
    extends CreateWithPersistError {
  const factory CreateWithPersistError_DataAlreadyExists() =
      _$CreateWithPersistError_DataAlreadyExistsImpl;
  const CreateWithPersistError_DataAlreadyExists._() : super._();
}

/// @nodoc
abstract class _$$CreateWithPersistError_DescriptorImplCopyWith<$Res> {
  factory _$$CreateWithPersistError_DescriptorImplCopyWith(
          _$CreateWithPersistError_DescriptorImpl value,
          $Res Function(_$CreateWithPersistError_DescriptorImpl) then) =
      __$$CreateWithPersistError_DescriptorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$CreateWithPersistError_DescriptorImplCopyWithImpl<$Res>
    extends _$CreateWithPersistErrorCopyWithImpl<$Res,
        _$CreateWithPersistError_DescriptorImpl>
    implements _$$CreateWithPersistError_DescriptorImplCopyWith<$Res> {
  __$$CreateWithPersistError_DescriptorImplCopyWithImpl(
      _$CreateWithPersistError_DescriptorImpl _value,
      $Res Function(_$CreateWithPersistError_DescriptorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$CreateWithPersistError_DescriptorImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateWithPersistError_DescriptorImpl
    extends CreateWithPersistError_Descriptor {
  const _$CreateWithPersistError_DescriptorImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CreateWithPersistError.descriptor(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateWithPersistError_DescriptorImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateWithPersistError_DescriptorImplCopyWith<
          _$CreateWithPersistError_DescriptorImpl>
      get copyWith => __$$CreateWithPersistError_DescriptorImplCopyWithImpl<
          _$CreateWithPersistError_DescriptorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function() dataAlreadyExists,
    required TResult Function(String errorMessage) descriptor,
  }) {
    return descriptor(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function()? dataAlreadyExists,
    TResult? Function(String errorMessage)? descriptor,
  }) {
    return descriptor?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function()? dataAlreadyExists,
    TResult Function(String errorMessage)? descriptor,
    required TResult orElse(),
  }) {
    if (descriptor != null) {
      return descriptor(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateWithPersistError_Persist value) persist,
    required TResult Function(CreateWithPersistError_DataAlreadyExists value)
        dataAlreadyExists,
    required TResult Function(CreateWithPersistError_Descriptor value)
        descriptor,
  }) {
    return descriptor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateWithPersistError_Persist value)? persist,
    TResult? Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult? Function(CreateWithPersistError_Descriptor value)? descriptor,
  }) {
    return descriptor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateWithPersistError_Persist value)? persist,
    TResult Function(CreateWithPersistError_DataAlreadyExists value)?
        dataAlreadyExists,
    TResult Function(CreateWithPersistError_Descriptor value)? descriptor,
    required TResult orElse(),
  }) {
    if (descriptor != null) {
      return descriptor(this);
    }
    return orElse();
  }
}

abstract class CreateWithPersistError_Descriptor
    extends CreateWithPersistError {
  const factory CreateWithPersistError_Descriptor(
          {required final String errorMessage}) =
      _$CreateWithPersistError_DescriptorImpl;
  const CreateWithPersistError_Descriptor._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$CreateWithPersistError_DescriptorImplCopyWith<
          _$CreateWithPersistError_DescriptorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DescriptorError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DescriptorErrorCopyWith<$Res> {
  factory $DescriptorErrorCopyWith(
          DescriptorError value, $Res Function(DescriptorError) then) =
      _$DescriptorErrorCopyWithImpl<$Res, DescriptorError>;
}

/// @nodoc
class _$DescriptorErrorCopyWithImpl<$Res, $Val extends DescriptorError>
    implements $DescriptorErrorCopyWith<$Res> {
  _$DescriptorErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DescriptorError_InvalidHdKeyPathImplCopyWith<$Res> {
  factory _$$DescriptorError_InvalidHdKeyPathImplCopyWith(
          _$DescriptorError_InvalidHdKeyPathImpl value,
          $Res Function(_$DescriptorError_InvalidHdKeyPathImpl) then) =
      __$$DescriptorError_InvalidHdKeyPathImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_InvalidHdKeyPathImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_InvalidHdKeyPathImpl>
    implements _$$DescriptorError_InvalidHdKeyPathImplCopyWith<$Res> {
  __$$DescriptorError_InvalidHdKeyPathImplCopyWithImpl(
      _$DescriptorError_InvalidHdKeyPathImpl _value,
      $Res Function(_$DescriptorError_InvalidHdKeyPathImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_InvalidHdKeyPathImpl
    extends DescriptorError_InvalidHdKeyPath {
  const _$DescriptorError_InvalidHdKeyPathImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.invalidHdKeyPath()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_InvalidHdKeyPathImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return invalidHdKeyPath();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return invalidHdKeyPath?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidHdKeyPath != null) {
      return invalidHdKeyPath();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return invalidHdKeyPath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return invalidHdKeyPath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidHdKeyPath != null) {
      return invalidHdKeyPath(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_InvalidHdKeyPath extends DescriptorError {
  const factory DescriptorError_InvalidHdKeyPath() =
      _$DescriptorError_InvalidHdKeyPathImpl;
  const DescriptorError_InvalidHdKeyPath._() : super._();
}

/// @nodoc
abstract class _$$DescriptorError_MissingPrivateDataImplCopyWith<$Res> {
  factory _$$DescriptorError_MissingPrivateDataImplCopyWith(
          _$DescriptorError_MissingPrivateDataImpl value,
          $Res Function(_$DescriptorError_MissingPrivateDataImpl) then) =
      __$$DescriptorError_MissingPrivateDataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_MissingPrivateDataImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_MissingPrivateDataImpl>
    implements _$$DescriptorError_MissingPrivateDataImplCopyWith<$Res> {
  __$$DescriptorError_MissingPrivateDataImplCopyWithImpl(
      _$DescriptorError_MissingPrivateDataImpl _value,
      $Res Function(_$DescriptorError_MissingPrivateDataImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_MissingPrivateDataImpl
    extends DescriptorError_MissingPrivateData {
  const _$DescriptorError_MissingPrivateDataImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.missingPrivateData()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_MissingPrivateDataImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return missingPrivateData();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return missingPrivateData?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (missingPrivateData != null) {
      return missingPrivateData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return missingPrivateData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return missingPrivateData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (missingPrivateData != null) {
      return missingPrivateData(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_MissingPrivateData extends DescriptorError {
  const factory DescriptorError_MissingPrivateData() =
      _$DescriptorError_MissingPrivateDataImpl;
  const DescriptorError_MissingPrivateData._() : super._();
}

/// @nodoc
abstract class _$$DescriptorError_InvalidDescriptorChecksumImplCopyWith<$Res> {
  factory _$$DescriptorError_InvalidDescriptorChecksumImplCopyWith(
          _$DescriptorError_InvalidDescriptorChecksumImpl value,
          $Res Function(_$DescriptorError_InvalidDescriptorChecksumImpl) then) =
      __$$DescriptorError_InvalidDescriptorChecksumImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_InvalidDescriptorChecksumImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_InvalidDescriptorChecksumImpl>
    implements _$$DescriptorError_InvalidDescriptorChecksumImplCopyWith<$Res> {
  __$$DescriptorError_InvalidDescriptorChecksumImplCopyWithImpl(
      _$DescriptorError_InvalidDescriptorChecksumImpl _value,
      $Res Function(_$DescriptorError_InvalidDescriptorChecksumImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_InvalidDescriptorChecksumImpl
    extends DescriptorError_InvalidDescriptorChecksum {
  const _$DescriptorError_InvalidDescriptorChecksumImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.invalidDescriptorChecksum()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_InvalidDescriptorChecksumImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorChecksum();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorChecksum?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidDescriptorChecksum != null) {
      return invalidDescriptorChecksum();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorChecksum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorChecksum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidDescriptorChecksum != null) {
      return invalidDescriptorChecksum(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_InvalidDescriptorChecksum
    extends DescriptorError {
  const factory DescriptorError_InvalidDescriptorChecksum() =
      _$DescriptorError_InvalidDescriptorChecksumImpl;
  const DescriptorError_InvalidDescriptorChecksum._() : super._();
}

/// @nodoc
abstract class _$$DescriptorError_HardenedDerivationXpubImplCopyWith<$Res> {
  factory _$$DescriptorError_HardenedDerivationXpubImplCopyWith(
          _$DescriptorError_HardenedDerivationXpubImpl value,
          $Res Function(_$DescriptorError_HardenedDerivationXpubImpl) then) =
      __$$DescriptorError_HardenedDerivationXpubImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_HardenedDerivationXpubImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_HardenedDerivationXpubImpl>
    implements _$$DescriptorError_HardenedDerivationXpubImplCopyWith<$Res> {
  __$$DescriptorError_HardenedDerivationXpubImplCopyWithImpl(
      _$DescriptorError_HardenedDerivationXpubImpl _value,
      $Res Function(_$DescriptorError_HardenedDerivationXpubImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_HardenedDerivationXpubImpl
    extends DescriptorError_HardenedDerivationXpub {
  const _$DescriptorError_HardenedDerivationXpubImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.hardenedDerivationXpub()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_HardenedDerivationXpubImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return hardenedDerivationXpub();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return hardenedDerivationXpub?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (hardenedDerivationXpub != null) {
      return hardenedDerivationXpub();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return hardenedDerivationXpub(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return hardenedDerivationXpub?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (hardenedDerivationXpub != null) {
      return hardenedDerivationXpub(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_HardenedDerivationXpub extends DescriptorError {
  const factory DescriptorError_HardenedDerivationXpub() =
      _$DescriptorError_HardenedDerivationXpubImpl;
  const DescriptorError_HardenedDerivationXpub._() : super._();
}

/// @nodoc
abstract class _$$DescriptorError_MultiPathImplCopyWith<$Res> {
  factory _$$DescriptorError_MultiPathImplCopyWith(
          _$DescriptorError_MultiPathImpl value,
          $Res Function(_$DescriptorError_MultiPathImpl) then) =
      __$$DescriptorError_MultiPathImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_MultiPathImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_MultiPathImpl>
    implements _$$DescriptorError_MultiPathImplCopyWith<$Res> {
  __$$DescriptorError_MultiPathImplCopyWithImpl(
      _$DescriptorError_MultiPathImpl _value,
      $Res Function(_$DescriptorError_MultiPathImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_MultiPathImpl extends DescriptorError_MultiPath {
  const _$DescriptorError_MultiPathImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.multiPath()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_MultiPathImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return multiPath();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return multiPath?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (multiPath != null) {
      return multiPath();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return multiPath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return multiPath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (multiPath != null) {
      return multiPath(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_MultiPath extends DescriptorError {
  const factory DescriptorError_MultiPath() = _$DescriptorError_MultiPathImpl;
  const DescriptorError_MultiPath._() : super._();
}

/// @nodoc
abstract class _$$DescriptorError_KeyImplCopyWith<$Res> {
  factory _$$DescriptorError_KeyImplCopyWith(_$DescriptorError_KeyImpl value,
          $Res Function(_$DescriptorError_KeyImpl) then) =
      __$$DescriptorError_KeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_KeyImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_KeyImpl>
    implements _$$DescriptorError_KeyImplCopyWith<$Res> {
  __$$DescriptorError_KeyImplCopyWithImpl(_$DescriptorError_KeyImpl _value,
      $Res Function(_$DescriptorError_KeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_KeyImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_KeyImpl extends DescriptorError_Key {
  const _$DescriptorError_KeyImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.key(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_KeyImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_KeyImplCopyWith<_$DescriptorError_KeyImpl> get copyWith =>
      __$$DescriptorError_KeyImplCopyWithImpl<_$DescriptorError_KeyImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return key(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return key?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (key != null) {
      return key(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return key(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return key?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (key != null) {
      return key(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Key extends DescriptorError {
  const factory DescriptorError_Key({required final String errorMessage}) =
      _$DescriptorError_KeyImpl;
  const DescriptorError_Key._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_KeyImplCopyWith<_$DescriptorError_KeyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_GenericImplCopyWith<$Res> {
  factory _$$DescriptorError_GenericImplCopyWith(
          _$DescriptorError_GenericImpl value,
          $Res Function(_$DescriptorError_GenericImpl) then) =
      __$$DescriptorError_GenericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_GenericImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_GenericImpl>
    implements _$$DescriptorError_GenericImplCopyWith<$Res> {
  __$$DescriptorError_GenericImplCopyWithImpl(
      _$DescriptorError_GenericImpl _value,
      $Res Function(_$DescriptorError_GenericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_GenericImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_GenericImpl extends DescriptorError_Generic {
  const _$DescriptorError_GenericImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.generic(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_GenericImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_GenericImplCopyWith<_$DescriptorError_GenericImpl>
      get copyWith => __$$DescriptorError_GenericImplCopyWithImpl<
          _$DescriptorError_GenericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return generic(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return generic?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return generic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return generic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (generic != null) {
      return generic(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Generic extends DescriptorError {
  const factory DescriptorError_Generic({required final String errorMessage}) =
      _$DescriptorError_GenericImpl;
  const DescriptorError_Generic._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_GenericImplCopyWith<_$DescriptorError_GenericImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_PolicyImplCopyWith<$Res> {
  factory _$$DescriptorError_PolicyImplCopyWith(
          _$DescriptorError_PolicyImpl value,
          $Res Function(_$DescriptorError_PolicyImpl) then) =
      __$$DescriptorError_PolicyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_PolicyImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_PolicyImpl>
    implements _$$DescriptorError_PolicyImplCopyWith<$Res> {
  __$$DescriptorError_PolicyImplCopyWithImpl(
      _$DescriptorError_PolicyImpl _value,
      $Res Function(_$DescriptorError_PolicyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_PolicyImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_PolicyImpl extends DescriptorError_Policy {
  const _$DescriptorError_PolicyImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.policy(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_PolicyImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_PolicyImplCopyWith<_$DescriptorError_PolicyImpl>
      get copyWith => __$$DescriptorError_PolicyImplCopyWithImpl<
          _$DescriptorError_PolicyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return policy(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return policy?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (policy != null) {
      return policy(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return policy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return policy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (policy != null) {
      return policy(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Policy extends DescriptorError {
  const factory DescriptorError_Policy({required final String errorMessage}) =
      _$DescriptorError_PolicyImpl;
  const DescriptorError_Policy._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_PolicyImplCopyWith<_$DescriptorError_PolicyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_InvalidDescriptorCharacterImplCopyWith<$Res> {
  factory _$$DescriptorError_InvalidDescriptorCharacterImplCopyWith(
          _$DescriptorError_InvalidDescriptorCharacterImpl value,
          $Res Function(_$DescriptorError_InvalidDescriptorCharacterImpl)
              then) =
      __$$DescriptorError_InvalidDescriptorCharacterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String char});
}

/// @nodoc
class __$$DescriptorError_InvalidDescriptorCharacterImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_InvalidDescriptorCharacterImpl>
    implements _$$DescriptorError_InvalidDescriptorCharacterImplCopyWith<$Res> {
  __$$DescriptorError_InvalidDescriptorCharacterImplCopyWithImpl(
      _$DescriptorError_InvalidDescriptorCharacterImpl _value,
      $Res Function(_$DescriptorError_InvalidDescriptorCharacterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? char = null,
  }) {
    return _then(_$DescriptorError_InvalidDescriptorCharacterImpl(
      char: null == char
          ? _value.char
          : char // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_InvalidDescriptorCharacterImpl
    extends DescriptorError_InvalidDescriptorCharacter {
  const _$DescriptorError_InvalidDescriptorCharacterImpl({required this.char})
      : super._();

  @override
  final String char;

  @override
  String toString() {
    return 'DescriptorError.invalidDescriptorCharacter(char: $char)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_InvalidDescriptorCharacterImpl &&
            (identical(other.char, char) || other.char == char));
  }

  @override
  int get hashCode => Object.hash(runtimeType, char);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_InvalidDescriptorCharacterImplCopyWith<
          _$DescriptorError_InvalidDescriptorCharacterImpl>
      get copyWith =>
          __$$DescriptorError_InvalidDescriptorCharacterImplCopyWithImpl<
                  _$DescriptorError_InvalidDescriptorCharacterImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorCharacter(char);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorCharacter?.call(char);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidDescriptorCharacter != null) {
      return invalidDescriptorCharacter(char);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorCharacter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return invalidDescriptorCharacter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (invalidDescriptorCharacter != null) {
      return invalidDescriptorCharacter(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_InvalidDescriptorCharacter
    extends DescriptorError {
  const factory DescriptorError_InvalidDescriptorCharacter(
          {required final String char}) =
      _$DescriptorError_InvalidDescriptorCharacterImpl;
  const DescriptorError_InvalidDescriptorCharacter._() : super._();

  String get char;
  @JsonKey(ignore: true)
  _$$DescriptorError_InvalidDescriptorCharacterImplCopyWith<
          _$DescriptorError_InvalidDescriptorCharacterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_Bip32ImplCopyWith<$Res> {
  factory _$$DescriptorError_Bip32ImplCopyWith(
          _$DescriptorError_Bip32Impl value,
          $Res Function(_$DescriptorError_Bip32Impl) then) =
      __$$DescriptorError_Bip32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_Bip32ImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_Bip32Impl>
    implements _$$DescriptorError_Bip32ImplCopyWith<$Res> {
  __$$DescriptorError_Bip32ImplCopyWithImpl(_$DescriptorError_Bip32Impl _value,
      $Res Function(_$DescriptorError_Bip32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_Bip32Impl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_Bip32Impl extends DescriptorError_Bip32 {
  const _$DescriptorError_Bip32Impl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.bip32(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_Bip32Impl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_Bip32ImplCopyWith<_$DescriptorError_Bip32Impl>
      get copyWith => __$$DescriptorError_Bip32ImplCopyWithImpl<
          _$DescriptorError_Bip32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return bip32(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return bip32?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (bip32 != null) {
      return bip32(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return bip32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return bip32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (bip32 != null) {
      return bip32(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Bip32 extends DescriptorError {
  const factory DescriptorError_Bip32({required final String errorMessage}) =
      _$DescriptorError_Bip32Impl;
  const DescriptorError_Bip32._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_Bip32ImplCopyWith<_$DescriptorError_Bip32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_Base58ImplCopyWith<$Res> {
  factory _$$DescriptorError_Base58ImplCopyWith(
          _$DescriptorError_Base58Impl value,
          $Res Function(_$DescriptorError_Base58Impl) then) =
      __$$DescriptorError_Base58ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_Base58ImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_Base58Impl>
    implements _$$DescriptorError_Base58ImplCopyWith<$Res> {
  __$$DescriptorError_Base58ImplCopyWithImpl(
      _$DescriptorError_Base58Impl _value,
      $Res Function(_$DescriptorError_Base58Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_Base58Impl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_Base58Impl extends DescriptorError_Base58 {
  const _$DescriptorError_Base58Impl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.base58(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_Base58Impl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_Base58ImplCopyWith<_$DescriptorError_Base58Impl>
      get copyWith => __$$DescriptorError_Base58ImplCopyWithImpl<
          _$DescriptorError_Base58Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return base58(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return base58?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return base58(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return base58?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Base58 extends DescriptorError {
  const factory DescriptorError_Base58({required final String errorMessage}) =
      _$DescriptorError_Base58Impl;
  const DescriptorError_Base58._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_Base58ImplCopyWith<_$DescriptorError_Base58Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_PkImplCopyWith<$Res> {
  factory _$$DescriptorError_PkImplCopyWith(_$DescriptorError_PkImpl value,
          $Res Function(_$DescriptorError_PkImpl) then) =
      __$$DescriptorError_PkImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_PkImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_PkImpl>
    implements _$$DescriptorError_PkImplCopyWith<$Res> {
  __$$DescriptorError_PkImplCopyWithImpl(_$DescriptorError_PkImpl _value,
      $Res Function(_$DescriptorError_PkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_PkImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_PkImpl extends DescriptorError_Pk {
  const _$DescriptorError_PkImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.pk(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_PkImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_PkImplCopyWith<_$DescriptorError_PkImpl> get copyWith =>
      __$$DescriptorError_PkImplCopyWithImpl<_$DescriptorError_PkImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return pk(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return pk?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (pk != null) {
      return pk(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return pk(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return pk?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (pk != null) {
      return pk(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Pk extends DescriptorError {
  const factory DescriptorError_Pk({required final String errorMessage}) =
      _$DescriptorError_PkImpl;
  const DescriptorError_Pk._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_PkImplCopyWith<_$DescriptorError_PkImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_MiniscriptImplCopyWith<$Res> {
  factory _$$DescriptorError_MiniscriptImplCopyWith(
          _$DescriptorError_MiniscriptImpl value,
          $Res Function(_$DescriptorError_MiniscriptImpl) then) =
      __$$DescriptorError_MiniscriptImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_MiniscriptImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_MiniscriptImpl>
    implements _$$DescriptorError_MiniscriptImplCopyWith<$Res> {
  __$$DescriptorError_MiniscriptImplCopyWithImpl(
      _$DescriptorError_MiniscriptImpl _value,
      $Res Function(_$DescriptorError_MiniscriptImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_MiniscriptImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_MiniscriptImpl extends DescriptorError_Miniscript {
  const _$DescriptorError_MiniscriptImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.miniscript(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_MiniscriptImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_MiniscriptImplCopyWith<_$DescriptorError_MiniscriptImpl>
      get copyWith => __$$DescriptorError_MiniscriptImplCopyWithImpl<
          _$DescriptorError_MiniscriptImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return miniscript(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return miniscript?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (miniscript != null) {
      return miniscript(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return miniscript(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return miniscript?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (miniscript != null) {
      return miniscript(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Miniscript extends DescriptorError {
  const factory DescriptorError_Miniscript(
      {required final String errorMessage}) = _$DescriptorError_MiniscriptImpl;
  const DescriptorError_Miniscript._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_MiniscriptImplCopyWith<_$DescriptorError_MiniscriptImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_HexImplCopyWith<$Res> {
  factory _$$DescriptorError_HexImplCopyWith(_$DescriptorError_HexImpl value,
          $Res Function(_$DescriptorError_HexImpl) then) =
      __$$DescriptorError_HexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorError_HexImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res, _$DescriptorError_HexImpl>
    implements _$$DescriptorError_HexImplCopyWith<$Res> {
  __$$DescriptorError_HexImplCopyWithImpl(_$DescriptorError_HexImpl _value,
      $Res Function(_$DescriptorError_HexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorError_HexImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorError_HexImpl extends DescriptorError_Hex {
  const _$DescriptorError_HexImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorError.hex(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_HexImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorError_HexImplCopyWith<_$DescriptorError_HexImpl> get copyWith =>
      __$$DescriptorError_HexImplCopyWithImpl<_$DescriptorError_HexImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return hex(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return hex?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return hex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return hex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_Hex extends DescriptorError {
  const factory DescriptorError_Hex({required final String errorMessage}) =
      _$DescriptorError_HexImpl;
  const DescriptorError_Hex._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorError_HexImplCopyWith<_$DescriptorError_HexImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWith<
    $Res> {
  factory _$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWith(
          _$DescriptorError_ExternalAndInternalAreTheSameImpl value,
          $Res Function(_$DescriptorError_ExternalAndInternalAreTheSameImpl)
              then) =
      __$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWithImpl<$Res>
    extends _$DescriptorErrorCopyWithImpl<$Res,
        _$DescriptorError_ExternalAndInternalAreTheSameImpl>
    implements
        _$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWith<$Res> {
  __$$DescriptorError_ExternalAndInternalAreTheSameImplCopyWithImpl(
      _$DescriptorError_ExternalAndInternalAreTheSameImpl _value,
      $Res Function(_$DescriptorError_ExternalAndInternalAreTheSameImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorError_ExternalAndInternalAreTheSameImpl
    extends DescriptorError_ExternalAndInternalAreTheSame {
  const _$DescriptorError_ExternalAndInternalAreTheSameImpl() : super._();

  @override
  String toString() {
    return 'DescriptorError.externalAndInternalAreTheSame()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorError_ExternalAndInternalAreTheSameImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidHdKeyPath,
    required TResult Function() missingPrivateData,
    required TResult Function() invalidDescriptorChecksum,
    required TResult Function() hardenedDerivationXpub,
    required TResult Function() multiPath,
    required TResult Function(String errorMessage) key,
    required TResult Function(String errorMessage) generic,
    required TResult Function(String errorMessage) policy,
    required TResult Function(String char) invalidDescriptorCharacter,
    required TResult Function(String errorMessage) bip32,
    required TResult Function(String errorMessage) base58,
    required TResult Function(String errorMessage) pk,
    required TResult Function(String errorMessage) miniscript,
    required TResult Function(String errorMessage) hex,
    required TResult Function() externalAndInternalAreTheSame,
  }) {
    return externalAndInternalAreTheSame();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidHdKeyPath,
    TResult? Function()? missingPrivateData,
    TResult? Function()? invalidDescriptorChecksum,
    TResult? Function()? hardenedDerivationXpub,
    TResult? Function()? multiPath,
    TResult? Function(String errorMessage)? key,
    TResult? Function(String errorMessage)? generic,
    TResult? Function(String errorMessage)? policy,
    TResult? Function(String char)? invalidDescriptorCharacter,
    TResult? Function(String errorMessage)? bip32,
    TResult? Function(String errorMessage)? base58,
    TResult? Function(String errorMessage)? pk,
    TResult? Function(String errorMessage)? miniscript,
    TResult? Function(String errorMessage)? hex,
    TResult? Function()? externalAndInternalAreTheSame,
  }) {
    return externalAndInternalAreTheSame?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidHdKeyPath,
    TResult Function()? missingPrivateData,
    TResult Function()? invalidDescriptorChecksum,
    TResult Function()? hardenedDerivationXpub,
    TResult Function()? multiPath,
    TResult Function(String errorMessage)? key,
    TResult Function(String errorMessage)? generic,
    TResult Function(String errorMessage)? policy,
    TResult Function(String char)? invalidDescriptorCharacter,
    TResult Function(String errorMessage)? bip32,
    TResult Function(String errorMessage)? base58,
    TResult Function(String errorMessage)? pk,
    TResult Function(String errorMessage)? miniscript,
    TResult Function(String errorMessage)? hex,
    TResult Function()? externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (externalAndInternalAreTheSame != null) {
      return externalAndInternalAreTheSame();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorError_InvalidHdKeyPath value)
        invalidHdKeyPath,
    required TResult Function(DescriptorError_MissingPrivateData value)
        missingPrivateData,
    required TResult Function(DescriptorError_InvalidDescriptorChecksum value)
        invalidDescriptorChecksum,
    required TResult Function(DescriptorError_HardenedDerivationXpub value)
        hardenedDerivationXpub,
    required TResult Function(DescriptorError_MultiPath value) multiPath,
    required TResult Function(DescriptorError_Key value) key,
    required TResult Function(DescriptorError_Generic value) generic,
    required TResult Function(DescriptorError_Policy value) policy,
    required TResult Function(DescriptorError_InvalidDescriptorCharacter value)
        invalidDescriptorCharacter,
    required TResult Function(DescriptorError_Bip32 value) bip32,
    required TResult Function(DescriptorError_Base58 value) base58,
    required TResult Function(DescriptorError_Pk value) pk,
    required TResult Function(DescriptorError_Miniscript value) miniscript,
    required TResult Function(DescriptorError_Hex value) hex,
    required TResult Function(
            DescriptorError_ExternalAndInternalAreTheSame value)
        externalAndInternalAreTheSame,
  }) {
    return externalAndInternalAreTheSame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult? Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult? Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult? Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult? Function(DescriptorError_MultiPath value)? multiPath,
    TResult? Function(DescriptorError_Key value)? key,
    TResult? Function(DescriptorError_Generic value)? generic,
    TResult? Function(DescriptorError_Policy value)? policy,
    TResult? Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult? Function(DescriptorError_Bip32 value)? bip32,
    TResult? Function(DescriptorError_Base58 value)? base58,
    TResult? Function(DescriptorError_Pk value)? pk,
    TResult? Function(DescriptorError_Miniscript value)? miniscript,
    TResult? Function(DescriptorError_Hex value)? hex,
    TResult? Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
  }) {
    return externalAndInternalAreTheSame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorError_InvalidHdKeyPath value)? invalidHdKeyPath,
    TResult Function(DescriptorError_MissingPrivateData value)?
        missingPrivateData,
    TResult Function(DescriptorError_InvalidDescriptorChecksum value)?
        invalidDescriptorChecksum,
    TResult Function(DescriptorError_HardenedDerivationXpub value)?
        hardenedDerivationXpub,
    TResult Function(DescriptorError_MultiPath value)? multiPath,
    TResult Function(DescriptorError_Key value)? key,
    TResult Function(DescriptorError_Generic value)? generic,
    TResult Function(DescriptorError_Policy value)? policy,
    TResult Function(DescriptorError_InvalidDescriptorCharacter value)?
        invalidDescriptorCharacter,
    TResult Function(DescriptorError_Bip32 value)? bip32,
    TResult Function(DescriptorError_Base58 value)? base58,
    TResult Function(DescriptorError_Pk value)? pk,
    TResult Function(DescriptorError_Miniscript value)? miniscript,
    TResult Function(DescriptorError_Hex value)? hex,
    TResult Function(DescriptorError_ExternalAndInternalAreTheSame value)?
        externalAndInternalAreTheSame,
    required TResult orElse(),
  }) {
    if (externalAndInternalAreTheSame != null) {
      return externalAndInternalAreTheSame(this);
    }
    return orElse();
  }
}

abstract class DescriptorError_ExternalAndInternalAreTheSame
    extends DescriptorError {
  const factory DescriptorError_ExternalAndInternalAreTheSame() =
      _$DescriptorError_ExternalAndInternalAreTheSameImpl;
  const DescriptorError_ExternalAndInternalAreTheSame._() : super._();
}

/// @nodoc
mixin _$DescriptorKeyError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) parse,
    required TResult Function() invalidKeyType,
    required TResult Function(String errorMessage) bip32,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? parse,
    TResult? Function()? invalidKeyType,
    TResult? Function(String errorMessage)? bip32,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? parse,
    TResult Function()? invalidKeyType,
    TResult Function(String errorMessage)? bip32,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorKeyError_Parse value) parse,
    required TResult Function(DescriptorKeyError_InvalidKeyType value)
        invalidKeyType,
    required TResult Function(DescriptorKeyError_Bip32 value) bip32,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorKeyError_Parse value)? parse,
    TResult? Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult? Function(DescriptorKeyError_Bip32 value)? bip32,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorKeyError_Parse value)? parse,
    TResult Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult Function(DescriptorKeyError_Bip32 value)? bip32,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DescriptorKeyErrorCopyWith<$Res> {
  factory $DescriptorKeyErrorCopyWith(
          DescriptorKeyError value, $Res Function(DescriptorKeyError) then) =
      _$DescriptorKeyErrorCopyWithImpl<$Res, DescriptorKeyError>;
}

/// @nodoc
class _$DescriptorKeyErrorCopyWithImpl<$Res, $Val extends DescriptorKeyError>
    implements $DescriptorKeyErrorCopyWith<$Res> {
  _$DescriptorKeyErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DescriptorKeyError_ParseImplCopyWith<$Res> {
  factory _$$DescriptorKeyError_ParseImplCopyWith(
          _$DescriptorKeyError_ParseImpl value,
          $Res Function(_$DescriptorKeyError_ParseImpl) then) =
      __$$DescriptorKeyError_ParseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorKeyError_ParseImplCopyWithImpl<$Res>
    extends _$DescriptorKeyErrorCopyWithImpl<$Res,
        _$DescriptorKeyError_ParseImpl>
    implements _$$DescriptorKeyError_ParseImplCopyWith<$Res> {
  __$$DescriptorKeyError_ParseImplCopyWithImpl(
      _$DescriptorKeyError_ParseImpl _value,
      $Res Function(_$DescriptorKeyError_ParseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorKeyError_ParseImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorKeyError_ParseImpl extends DescriptorKeyError_Parse {
  const _$DescriptorKeyError_ParseImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorKeyError.parse(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorKeyError_ParseImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorKeyError_ParseImplCopyWith<_$DescriptorKeyError_ParseImpl>
      get copyWith => __$$DescriptorKeyError_ParseImplCopyWithImpl<
          _$DescriptorKeyError_ParseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) parse,
    required TResult Function() invalidKeyType,
    required TResult Function(String errorMessage) bip32,
  }) {
    return parse(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? parse,
    TResult? Function()? invalidKeyType,
    TResult? Function(String errorMessage)? bip32,
  }) {
    return parse?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? parse,
    TResult Function()? invalidKeyType,
    TResult Function(String errorMessage)? bip32,
    required TResult orElse(),
  }) {
    if (parse != null) {
      return parse(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorKeyError_Parse value) parse,
    required TResult Function(DescriptorKeyError_InvalidKeyType value)
        invalidKeyType,
    required TResult Function(DescriptorKeyError_Bip32 value) bip32,
  }) {
    return parse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorKeyError_Parse value)? parse,
    TResult? Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult? Function(DescriptorKeyError_Bip32 value)? bip32,
  }) {
    return parse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorKeyError_Parse value)? parse,
    TResult Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult Function(DescriptorKeyError_Bip32 value)? bip32,
    required TResult orElse(),
  }) {
    if (parse != null) {
      return parse(this);
    }
    return orElse();
  }
}

abstract class DescriptorKeyError_Parse extends DescriptorKeyError {
  const factory DescriptorKeyError_Parse({required final String errorMessage}) =
      _$DescriptorKeyError_ParseImpl;
  const DescriptorKeyError_Parse._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorKeyError_ParseImplCopyWith<_$DescriptorKeyError_ParseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DescriptorKeyError_InvalidKeyTypeImplCopyWith<$Res> {
  factory _$$DescriptorKeyError_InvalidKeyTypeImplCopyWith(
          _$DescriptorKeyError_InvalidKeyTypeImpl value,
          $Res Function(_$DescriptorKeyError_InvalidKeyTypeImpl) then) =
      __$$DescriptorKeyError_InvalidKeyTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DescriptorKeyError_InvalidKeyTypeImplCopyWithImpl<$Res>
    extends _$DescriptorKeyErrorCopyWithImpl<$Res,
        _$DescriptorKeyError_InvalidKeyTypeImpl>
    implements _$$DescriptorKeyError_InvalidKeyTypeImplCopyWith<$Res> {
  __$$DescriptorKeyError_InvalidKeyTypeImplCopyWithImpl(
      _$DescriptorKeyError_InvalidKeyTypeImpl _value,
      $Res Function(_$DescriptorKeyError_InvalidKeyTypeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DescriptorKeyError_InvalidKeyTypeImpl
    extends DescriptorKeyError_InvalidKeyType {
  const _$DescriptorKeyError_InvalidKeyTypeImpl() : super._();

  @override
  String toString() {
    return 'DescriptorKeyError.invalidKeyType()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorKeyError_InvalidKeyTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) parse,
    required TResult Function() invalidKeyType,
    required TResult Function(String errorMessage) bip32,
  }) {
    return invalidKeyType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? parse,
    TResult? Function()? invalidKeyType,
    TResult? Function(String errorMessage)? bip32,
  }) {
    return invalidKeyType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? parse,
    TResult Function()? invalidKeyType,
    TResult Function(String errorMessage)? bip32,
    required TResult orElse(),
  }) {
    if (invalidKeyType != null) {
      return invalidKeyType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorKeyError_Parse value) parse,
    required TResult Function(DescriptorKeyError_InvalidKeyType value)
        invalidKeyType,
    required TResult Function(DescriptorKeyError_Bip32 value) bip32,
  }) {
    return invalidKeyType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorKeyError_Parse value)? parse,
    TResult? Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult? Function(DescriptorKeyError_Bip32 value)? bip32,
  }) {
    return invalidKeyType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorKeyError_Parse value)? parse,
    TResult Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult Function(DescriptorKeyError_Bip32 value)? bip32,
    required TResult orElse(),
  }) {
    if (invalidKeyType != null) {
      return invalidKeyType(this);
    }
    return orElse();
  }
}

abstract class DescriptorKeyError_InvalidKeyType extends DescriptorKeyError {
  const factory DescriptorKeyError_InvalidKeyType() =
      _$DescriptorKeyError_InvalidKeyTypeImpl;
  const DescriptorKeyError_InvalidKeyType._() : super._();
}

/// @nodoc
abstract class _$$DescriptorKeyError_Bip32ImplCopyWith<$Res> {
  factory _$$DescriptorKeyError_Bip32ImplCopyWith(
          _$DescriptorKeyError_Bip32Impl value,
          $Res Function(_$DescriptorKeyError_Bip32Impl) then) =
      __$$DescriptorKeyError_Bip32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$DescriptorKeyError_Bip32ImplCopyWithImpl<$Res>
    extends _$DescriptorKeyErrorCopyWithImpl<$Res,
        _$DescriptorKeyError_Bip32Impl>
    implements _$$DescriptorKeyError_Bip32ImplCopyWith<$Res> {
  __$$DescriptorKeyError_Bip32ImplCopyWithImpl(
      _$DescriptorKeyError_Bip32Impl _value,
      $Res Function(_$DescriptorKeyError_Bip32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$DescriptorKeyError_Bip32Impl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DescriptorKeyError_Bip32Impl extends DescriptorKeyError_Bip32 {
  const _$DescriptorKeyError_Bip32Impl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'DescriptorKeyError.bip32(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DescriptorKeyError_Bip32Impl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DescriptorKeyError_Bip32ImplCopyWith<_$DescriptorKeyError_Bip32Impl>
      get copyWith => __$$DescriptorKeyError_Bip32ImplCopyWithImpl<
          _$DescriptorKeyError_Bip32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) parse,
    required TResult Function() invalidKeyType,
    required TResult Function(String errorMessage) bip32,
  }) {
    return bip32(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? parse,
    TResult? Function()? invalidKeyType,
    TResult? Function(String errorMessage)? bip32,
  }) {
    return bip32?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? parse,
    TResult Function()? invalidKeyType,
    TResult Function(String errorMessage)? bip32,
    required TResult orElse(),
  }) {
    if (bip32 != null) {
      return bip32(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DescriptorKeyError_Parse value) parse,
    required TResult Function(DescriptorKeyError_InvalidKeyType value)
        invalidKeyType,
    required TResult Function(DescriptorKeyError_Bip32 value) bip32,
  }) {
    return bip32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DescriptorKeyError_Parse value)? parse,
    TResult? Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult? Function(DescriptorKeyError_Bip32 value)? bip32,
  }) {
    return bip32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DescriptorKeyError_Parse value)? parse,
    TResult Function(DescriptorKeyError_InvalidKeyType value)? invalidKeyType,
    TResult Function(DescriptorKeyError_Bip32 value)? bip32,
    required TResult orElse(),
  }) {
    if (bip32 != null) {
      return bip32(this);
    }
    return orElse();
  }
}

abstract class DescriptorKeyError_Bip32 extends DescriptorKeyError {
  const factory DescriptorKeyError_Bip32({required final String errorMessage}) =
      _$DescriptorKeyError_Bip32Impl;
  const DescriptorKeyError_Bip32._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$DescriptorKeyError_Bip32ImplCopyWith<_$DescriptorKeyError_Bip32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ElectrumError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ElectrumErrorCopyWith<$Res> {
  factory $ElectrumErrorCopyWith(
          ElectrumError value, $Res Function(ElectrumError) then) =
      _$ElectrumErrorCopyWithImpl<$Res, ElectrumError>;
}

/// @nodoc
class _$ElectrumErrorCopyWithImpl<$Res, $Val extends ElectrumError>
    implements $ElectrumErrorCopyWith<$Res> {
  _$ElectrumErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ElectrumError_IOErrorImplCopyWith<$Res> {
  factory _$$ElectrumError_IOErrorImplCopyWith(
          _$ElectrumError_IOErrorImpl value,
          $Res Function(_$ElectrumError_IOErrorImpl) then) =
      __$$ElectrumError_IOErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_IOErrorImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_IOErrorImpl>
    implements _$$ElectrumError_IOErrorImplCopyWith<$Res> {
  __$$ElectrumError_IOErrorImplCopyWithImpl(_$ElectrumError_IOErrorImpl _value,
      $Res Function(_$ElectrumError_IOErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_IOErrorImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_IOErrorImpl extends ElectrumError_IOError {
  const _$ElectrumError_IOErrorImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.ioError(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_IOErrorImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_IOErrorImplCopyWith<_$ElectrumError_IOErrorImpl>
      get copyWith => __$$ElectrumError_IOErrorImplCopyWithImpl<
          _$ElectrumError_IOErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return ioError(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return ioError?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (ioError != null) {
      return ioError(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return ioError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return ioError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (ioError != null) {
      return ioError(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_IOError extends ElectrumError {
  const factory ElectrumError_IOError({required final String errorMessage}) =
      _$ElectrumError_IOErrorImpl;
  const ElectrumError_IOError._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_IOErrorImplCopyWith<_$ElectrumError_IOErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_JsonImplCopyWith<$Res> {
  factory _$$ElectrumError_JsonImplCopyWith(_$ElectrumError_JsonImpl value,
          $Res Function(_$ElectrumError_JsonImpl) then) =
      __$$ElectrumError_JsonImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_JsonImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_JsonImpl>
    implements _$$ElectrumError_JsonImplCopyWith<$Res> {
  __$$ElectrumError_JsonImplCopyWithImpl(_$ElectrumError_JsonImpl _value,
      $Res Function(_$ElectrumError_JsonImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_JsonImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_JsonImpl extends ElectrumError_Json {
  const _$ElectrumError_JsonImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.json(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_JsonImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_JsonImplCopyWith<_$ElectrumError_JsonImpl> get copyWith =>
      __$$ElectrumError_JsonImplCopyWithImpl<_$ElectrumError_JsonImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return json(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return json?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return json(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return json?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Json extends ElectrumError {
  const factory ElectrumError_Json({required final String errorMessage}) =
      _$ElectrumError_JsonImpl;
  const ElectrumError_Json._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_JsonImplCopyWith<_$ElectrumError_JsonImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_HexImplCopyWith<$Res> {
  factory _$$ElectrumError_HexImplCopyWith(_$ElectrumError_HexImpl value,
          $Res Function(_$ElectrumError_HexImpl) then) =
      __$$ElectrumError_HexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_HexImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_HexImpl>
    implements _$$ElectrumError_HexImplCopyWith<$Res> {
  __$$ElectrumError_HexImplCopyWithImpl(_$ElectrumError_HexImpl _value,
      $Res Function(_$ElectrumError_HexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_HexImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_HexImpl extends ElectrumError_Hex {
  const _$ElectrumError_HexImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.hex(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_HexImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_HexImplCopyWith<_$ElectrumError_HexImpl> get copyWith =>
      __$$ElectrumError_HexImplCopyWithImpl<_$ElectrumError_HexImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return hex(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return hex?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return hex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return hex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hex != null) {
      return hex(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Hex extends ElectrumError {
  const factory ElectrumError_Hex({required final String errorMessage}) =
      _$ElectrumError_HexImpl;
  const ElectrumError_Hex._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_HexImplCopyWith<_$ElectrumError_HexImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_ProtocolImplCopyWith<$Res> {
  factory _$$ElectrumError_ProtocolImplCopyWith(
          _$ElectrumError_ProtocolImpl value,
          $Res Function(_$ElectrumError_ProtocolImpl) then) =
      __$$ElectrumError_ProtocolImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_ProtocolImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_ProtocolImpl>
    implements _$$ElectrumError_ProtocolImplCopyWith<$Res> {
  __$$ElectrumError_ProtocolImplCopyWithImpl(
      _$ElectrumError_ProtocolImpl _value,
      $Res Function(_$ElectrumError_ProtocolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_ProtocolImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_ProtocolImpl extends ElectrumError_Protocol {
  const _$ElectrumError_ProtocolImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.protocol(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_ProtocolImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_ProtocolImplCopyWith<_$ElectrumError_ProtocolImpl>
      get copyWith => __$$ElectrumError_ProtocolImplCopyWithImpl<
          _$ElectrumError_ProtocolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return protocol(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return protocol?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (protocol != null) {
      return protocol(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return protocol(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return protocol?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (protocol != null) {
      return protocol(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Protocol extends ElectrumError {
  const factory ElectrumError_Protocol({required final String errorMessage}) =
      _$ElectrumError_ProtocolImpl;
  const ElectrumError_Protocol._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_ProtocolImplCopyWith<_$ElectrumError_ProtocolImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_BitcoinImplCopyWith<$Res> {
  factory _$$ElectrumError_BitcoinImplCopyWith(
          _$ElectrumError_BitcoinImpl value,
          $Res Function(_$ElectrumError_BitcoinImpl) then) =
      __$$ElectrumError_BitcoinImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_BitcoinImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_BitcoinImpl>
    implements _$$ElectrumError_BitcoinImplCopyWith<$Res> {
  __$$ElectrumError_BitcoinImplCopyWithImpl(_$ElectrumError_BitcoinImpl _value,
      $Res Function(_$ElectrumError_BitcoinImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_BitcoinImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_BitcoinImpl extends ElectrumError_Bitcoin {
  const _$ElectrumError_BitcoinImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.bitcoin(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_BitcoinImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_BitcoinImplCopyWith<_$ElectrumError_BitcoinImpl>
      get copyWith => __$$ElectrumError_BitcoinImplCopyWithImpl<
          _$ElectrumError_BitcoinImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return bitcoin(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return bitcoin?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (bitcoin != null) {
      return bitcoin(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return bitcoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return bitcoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (bitcoin != null) {
      return bitcoin(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Bitcoin extends ElectrumError {
  const factory ElectrumError_Bitcoin({required final String errorMessage}) =
      _$ElectrumError_BitcoinImpl;
  const ElectrumError_Bitcoin._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_BitcoinImplCopyWith<_$ElectrumError_BitcoinImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_AlreadySubscribedImplCopyWith<$Res> {
  factory _$$ElectrumError_AlreadySubscribedImplCopyWith(
          _$ElectrumError_AlreadySubscribedImpl value,
          $Res Function(_$ElectrumError_AlreadySubscribedImpl) then) =
      __$$ElectrumError_AlreadySubscribedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_AlreadySubscribedImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_AlreadySubscribedImpl>
    implements _$$ElectrumError_AlreadySubscribedImplCopyWith<$Res> {
  __$$ElectrumError_AlreadySubscribedImplCopyWithImpl(
      _$ElectrumError_AlreadySubscribedImpl _value,
      $Res Function(_$ElectrumError_AlreadySubscribedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_AlreadySubscribedImpl
    extends ElectrumError_AlreadySubscribed {
  const _$ElectrumError_AlreadySubscribedImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.alreadySubscribed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_AlreadySubscribedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return alreadySubscribed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return alreadySubscribed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (alreadySubscribed != null) {
      return alreadySubscribed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return alreadySubscribed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return alreadySubscribed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (alreadySubscribed != null) {
      return alreadySubscribed(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_AlreadySubscribed extends ElectrumError {
  const factory ElectrumError_AlreadySubscribed() =
      _$ElectrumError_AlreadySubscribedImpl;
  const ElectrumError_AlreadySubscribed._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_NotSubscribedImplCopyWith<$Res> {
  factory _$$ElectrumError_NotSubscribedImplCopyWith(
          _$ElectrumError_NotSubscribedImpl value,
          $Res Function(_$ElectrumError_NotSubscribedImpl) then) =
      __$$ElectrumError_NotSubscribedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_NotSubscribedImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_NotSubscribedImpl>
    implements _$$ElectrumError_NotSubscribedImplCopyWith<$Res> {
  __$$ElectrumError_NotSubscribedImplCopyWithImpl(
      _$ElectrumError_NotSubscribedImpl _value,
      $Res Function(_$ElectrumError_NotSubscribedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_NotSubscribedImpl extends ElectrumError_NotSubscribed {
  const _$ElectrumError_NotSubscribedImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.notSubscribed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_NotSubscribedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return notSubscribed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return notSubscribed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (notSubscribed != null) {
      return notSubscribed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return notSubscribed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return notSubscribed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (notSubscribed != null) {
      return notSubscribed(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_NotSubscribed extends ElectrumError {
  const factory ElectrumError_NotSubscribed() =
      _$ElectrumError_NotSubscribedImpl;
  const ElectrumError_NotSubscribed._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_InvalidResponseImplCopyWith<$Res> {
  factory _$$ElectrumError_InvalidResponseImplCopyWith(
          _$ElectrumError_InvalidResponseImpl value,
          $Res Function(_$ElectrumError_InvalidResponseImpl) then) =
      __$$ElectrumError_InvalidResponseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_InvalidResponseImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_InvalidResponseImpl>
    implements _$$ElectrumError_InvalidResponseImplCopyWith<$Res> {
  __$$ElectrumError_InvalidResponseImplCopyWithImpl(
      _$ElectrumError_InvalidResponseImpl _value,
      $Res Function(_$ElectrumError_InvalidResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_InvalidResponseImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_InvalidResponseImpl
    extends ElectrumError_InvalidResponse {
  const _$ElectrumError_InvalidResponseImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.invalidResponse(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_InvalidResponseImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_InvalidResponseImplCopyWith<
          _$ElectrumError_InvalidResponseImpl>
      get copyWith => __$$ElectrumError_InvalidResponseImplCopyWithImpl<
          _$ElectrumError_InvalidResponseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return invalidResponse(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return invalidResponse?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidResponse != null) {
      return invalidResponse(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return invalidResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return invalidResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidResponse != null) {
      return invalidResponse(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_InvalidResponse extends ElectrumError {
  const factory ElectrumError_InvalidResponse(
          {required final String errorMessage}) =
      _$ElectrumError_InvalidResponseImpl;
  const ElectrumError_InvalidResponse._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_InvalidResponseImplCopyWith<
          _$ElectrumError_InvalidResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_MessageImplCopyWith<$Res> {
  factory _$$ElectrumError_MessageImplCopyWith(
          _$ElectrumError_MessageImpl value,
          $Res Function(_$ElectrumError_MessageImpl) then) =
      __$$ElectrumError_MessageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_MessageImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_MessageImpl>
    implements _$$ElectrumError_MessageImplCopyWith<$Res> {
  __$$ElectrumError_MessageImplCopyWithImpl(_$ElectrumError_MessageImpl _value,
      $Res Function(_$ElectrumError_MessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_MessageImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_MessageImpl extends ElectrumError_Message {
  const _$ElectrumError_MessageImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.message(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_MessageImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_MessageImplCopyWith<_$ElectrumError_MessageImpl>
      get copyWith => __$$ElectrumError_MessageImplCopyWithImpl<
          _$ElectrumError_MessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return message(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return message?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return message(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return message?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Message extends ElectrumError {
  const factory ElectrumError_Message({required final String errorMessage}) =
      _$ElectrumError_MessageImpl;
  const ElectrumError_Message._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_MessageImplCopyWith<_$ElectrumError_MessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_InvalidDNSNameErrorImplCopyWith<$Res> {
  factory _$$ElectrumError_InvalidDNSNameErrorImplCopyWith(
          _$ElectrumError_InvalidDNSNameErrorImpl value,
          $Res Function(_$ElectrumError_InvalidDNSNameErrorImpl) then) =
      __$$ElectrumError_InvalidDNSNameErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String domain});
}

/// @nodoc
class __$$ElectrumError_InvalidDNSNameErrorImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_InvalidDNSNameErrorImpl>
    implements _$$ElectrumError_InvalidDNSNameErrorImplCopyWith<$Res> {
  __$$ElectrumError_InvalidDNSNameErrorImplCopyWithImpl(
      _$ElectrumError_InvalidDNSNameErrorImpl _value,
      $Res Function(_$ElectrumError_InvalidDNSNameErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? domain = null,
  }) {
    return _then(_$ElectrumError_InvalidDNSNameErrorImpl(
      domain: null == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_InvalidDNSNameErrorImpl
    extends ElectrumError_InvalidDNSNameError {
  const _$ElectrumError_InvalidDNSNameErrorImpl({required this.domain})
      : super._();

  @override
  final String domain;

  @override
  String toString() {
    return 'ElectrumError.invalidDnsNameError(domain: $domain)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_InvalidDNSNameErrorImpl &&
            (identical(other.domain, domain) || other.domain == domain));
  }

  @override
  int get hashCode => Object.hash(runtimeType, domain);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_InvalidDNSNameErrorImplCopyWith<
          _$ElectrumError_InvalidDNSNameErrorImpl>
      get copyWith => __$$ElectrumError_InvalidDNSNameErrorImplCopyWithImpl<
          _$ElectrumError_InvalidDNSNameErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return invalidDnsNameError(domain);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return invalidDnsNameError?.call(domain);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidDnsNameError != null) {
      return invalidDnsNameError(domain);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return invalidDnsNameError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return invalidDnsNameError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidDnsNameError != null) {
      return invalidDnsNameError(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_InvalidDNSNameError extends ElectrumError {
  const factory ElectrumError_InvalidDNSNameError(
      {required final String domain}) = _$ElectrumError_InvalidDNSNameErrorImpl;
  const ElectrumError_InvalidDNSNameError._() : super._();

  String get domain;
  @JsonKey(ignore: true)
  _$$ElectrumError_InvalidDNSNameErrorImplCopyWith<
          _$ElectrumError_InvalidDNSNameErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_MissingDomainImplCopyWith<$Res> {
  factory _$$ElectrumError_MissingDomainImplCopyWith(
          _$ElectrumError_MissingDomainImpl value,
          $Res Function(_$ElectrumError_MissingDomainImpl) then) =
      __$$ElectrumError_MissingDomainImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_MissingDomainImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_MissingDomainImpl>
    implements _$$ElectrumError_MissingDomainImplCopyWith<$Res> {
  __$$ElectrumError_MissingDomainImplCopyWithImpl(
      _$ElectrumError_MissingDomainImpl _value,
      $Res Function(_$ElectrumError_MissingDomainImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_MissingDomainImpl extends ElectrumError_MissingDomain {
  const _$ElectrumError_MissingDomainImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.missingDomain()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_MissingDomainImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return missingDomain();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return missingDomain?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (missingDomain != null) {
      return missingDomain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return missingDomain(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return missingDomain?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (missingDomain != null) {
      return missingDomain(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_MissingDomain extends ElectrumError {
  const factory ElectrumError_MissingDomain() =
      _$ElectrumError_MissingDomainImpl;
  const ElectrumError_MissingDomain._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_AllAttemptsErroredImplCopyWith<$Res> {
  factory _$$ElectrumError_AllAttemptsErroredImplCopyWith(
          _$ElectrumError_AllAttemptsErroredImpl value,
          $Res Function(_$ElectrumError_AllAttemptsErroredImpl) then) =
      __$$ElectrumError_AllAttemptsErroredImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_AllAttemptsErroredImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_AllAttemptsErroredImpl>
    implements _$$ElectrumError_AllAttemptsErroredImplCopyWith<$Res> {
  __$$ElectrumError_AllAttemptsErroredImplCopyWithImpl(
      _$ElectrumError_AllAttemptsErroredImpl _value,
      $Res Function(_$ElectrumError_AllAttemptsErroredImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_AllAttemptsErroredImpl
    extends ElectrumError_AllAttemptsErrored {
  const _$ElectrumError_AllAttemptsErroredImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.allAttemptsErrored()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_AllAttemptsErroredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return allAttemptsErrored();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return allAttemptsErrored?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (allAttemptsErrored != null) {
      return allAttemptsErrored();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return allAttemptsErrored(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return allAttemptsErrored?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (allAttemptsErrored != null) {
      return allAttemptsErrored(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_AllAttemptsErrored extends ElectrumError {
  const factory ElectrumError_AllAttemptsErrored() =
      _$ElectrumError_AllAttemptsErroredImpl;
  const ElectrumError_AllAttemptsErrored._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_SharedIOErrorImplCopyWith<$Res> {
  factory _$$ElectrumError_SharedIOErrorImplCopyWith(
          _$ElectrumError_SharedIOErrorImpl value,
          $Res Function(_$ElectrumError_SharedIOErrorImpl) then) =
      __$$ElectrumError_SharedIOErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_SharedIOErrorImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_SharedIOErrorImpl>
    implements _$$ElectrumError_SharedIOErrorImplCopyWith<$Res> {
  __$$ElectrumError_SharedIOErrorImplCopyWithImpl(
      _$ElectrumError_SharedIOErrorImpl _value,
      $Res Function(_$ElectrumError_SharedIOErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_SharedIOErrorImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_SharedIOErrorImpl extends ElectrumError_SharedIOError {
  const _$ElectrumError_SharedIOErrorImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.sharedIoError(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_SharedIOErrorImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_SharedIOErrorImplCopyWith<_$ElectrumError_SharedIOErrorImpl>
      get copyWith => __$$ElectrumError_SharedIOErrorImplCopyWithImpl<
          _$ElectrumError_SharedIOErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return sharedIoError(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return sharedIoError?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (sharedIoError != null) {
      return sharedIoError(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return sharedIoError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return sharedIoError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (sharedIoError != null) {
      return sharedIoError(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_SharedIOError extends ElectrumError {
  const factory ElectrumError_SharedIOError(
      {required final String errorMessage}) = _$ElectrumError_SharedIOErrorImpl;
  const ElectrumError_SharedIOError._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_SharedIOErrorImplCopyWith<_$ElectrumError_SharedIOErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_CouldntLockReaderImplCopyWith<$Res> {
  factory _$$ElectrumError_CouldntLockReaderImplCopyWith(
          _$ElectrumError_CouldntLockReaderImpl value,
          $Res Function(_$ElectrumError_CouldntLockReaderImpl) then) =
      __$$ElectrumError_CouldntLockReaderImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_CouldntLockReaderImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_CouldntLockReaderImpl>
    implements _$$ElectrumError_CouldntLockReaderImplCopyWith<$Res> {
  __$$ElectrumError_CouldntLockReaderImplCopyWithImpl(
      _$ElectrumError_CouldntLockReaderImpl _value,
      $Res Function(_$ElectrumError_CouldntLockReaderImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_CouldntLockReaderImpl
    extends ElectrumError_CouldntLockReader {
  const _$ElectrumError_CouldntLockReaderImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.couldntLockReader()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_CouldntLockReaderImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return couldntLockReader();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return couldntLockReader?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (couldntLockReader != null) {
      return couldntLockReader();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return couldntLockReader(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return couldntLockReader?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (couldntLockReader != null) {
      return couldntLockReader(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_CouldntLockReader extends ElectrumError {
  const factory ElectrumError_CouldntLockReader() =
      _$ElectrumError_CouldntLockReaderImpl;
  const ElectrumError_CouldntLockReader._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_MpscImplCopyWith<$Res> {
  factory _$$ElectrumError_MpscImplCopyWith(_$ElectrumError_MpscImpl value,
          $Res Function(_$ElectrumError_MpscImpl) then) =
      __$$ElectrumError_MpscImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_MpscImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res, _$ElectrumError_MpscImpl>
    implements _$$ElectrumError_MpscImplCopyWith<$Res> {
  __$$ElectrumError_MpscImplCopyWithImpl(_$ElectrumError_MpscImpl _value,
      $Res Function(_$ElectrumError_MpscImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_MpscImpl extends ElectrumError_Mpsc {
  const _$ElectrumError_MpscImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.mpsc()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ElectrumError_MpscImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return mpsc();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return mpsc?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (mpsc != null) {
      return mpsc();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return mpsc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return mpsc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (mpsc != null) {
      return mpsc(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_Mpsc extends ElectrumError {
  const factory ElectrumError_Mpsc() = _$ElectrumError_MpscImpl;
  const ElectrumError_Mpsc._() : super._();
}

/// @nodoc
abstract class _$$ElectrumError_CouldNotCreateConnectionImplCopyWith<$Res> {
  factory _$$ElectrumError_CouldNotCreateConnectionImplCopyWith(
          _$ElectrumError_CouldNotCreateConnectionImpl value,
          $Res Function(_$ElectrumError_CouldNotCreateConnectionImpl) then) =
      __$$ElectrumError_CouldNotCreateConnectionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$ElectrumError_CouldNotCreateConnectionImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_CouldNotCreateConnectionImpl>
    implements _$$ElectrumError_CouldNotCreateConnectionImplCopyWith<$Res> {
  __$$ElectrumError_CouldNotCreateConnectionImplCopyWithImpl(
      _$ElectrumError_CouldNotCreateConnectionImpl _value,
      $Res Function(_$ElectrumError_CouldNotCreateConnectionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$ElectrumError_CouldNotCreateConnectionImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ElectrumError_CouldNotCreateConnectionImpl
    extends ElectrumError_CouldNotCreateConnection {
  const _$ElectrumError_CouldNotCreateConnectionImpl(
      {required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'ElectrumError.couldNotCreateConnection(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_CouldNotCreateConnectionImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ElectrumError_CouldNotCreateConnectionImplCopyWith<
          _$ElectrumError_CouldNotCreateConnectionImpl>
      get copyWith =>
          __$$ElectrumError_CouldNotCreateConnectionImplCopyWithImpl<
              _$ElectrumError_CouldNotCreateConnectionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return couldNotCreateConnection(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return couldNotCreateConnection?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (couldNotCreateConnection != null) {
      return couldNotCreateConnection(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return couldNotCreateConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return couldNotCreateConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (couldNotCreateConnection != null) {
      return couldNotCreateConnection(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_CouldNotCreateConnection extends ElectrumError {
  const factory ElectrumError_CouldNotCreateConnection(
          {required final String errorMessage}) =
      _$ElectrumError_CouldNotCreateConnectionImpl;
  const ElectrumError_CouldNotCreateConnection._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$ElectrumError_CouldNotCreateConnectionImplCopyWith<
          _$ElectrumError_CouldNotCreateConnectionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ElectrumError_RequestAlreadyConsumedImplCopyWith<$Res> {
  factory _$$ElectrumError_RequestAlreadyConsumedImplCopyWith(
          _$ElectrumError_RequestAlreadyConsumedImpl value,
          $Res Function(_$ElectrumError_RequestAlreadyConsumedImpl) then) =
      __$$ElectrumError_RequestAlreadyConsumedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectrumError_RequestAlreadyConsumedImplCopyWithImpl<$Res>
    extends _$ElectrumErrorCopyWithImpl<$Res,
        _$ElectrumError_RequestAlreadyConsumedImpl>
    implements _$$ElectrumError_RequestAlreadyConsumedImplCopyWith<$Res> {
  __$$ElectrumError_RequestAlreadyConsumedImplCopyWithImpl(
      _$ElectrumError_RequestAlreadyConsumedImpl _value,
      $Res Function(_$ElectrumError_RequestAlreadyConsumedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ElectrumError_RequestAlreadyConsumedImpl
    extends ElectrumError_RequestAlreadyConsumed {
  const _$ElectrumError_RequestAlreadyConsumedImpl() : super._();

  @override
  String toString() {
    return 'ElectrumError.requestAlreadyConsumed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectrumError_RequestAlreadyConsumedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) ioError,
    required TResult Function(String errorMessage) json,
    required TResult Function(String errorMessage) hex,
    required TResult Function(String errorMessage) protocol,
    required TResult Function(String errorMessage) bitcoin,
    required TResult Function() alreadySubscribed,
    required TResult Function() notSubscribed,
    required TResult Function(String errorMessage) invalidResponse,
    required TResult Function(String errorMessage) message,
    required TResult Function(String domain) invalidDnsNameError,
    required TResult Function() missingDomain,
    required TResult Function() allAttemptsErrored,
    required TResult Function(String errorMessage) sharedIoError,
    required TResult Function() couldntLockReader,
    required TResult Function() mpsc,
    required TResult Function(String errorMessage) couldNotCreateConnection,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? ioError,
    TResult? Function(String errorMessage)? json,
    TResult? Function(String errorMessage)? hex,
    TResult? Function(String errorMessage)? protocol,
    TResult? Function(String errorMessage)? bitcoin,
    TResult? Function()? alreadySubscribed,
    TResult? Function()? notSubscribed,
    TResult? Function(String errorMessage)? invalidResponse,
    TResult? Function(String errorMessage)? message,
    TResult? Function(String domain)? invalidDnsNameError,
    TResult? Function()? missingDomain,
    TResult? Function()? allAttemptsErrored,
    TResult? Function(String errorMessage)? sharedIoError,
    TResult? Function()? couldntLockReader,
    TResult? Function()? mpsc,
    TResult? Function(String errorMessage)? couldNotCreateConnection,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? ioError,
    TResult Function(String errorMessage)? json,
    TResult Function(String errorMessage)? hex,
    TResult Function(String errorMessage)? protocol,
    TResult Function(String errorMessage)? bitcoin,
    TResult Function()? alreadySubscribed,
    TResult Function()? notSubscribed,
    TResult Function(String errorMessage)? invalidResponse,
    TResult Function(String errorMessage)? message,
    TResult Function(String domain)? invalidDnsNameError,
    TResult Function()? missingDomain,
    TResult Function()? allAttemptsErrored,
    TResult Function(String errorMessage)? sharedIoError,
    TResult Function()? couldntLockReader,
    TResult Function()? mpsc,
    TResult Function(String errorMessage)? couldNotCreateConnection,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (requestAlreadyConsumed != null) {
      return requestAlreadyConsumed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ElectrumError_IOError value) ioError,
    required TResult Function(ElectrumError_Json value) json,
    required TResult Function(ElectrumError_Hex value) hex,
    required TResult Function(ElectrumError_Protocol value) protocol,
    required TResult Function(ElectrumError_Bitcoin value) bitcoin,
    required TResult Function(ElectrumError_AlreadySubscribed value)
        alreadySubscribed,
    required TResult Function(ElectrumError_NotSubscribed value) notSubscribed,
    required TResult Function(ElectrumError_InvalidResponse value)
        invalidResponse,
    required TResult Function(ElectrumError_Message value) message,
    required TResult Function(ElectrumError_InvalidDNSNameError value)
        invalidDnsNameError,
    required TResult Function(ElectrumError_MissingDomain value) missingDomain,
    required TResult Function(ElectrumError_AllAttemptsErrored value)
        allAttemptsErrored,
    required TResult Function(ElectrumError_SharedIOError value) sharedIoError,
    required TResult Function(ElectrumError_CouldntLockReader value)
        couldntLockReader,
    required TResult Function(ElectrumError_Mpsc value) mpsc,
    required TResult Function(ElectrumError_CouldNotCreateConnection value)
        couldNotCreateConnection,
    required TResult Function(ElectrumError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ElectrumError_IOError value)? ioError,
    TResult? Function(ElectrumError_Json value)? json,
    TResult? Function(ElectrumError_Hex value)? hex,
    TResult? Function(ElectrumError_Protocol value)? protocol,
    TResult? Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult? Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult? Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult? Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult? Function(ElectrumError_Message value)? message,
    TResult? Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult? Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult? Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult? Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult? Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult? Function(ElectrumError_Mpsc value)? mpsc,
    TResult? Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult? Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ElectrumError_IOError value)? ioError,
    TResult Function(ElectrumError_Json value)? json,
    TResult Function(ElectrumError_Hex value)? hex,
    TResult Function(ElectrumError_Protocol value)? protocol,
    TResult Function(ElectrumError_Bitcoin value)? bitcoin,
    TResult Function(ElectrumError_AlreadySubscribed value)? alreadySubscribed,
    TResult Function(ElectrumError_NotSubscribed value)? notSubscribed,
    TResult Function(ElectrumError_InvalidResponse value)? invalidResponse,
    TResult Function(ElectrumError_Message value)? message,
    TResult Function(ElectrumError_InvalidDNSNameError value)?
        invalidDnsNameError,
    TResult Function(ElectrumError_MissingDomain value)? missingDomain,
    TResult Function(ElectrumError_AllAttemptsErrored value)?
        allAttemptsErrored,
    TResult Function(ElectrumError_SharedIOError value)? sharedIoError,
    TResult Function(ElectrumError_CouldntLockReader value)? couldntLockReader,
    TResult Function(ElectrumError_Mpsc value)? mpsc,
    TResult Function(ElectrumError_CouldNotCreateConnection value)?
        couldNotCreateConnection,
    TResult Function(ElectrumError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (requestAlreadyConsumed != null) {
      return requestAlreadyConsumed(this);
    }
    return orElse();
  }
}

abstract class ElectrumError_RequestAlreadyConsumed extends ElectrumError {
  const factory ElectrumError_RequestAlreadyConsumed() =
      _$ElectrumError_RequestAlreadyConsumedImpl;
  const ElectrumError_RequestAlreadyConsumed._() : super._();
}

/// @nodoc
mixin _$EsploraError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EsploraErrorCopyWith<$Res> {
  factory $EsploraErrorCopyWith(
          EsploraError value, $Res Function(EsploraError) then) =
      _$EsploraErrorCopyWithImpl<$Res, EsploraError>;
}

/// @nodoc
class _$EsploraErrorCopyWithImpl<$Res, $Val extends EsploraError>
    implements $EsploraErrorCopyWith<$Res> {
  _$EsploraErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EsploraError_MinreqImplCopyWith<$Res> {
  factory _$$EsploraError_MinreqImplCopyWith(_$EsploraError_MinreqImpl value,
          $Res Function(_$EsploraError_MinreqImpl) then) =
      __$$EsploraError_MinreqImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_MinreqImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_MinreqImpl>
    implements _$$EsploraError_MinreqImplCopyWith<$Res> {
  __$$EsploraError_MinreqImplCopyWithImpl(_$EsploraError_MinreqImpl _value,
      $Res Function(_$EsploraError_MinreqImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_MinreqImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_MinreqImpl extends EsploraError_Minreq {
  const _$EsploraError_MinreqImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.minreq(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_MinreqImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_MinreqImplCopyWith<_$EsploraError_MinreqImpl> get copyWith =>
      __$$EsploraError_MinreqImplCopyWithImpl<_$EsploraError_MinreqImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return minreq(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return minreq?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (minreq != null) {
      return minreq(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return minreq(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return minreq?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (minreq != null) {
      return minreq(this);
    }
    return orElse();
  }
}

abstract class EsploraError_Minreq extends EsploraError {
  const factory EsploraError_Minreq({required final String errorMessage}) =
      _$EsploraError_MinreqImpl;
  const EsploraError_Minreq._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_MinreqImplCopyWith<_$EsploraError_MinreqImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_HttpResponseImplCopyWith<$Res> {
  factory _$$EsploraError_HttpResponseImplCopyWith(
          _$EsploraError_HttpResponseImpl value,
          $Res Function(_$EsploraError_HttpResponseImpl) then) =
      __$$EsploraError_HttpResponseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int status, String errorMessage});
}

/// @nodoc
class __$$EsploraError_HttpResponseImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_HttpResponseImpl>
    implements _$$EsploraError_HttpResponseImplCopyWith<$Res> {
  __$$EsploraError_HttpResponseImplCopyWithImpl(
      _$EsploraError_HttpResponseImpl _value,
      $Res Function(_$EsploraError_HttpResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_HttpResponseImpl(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as int,
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_HttpResponseImpl extends EsploraError_HttpResponse {
  const _$EsploraError_HttpResponseImpl(
      {required this.status, required this.errorMessage})
      : super._();

  @override
  final int status;
  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.httpResponse(status: $status, errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_HttpResponseImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_HttpResponseImplCopyWith<_$EsploraError_HttpResponseImpl>
      get copyWith => __$$EsploraError_HttpResponseImplCopyWithImpl<
          _$EsploraError_HttpResponseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return httpResponse(status, errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return httpResponse?.call(status, errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (httpResponse != null) {
      return httpResponse(status, errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return httpResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return httpResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (httpResponse != null) {
      return httpResponse(this);
    }
    return orElse();
  }
}

abstract class EsploraError_HttpResponse extends EsploraError {
  const factory EsploraError_HttpResponse(
      {required final int status,
      required final String errorMessage}) = _$EsploraError_HttpResponseImpl;
  const EsploraError_HttpResponse._() : super._();

  int get status;
  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_HttpResponseImplCopyWith<_$EsploraError_HttpResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_ParsingImplCopyWith<$Res> {
  factory _$$EsploraError_ParsingImplCopyWith(_$EsploraError_ParsingImpl value,
          $Res Function(_$EsploraError_ParsingImpl) then) =
      __$$EsploraError_ParsingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_ParsingImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_ParsingImpl>
    implements _$$EsploraError_ParsingImplCopyWith<$Res> {
  __$$EsploraError_ParsingImplCopyWithImpl(_$EsploraError_ParsingImpl _value,
      $Res Function(_$EsploraError_ParsingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_ParsingImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_ParsingImpl extends EsploraError_Parsing {
  const _$EsploraError_ParsingImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.parsing(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_ParsingImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_ParsingImplCopyWith<_$EsploraError_ParsingImpl>
      get copyWith =>
          __$$EsploraError_ParsingImplCopyWithImpl<_$EsploraError_ParsingImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return parsing(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return parsing?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (parsing != null) {
      return parsing(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return parsing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return parsing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (parsing != null) {
      return parsing(this);
    }
    return orElse();
  }
}

abstract class EsploraError_Parsing extends EsploraError {
  const factory EsploraError_Parsing({required final String errorMessage}) =
      _$EsploraError_ParsingImpl;
  const EsploraError_Parsing._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_ParsingImplCopyWith<_$EsploraError_ParsingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_StatusCodeImplCopyWith<$Res> {
  factory _$$EsploraError_StatusCodeImplCopyWith(
          _$EsploraError_StatusCodeImpl value,
          $Res Function(_$EsploraError_StatusCodeImpl) then) =
      __$$EsploraError_StatusCodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_StatusCodeImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_StatusCodeImpl>
    implements _$$EsploraError_StatusCodeImplCopyWith<$Res> {
  __$$EsploraError_StatusCodeImplCopyWithImpl(
      _$EsploraError_StatusCodeImpl _value,
      $Res Function(_$EsploraError_StatusCodeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_StatusCodeImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_StatusCodeImpl extends EsploraError_StatusCode {
  const _$EsploraError_StatusCodeImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.statusCode(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_StatusCodeImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_StatusCodeImplCopyWith<_$EsploraError_StatusCodeImpl>
      get copyWith => __$$EsploraError_StatusCodeImplCopyWithImpl<
          _$EsploraError_StatusCodeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return statusCode(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return statusCode?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (statusCode != null) {
      return statusCode(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return statusCode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return statusCode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (statusCode != null) {
      return statusCode(this);
    }
    return orElse();
  }
}

abstract class EsploraError_StatusCode extends EsploraError {
  const factory EsploraError_StatusCode({required final String errorMessage}) =
      _$EsploraError_StatusCodeImpl;
  const EsploraError_StatusCode._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_StatusCodeImplCopyWith<_$EsploraError_StatusCodeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_BitcoinEncodingImplCopyWith<$Res> {
  factory _$$EsploraError_BitcoinEncodingImplCopyWith(
          _$EsploraError_BitcoinEncodingImpl value,
          $Res Function(_$EsploraError_BitcoinEncodingImpl) then) =
      __$$EsploraError_BitcoinEncodingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_BitcoinEncodingImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_BitcoinEncodingImpl>
    implements _$$EsploraError_BitcoinEncodingImplCopyWith<$Res> {
  __$$EsploraError_BitcoinEncodingImplCopyWithImpl(
      _$EsploraError_BitcoinEncodingImpl _value,
      $Res Function(_$EsploraError_BitcoinEncodingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_BitcoinEncodingImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_BitcoinEncodingImpl extends EsploraError_BitcoinEncoding {
  const _$EsploraError_BitcoinEncodingImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.bitcoinEncoding(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_BitcoinEncodingImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_BitcoinEncodingImplCopyWith<
          _$EsploraError_BitcoinEncodingImpl>
      get copyWith => __$$EsploraError_BitcoinEncodingImplCopyWithImpl<
          _$EsploraError_BitcoinEncodingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return bitcoinEncoding(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return bitcoinEncoding?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (bitcoinEncoding != null) {
      return bitcoinEncoding(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return bitcoinEncoding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return bitcoinEncoding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (bitcoinEncoding != null) {
      return bitcoinEncoding(this);
    }
    return orElse();
  }
}

abstract class EsploraError_BitcoinEncoding extends EsploraError {
  const factory EsploraError_BitcoinEncoding(
          {required final String errorMessage}) =
      _$EsploraError_BitcoinEncodingImpl;
  const EsploraError_BitcoinEncoding._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_BitcoinEncodingImplCopyWith<
          _$EsploraError_BitcoinEncodingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_HexToArrayImplCopyWith<$Res> {
  factory _$$EsploraError_HexToArrayImplCopyWith(
          _$EsploraError_HexToArrayImpl value,
          $Res Function(_$EsploraError_HexToArrayImpl) then) =
      __$$EsploraError_HexToArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_HexToArrayImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_HexToArrayImpl>
    implements _$$EsploraError_HexToArrayImplCopyWith<$Res> {
  __$$EsploraError_HexToArrayImplCopyWithImpl(
      _$EsploraError_HexToArrayImpl _value,
      $Res Function(_$EsploraError_HexToArrayImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_HexToArrayImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_HexToArrayImpl extends EsploraError_HexToArray {
  const _$EsploraError_HexToArrayImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.hexToArray(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_HexToArrayImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_HexToArrayImplCopyWith<_$EsploraError_HexToArrayImpl>
      get copyWith => __$$EsploraError_HexToArrayImplCopyWithImpl<
          _$EsploraError_HexToArrayImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return hexToArray(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return hexToArray?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hexToArray != null) {
      return hexToArray(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return hexToArray(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return hexToArray?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hexToArray != null) {
      return hexToArray(this);
    }
    return orElse();
  }
}

abstract class EsploraError_HexToArray extends EsploraError {
  const factory EsploraError_HexToArray({required final String errorMessage}) =
      _$EsploraError_HexToArrayImpl;
  const EsploraError_HexToArray._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_HexToArrayImplCopyWith<_$EsploraError_HexToArrayImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_HexToBytesImplCopyWith<$Res> {
  factory _$$EsploraError_HexToBytesImplCopyWith(
          _$EsploraError_HexToBytesImpl value,
          $Res Function(_$EsploraError_HexToBytesImpl) then) =
      __$$EsploraError_HexToBytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$EsploraError_HexToBytesImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res, _$EsploraError_HexToBytesImpl>
    implements _$$EsploraError_HexToBytesImplCopyWith<$Res> {
  __$$EsploraError_HexToBytesImplCopyWithImpl(
      _$EsploraError_HexToBytesImpl _value,
      $Res Function(_$EsploraError_HexToBytesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$EsploraError_HexToBytesImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_HexToBytesImpl extends EsploraError_HexToBytes {
  const _$EsploraError_HexToBytesImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'EsploraError.hexToBytes(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_HexToBytesImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_HexToBytesImplCopyWith<_$EsploraError_HexToBytesImpl>
      get copyWith => __$$EsploraError_HexToBytesImplCopyWithImpl<
          _$EsploraError_HexToBytesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return hexToBytes(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return hexToBytes?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hexToBytes != null) {
      return hexToBytes(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return hexToBytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return hexToBytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (hexToBytes != null) {
      return hexToBytes(this);
    }
    return orElse();
  }
}

abstract class EsploraError_HexToBytes extends EsploraError {
  const factory EsploraError_HexToBytes({required final String errorMessage}) =
      _$EsploraError_HexToBytesImpl;
  const EsploraError_HexToBytes._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$EsploraError_HexToBytesImplCopyWith<_$EsploraError_HexToBytesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_TransactionNotFoundImplCopyWith<$Res> {
  factory _$$EsploraError_TransactionNotFoundImplCopyWith(
          _$EsploraError_TransactionNotFoundImpl value,
          $Res Function(_$EsploraError_TransactionNotFoundImpl) then) =
      __$$EsploraError_TransactionNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EsploraError_TransactionNotFoundImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_TransactionNotFoundImpl>
    implements _$$EsploraError_TransactionNotFoundImplCopyWith<$Res> {
  __$$EsploraError_TransactionNotFoundImplCopyWithImpl(
      _$EsploraError_TransactionNotFoundImpl _value,
      $Res Function(_$EsploraError_TransactionNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EsploraError_TransactionNotFoundImpl
    extends EsploraError_TransactionNotFound {
  const _$EsploraError_TransactionNotFoundImpl() : super._();

  @override
  String toString() {
    return 'EsploraError.transactionNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_TransactionNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return transactionNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return transactionNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return transactionNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return transactionNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound(this);
    }
    return orElse();
  }
}

abstract class EsploraError_TransactionNotFound extends EsploraError {
  const factory EsploraError_TransactionNotFound() =
      _$EsploraError_TransactionNotFoundImpl;
  const EsploraError_TransactionNotFound._() : super._();
}

/// @nodoc
abstract class _$$EsploraError_HeaderHeightNotFoundImplCopyWith<$Res> {
  factory _$$EsploraError_HeaderHeightNotFoundImplCopyWith(
          _$EsploraError_HeaderHeightNotFoundImpl value,
          $Res Function(_$EsploraError_HeaderHeightNotFoundImpl) then) =
      __$$EsploraError_HeaderHeightNotFoundImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int height});
}

/// @nodoc
class __$$EsploraError_HeaderHeightNotFoundImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_HeaderHeightNotFoundImpl>
    implements _$$EsploraError_HeaderHeightNotFoundImplCopyWith<$Res> {
  __$$EsploraError_HeaderHeightNotFoundImplCopyWithImpl(
      _$EsploraError_HeaderHeightNotFoundImpl _value,
      $Res Function(_$EsploraError_HeaderHeightNotFoundImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = null,
  }) {
    return _then(_$EsploraError_HeaderHeightNotFoundImpl(
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$EsploraError_HeaderHeightNotFoundImpl
    extends EsploraError_HeaderHeightNotFound {
  const _$EsploraError_HeaderHeightNotFoundImpl({required this.height})
      : super._();

  @override
  final int height;

  @override
  String toString() {
    return 'EsploraError.headerHeightNotFound(height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_HeaderHeightNotFoundImpl &&
            (identical(other.height, height) || other.height == height));
  }

  @override
  int get hashCode => Object.hash(runtimeType, height);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_HeaderHeightNotFoundImplCopyWith<
          _$EsploraError_HeaderHeightNotFoundImpl>
      get copyWith => __$$EsploraError_HeaderHeightNotFoundImplCopyWithImpl<
          _$EsploraError_HeaderHeightNotFoundImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return headerHeightNotFound(height);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return headerHeightNotFound?.call(height);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (headerHeightNotFound != null) {
      return headerHeightNotFound(height);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return headerHeightNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return headerHeightNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (headerHeightNotFound != null) {
      return headerHeightNotFound(this);
    }
    return orElse();
  }
}

abstract class EsploraError_HeaderHeightNotFound extends EsploraError {
  const factory EsploraError_HeaderHeightNotFound({required final int height}) =
      _$EsploraError_HeaderHeightNotFoundImpl;
  const EsploraError_HeaderHeightNotFound._() : super._();

  int get height;
  @JsonKey(ignore: true)
  _$$EsploraError_HeaderHeightNotFoundImplCopyWith<
          _$EsploraError_HeaderHeightNotFoundImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_HeaderHashNotFoundImplCopyWith<$Res> {
  factory _$$EsploraError_HeaderHashNotFoundImplCopyWith(
          _$EsploraError_HeaderHashNotFoundImpl value,
          $Res Function(_$EsploraError_HeaderHashNotFoundImpl) then) =
      __$$EsploraError_HeaderHashNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EsploraError_HeaderHashNotFoundImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_HeaderHashNotFoundImpl>
    implements _$$EsploraError_HeaderHashNotFoundImplCopyWith<$Res> {
  __$$EsploraError_HeaderHashNotFoundImplCopyWithImpl(
      _$EsploraError_HeaderHashNotFoundImpl _value,
      $Res Function(_$EsploraError_HeaderHashNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EsploraError_HeaderHashNotFoundImpl
    extends EsploraError_HeaderHashNotFound {
  const _$EsploraError_HeaderHashNotFoundImpl() : super._();

  @override
  String toString() {
    return 'EsploraError.headerHashNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_HeaderHashNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return headerHashNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return headerHashNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (headerHashNotFound != null) {
      return headerHashNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return headerHashNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return headerHashNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (headerHashNotFound != null) {
      return headerHashNotFound(this);
    }
    return orElse();
  }
}

abstract class EsploraError_HeaderHashNotFound extends EsploraError {
  const factory EsploraError_HeaderHashNotFound() =
      _$EsploraError_HeaderHashNotFoundImpl;
  const EsploraError_HeaderHashNotFound._() : super._();
}

/// @nodoc
abstract class _$$EsploraError_InvalidHttpHeaderNameImplCopyWith<$Res> {
  factory _$$EsploraError_InvalidHttpHeaderNameImplCopyWith(
          _$EsploraError_InvalidHttpHeaderNameImpl value,
          $Res Function(_$EsploraError_InvalidHttpHeaderNameImpl) then) =
      __$$EsploraError_InvalidHttpHeaderNameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$EsploraError_InvalidHttpHeaderNameImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_InvalidHttpHeaderNameImpl>
    implements _$$EsploraError_InvalidHttpHeaderNameImplCopyWith<$Res> {
  __$$EsploraError_InvalidHttpHeaderNameImplCopyWithImpl(
      _$EsploraError_InvalidHttpHeaderNameImpl _value,
      $Res Function(_$EsploraError_InvalidHttpHeaderNameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$EsploraError_InvalidHttpHeaderNameImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_InvalidHttpHeaderNameImpl
    extends EsploraError_InvalidHttpHeaderName {
  const _$EsploraError_InvalidHttpHeaderNameImpl({required this.name})
      : super._();

  @override
  final String name;

  @override
  String toString() {
    return 'EsploraError.invalidHttpHeaderName(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_InvalidHttpHeaderNameImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_InvalidHttpHeaderNameImplCopyWith<
          _$EsploraError_InvalidHttpHeaderNameImpl>
      get copyWith => __$$EsploraError_InvalidHttpHeaderNameImplCopyWithImpl<
          _$EsploraError_InvalidHttpHeaderNameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderName(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderName?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidHttpHeaderName != null) {
      return invalidHttpHeaderName(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidHttpHeaderName != null) {
      return invalidHttpHeaderName(this);
    }
    return orElse();
  }
}

abstract class EsploraError_InvalidHttpHeaderName extends EsploraError {
  const factory EsploraError_InvalidHttpHeaderName(
      {required final String name}) = _$EsploraError_InvalidHttpHeaderNameImpl;
  const EsploraError_InvalidHttpHeaderName._() : super._();

  String get name;
  @JsonKey(ignore: true)
  _$$EsploraError_InvalidHttpHeaderNameImplCopyWith<
          _$EsploraError_InvalidHttpHeaderNameImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_InvalidHttpHeaderValueImplCopyWith<$Res> {
  factory _$$EsploraError_InvalidHttpHeaderValueImplCopyWith(
          _$EsploraError_InvalidHttpHeaderValueImpl value,
          $Res Function(_$EsploraError_InvalidHttpHeaderValueImpl) then) =
      __$$EsploraError_InvalidHttpHeaderValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EsploraError_InvalidHttpHeaderValueImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_InvalidHttpHeaderValueImpl>
    implements _$$EsploraError_InvalidHttpHeaderValueImplCopyWith<$Res> {
  __$$EsploraError_InvalidHttpHeaderValueImplCopyWithImpl(
      _$EsploraError_InvalidHttpHeaderValueImpl _value,
      $Res Function(_$EsploraError_InvalidHttpHeaderValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EsploraError_InvalidHttpHeaderValueImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsploraError_InvalidHttpHeaderValueImpl
    extends EsploraError_InvalidHttpHeaderValue {
  const _$EsploraError_InvalidHttpHeaderValueImpl({required this.value})
      : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'EsploraError.invalidHttpHeaderValue(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_InvalidHttpHeaderValueImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EsploraError_InvalidHttpHeaderValueImplCopyWith<
          _$EsploraError_InvalidHttpHeaderValueImpl>
      get copyWith => __$$EsploraError_InvalidHttpHeaderValueImplCopyWithImpl<
          _$EsploraError_InvalidHttpHeaderValueImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderValue(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderValue?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidHttpHeaderValue != null) {
      return invalidHttpHeaderValue(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return invalidHttpHeaderValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (invalidHttpHeaderValue != null) {
      return invalidHttpHeaderValue(this);
    }
    return orElse();
  }
}

abstract class EsploraError_InvalidHttpHeaderValue extends EsploraError {
  const factory EsploraError_InvalidHttpHeaderValue(
          {required final String value}) =
      _$EsploraError_InvalidHttpHeaderValueImpl;
  const EsploraError_InvalidHttpHeaderValue._() : super._();

  String get value;
  @JsonKey(ignore: true)
  _$$EsploraError_InvalidHttpHeaderValueImplCopyWith<
          _$EsploraError_InvalidHttpHeaderValueImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EsploraError_RequestAlreadyConsumedImplCopyWith<$Res> {
  factory _$$EsploraError_RequestAlreadyConsumedImplCopyWith(
          _$EsploraError_RequestAlreadyConsumedImpl value,
          $Res Function(_$EsploraError_RequestAlreadyConsumedImpl) then) =
      __$$EsploraError_RequestAlreadyConsumedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EsploraError_RequestAlreadyConsumedImplCopyWithImpl<$Res>
    extends _$EsploraErrorCopyWithImpl<$Res,
        _$EsploraError_RequestAlreadyConsumedImpl>
    implements _$$EsploraError_RequestAlreadyConsumedImplCopyWith<$Res> {
  __$$EsploraError_RequestAlreadyConsumedImplCopyWithImpl(
      _$EsploraError_RequestAlreadyConsumedImpl _value,
      $Res Function(_$EsploraError_RequestAlreadyConsumedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EsploraError_RequestAlreadyConsumedImpl
    extends EsploraError_RequestAlreadyConsumed {
  const _$EsploraError_RequestAlreadyConsumedImpl() : super._();

  @override
  String toString() {
    return 'EsploraError.requestAlreadyConsumed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsploraError_RequestAlreadyConsumedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) minreq,
    required TResult Function(int status, String errorMessage) httpResponse,
    required TResult Function(String errorMessage) parsing,
    required TResult Function(String errorMessage) statusCode,
    required TResult Function(String errorMessage) bitcoinEncoding,
    required TResult Function(String errorMessage) hexToArray,
    required TResult Function(String errorMessage) hexToBytes,
    required TResult Function() transactionNotFound,
    required TResult Function(int height) headerHeightNotFound,
    required TResult Function() headerHashNotFound,
    required TResult Function(String name) invalidHttpHeaderName,
    required TResult Function(String value) invalidHttpHeaderValue,
    required TResult Function() requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? minreq,
    TResult? Function(int status, String errorMessage)? httpResponse,
    TResult? Function(String errorMessage)? parsing,
    TResult? Function(String errorMessage)? statusCode,
    TResult? Function(String errorMessage)? bitcoinEncoding,
    TResult? Function(String errorMessage)? hexToArray,
    TResult? Function(String errorMessage)? hexToBytes,
    TResult? Function()? transactionNotFound,
    TResult? Function(int height)? headerHeightNotFound,
    TResult? Function()? headerHashNotFound,
    TResult? Function(String name)? invalidHttpHeaderName,
    TResult? Function(String value)? invalidHttpHeaderValue,
    TResult? Function()? requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? minreq,
    TResult Function(int status, String errorMessage)? httpResponse,
    TResult Function(String errorMessage)? parsing,
    TResult Function(String errorMessage)? statusCode,
    TResult Function(String errorMessage)? bitcoinEncoding,
    TResult Function(String errorMessage)? hexToArray,
    TResult Function(String errorMessage)? hexToBytes,
    TResult Function()? transactionNotFound,
    TResult Function(int height)? headerHeightNotFound,
    TResult Function()? headerHashNotFound,
    TResult Function(String name)? invalidHttpHeaderName,
    TResult Function(String value)? invalidHttpHeaderValue,
    TResult Function()? requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (requestAlreadyConsumed != null) {
      return requestAlreadyConsumed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EsploraError_Minreq value) minreq,
    required TResult Function(EsploraError_HttpResponse value) httpResponse,
    required TResult Function(EsploraError_Parsing value) parsing,
    required TResult Function(EsploraError_StatusCode value) statusCode,
    required TResult Function(EsploraError_BitcoinEncoding value)
        bitcoinEncoding,
    required TResult Function(EsploraError_HexToArray value) hexToArray,
    required TResult Function(EsploraError_HexToBytes value) hexToBytes,
    required TResult Function(EsploraError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(EsploraError_HeaderHeightNotFound value)
        headerHeightNotFound,
    required TResult Function(EsploraError_HeaderHashNotFound value)
        headerHashNotFound,
    required TResult Function(EsploraError_InvalidHttpHeaderName value)
        invalidHttpHeaderName,
    required TResult Function(EsploraError_InvalidHttpHeaderValue value)
        invalidHttpHeaderValue,
    required TResult Function(EsploraError_RequestAlreadyConsumed value)
        requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EsploraError_Minreq value)? minreq,
    TResult? Function(EsploraError_HttpResponse value)? httpResponse,
    TResult? Function(EsploraError_Parsing value)? parsing,
    TResult? Function(EsploraError_StatusCode value)? statusCode,
    TResult? Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult? Function(EsploraError_HexToArray value)? hexToArray,
    TResult? Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult? Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult? Function(EsploraError_HeaderHashNotFound value)?
        headerHashNotFound,
    TResult? Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult? Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult? Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
  }) {
    return requestAlreadyConsumed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EsploraError_Minreq value)? minreq,
    TResult Function(EsploraError_HttpResponse value)? httpResponse,
    TResult Function(EsploraError_Parsing value)? parsing,
    TResult Function(EsploraError_StatusCode value)? statusCode,
    TResult Function(EsploraError_BitcoinEncoding value)? bitcoinEncoding,
    TResult Function(EsploraError_HexToArray value)? hexToArray,
    TResult Function(EsploraError_HexToBytes value)? hexToBytes,
    TResult Function(EsploraError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(EsploraError_HeaderHeightNotFound value)?
        headerHeightNotFound,
    TResult Function(EsploraError_HeaderHashNotFound value)? headerHashNotFound,
    TResult Function(EsploraError_InvalidHttpHeaderName value)?
        invalidHttpHeaderName,
    TResult Function(EsploraError_InvalidHttpHeaderValue value)?
        invalidHttpHeaderValue,
    TResult Function(EsploraError_RequestAlreadyConsumed value)?
        requestAlreadyConsumed,
    required TResult orElse(),
  }) {
    if (requestAlreadyConsumed != null) {
      return requestAlreadyConsumed(this);
    }
    return orElse();
  }
}

abstract class EsploraError_RequestAlreadyConsumed extends EsploraError {
  const factory EsploraError_RequestAlreadyConsumed() =
      _$EsploraError_RequestAlreadyConsumedImpl;
  const EsploraError_RequestAlreadyConsumed._() : super._();
}

/// @nodoc
mixin _$ExtractTxError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt feeRate) absurdFeeRate,
    required TResult Function() missingInputValue,
    required TResult Function() sendingTooMuch,
    required TResult Function() otherExtractTxErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt feeRate)? absurdFeeRate,
    TResult? Function()? missingInputValue,
    TResult? Function()? sendingTooMuch,
    TResult? Function()? otherExtractTxErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt feeRate)? absurdFeeRate,
    TResult Function()? missingInputValue,
    TResult Function()? sendingTooMuch,
    TResult Function()? otherExtractTxErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExtractTxError_AbsurdFeeRate value) absurdFeeRate,
    required TResult Function(ExtractTxError_MissingInputValue value)
        missingInputValue,
    required TResult Function(ExtractTxError_SendingTooMuch value)
        sendingTooMuch,
    required TResult Function(ExtractTxError_OtherExtractTxErr value)
        otherExtractTxErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult? Function(ExtractTxError_MissingInputValue value)?
        missingInputValue,
    TResult? Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult? Function(ExtractTxError_OtherExtractTxErr value)?
        otherExtractTxErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult Function(ExtractTxError_MissingInputValue value)? missingInputValue,
    TResult Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult Function(ExtractTxError_OtherExtractTxErr value)? otherExtractTxErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtractTxErrorCopyWith<$Res> {
  factory $ExtractTxErrorCopyWith(
          ExtractTxError value, $Res Function(ExtractTxError) then) =
      _$ExtractTxErrorCopyWithImpl<$Res, ExtractTxError>;
}

/// @nodoc
class _$ExtractTxErrorCopyWithImpl<$Res, $Val extends ExtractTxError>
    implements $ExtractTxErrorCopyWith<$Res> {
  _$ExtractTxErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ExtractTxError_AbsurdFeeRateImplCopyWith<$Res> {
  factory _$$ExtractTxError_AbsurdFeeRateImplCopyWith(
          _$ExtractTxError_AbsurdFeeRateImpl value,
          $Res Function(_$ExtractTxError_AbsurdFeeRateImpl) then) =
      __$$ExtractTxError_AbsurdFeeRateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt feeRate});
}

/// @nodoc
class __$$ExtractTxError_AbsurdFeeRateImplCopyWithImpl<$Res>
    extends _$ExtractTxErrorCopyWithImpl<$Res,
        _$ExtractTxError_AbsurdFeeRateImpl>
    implements _$$ExtractTxError_AbsurdFeeRateImplCopyWith<$Res> {
  __$$ExtractTxError_AbsurdFeeRateImplCopyWithImpl(
      _$ExtractTxError_AbsurdFeeRateImpl _value,
      $Res Function(_$ExtractTxError_AbsurdFeeRateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeRate = null,
  }) {
    return _then(_$ExtractTxError_AbsurdFeeRateImpl(
      feeRate: null == feeRate
          ? _value.feeRate
          : feeRate // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$ExtractTxError_AbsurdFeeRateImpl extends ExtractTxError_AbsurdFeeRate {
  const _$ExtractTxError_AbsurdFeeRateImpl({required this.feeRate}) : super._();

  @override
  final BigInt feeRate;

  @override
  String toString() {
    return 'ExtractTxError.absurdFeeRate(feeRate: $feeRate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtractTxError_AbsurdFeeRateImpl &&
            (identical(other.feeRate, feeRate) || other.feeRate == feeRate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, feeRate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExtractTxError_AbsurdFeeRateImplCopyWith<
          _$ExtractTxError_AbsurdFeeRateImpl>
      get copyWith => __$$ExtractTxError_AbsurdFeeRateImplCopyWithImpl<
          _$ExtractTxError_AbsurdFeeRateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt feeRate) absurdFeeRate,
    required TResult Function() missingInputValue,
    required TResult Function() sendingTooMuch,
    required TResult Function() otherExtractTxErr,
  }) {
    return absurdFeeRate(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt feeRate)? absurdFeeRate,
    TResult? Function()? missingInputValue,
    TResult? Function()? sendingTooMuch,
    TResult? Function()? otherExtractTxErr,
  }) {
    return absurdFeeRate?.call(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt feeRate)? absurdFeeRate,
    TResult Function()? missingInputValue,
    TResult Function()? sendingTooMuch,
    TResult Function()? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (absurdFeeRate != null) {
      return absurdFeeRate(feeRate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExtractTxError_AbsurdFeeRate value) absurdFeeRate,
    required TResult Function(ExtractTxError_MissingInputValue value)
        missingInputValue,
    required TResult Function(ExtractTxError_SendingTooMuch value)
        sendingTooMuch,
    required TResult Function(ExtractTxError_OtherExtractTxErr value)
        otherExtractTxErr,
  }) {
    return absurdFeeRate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult? Function(ExtractTxError_MissingInputValue value)?
        missingInputValue,
    TResult? Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult? Function(ExtractTxError_OtherExtractTxErr value)?
        otherExtractTxErr,
  }) {
    return absurdFeeRate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult Function(ExtractTxError_MissingInputValue value)? missingInputValue,
    TResult Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult Function(ExtractTxError_OtherExtractTxErr value)? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (absurdFeeRate != null) {
      return absurdFeeRate(this);
    }
    return orElse();
  }
}

abstract class ExtractTxError_AbsurdFeeRate extends ExtractTxError {
  const factory ExtractTxError_AbsurdFeeRate({required final BigInt feeRate}) =
      _$ExtractTxError_AbsurdFeeRateImpl;
  const ExtractTxError_AbsurdFeeRate._() : super._();

  BigInt get feeRate;
  @JsonKey(ignore: true)
  _$$ExtractTxError_AbsurdFeeRateImplCopyWith<
          _$ExtractTxError_AbsurdFeeRateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExtractTxError_MissingInputValueImplCopyWith<$Res> {
  factory _$$ExtractTxError_MissingInputValueImplCopyWith(
          _$ExtractTxError_MissingInputValueImpl value,
          $Res Function(_$ExtractTxError_MissingInputValueImpl) then) =
      __$$ExtractTxError_MissingInputValueImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExtractTxError_MissingInputValueImplCopyWithImpl<$Res>
    extends _$ExtractTxErrorCopyWithImpl<$Res,
        _$ExtractTxError_MissingInputValueImpl>
    implements _$$ExtractTxError_MissingInputValueImplCopyWith<$Res> {
  __$$ExtractTxError_MissingInputValueImplCopyWithImpl(
      _$ExtractTxError_MissingInputValueImpl _value,
      $Res Function(_$ExtractTxError_MissingInputValueImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ExtractTxError_MissingInputValueImpl
    extends ExtractTxError_MissingInputValue {
  const _$ExtractTxError_MissingInputValueImpl() : super._();

  @override
  String toString() {
    return 'ExtractTxError.missingInputValue()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtractTxError_MissingInputValueImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt feeRate) absurdFeeRate,
    required TResult Function() missingInputValue,
    required TResult Function() sendingTooMuch,
    required TResult Function() otherExtractTxErr,
  }) {
    return missingInputValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt feeRate)? absurdFeeRate,
    TResult? Function()? missingInputValue,
    TResult? Function()? sendingTooMuch,
    TResult? Function()? otherExtractTxErr,
  }) {
    return missingInputValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt feeRate)? absurdFeeRate,
    TResult Function()? missingInputValue,
    TResult Function()? sendingTooMuch,
    TResult Function()? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (missingInputValue != null) {
      return missingInputValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExtractTxError_AbsurdFeeRate value) absurdFeeRate,
    required TResult Function(ExtractTxError_MissingInputValue value)
        missingInputValue,
    required TResult Function(ExtractTxError_SendingTooMuch value)
        sendingTooMuch,
    required TResult Function(ExtractTxError_OtherExtractTxErr value)
        otherExtractTxErr,
  }) {
    return missingInputValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult? Function(ExtractTxError_MissingInputValue value)?
        missingInputValue,
    TResult? Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult? Function(ExtractTxError_OtherExtractTxErr value)?
        otherExtractTxErr,
  }) {
    return missingInputValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult Function(ExtractTxError_MissingInputValue value)? missingInputValue,
    TResult Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult Function(ExtractTxError_OtherExtractTxErr value)? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (missingInputValue != null) {
      return missingInputValue(this);
    }
    return orElse();
  }
}

abstract class ExtractTxError_MissingInputValue extends ExtractTxError {
  const factory ExtractTxError_MissingInputValue() =
      _$ExtractTxError_MissingInputValueImpl;
  const ExtractTxError_MissingInputValue._() : super._();
}

/// @nodoc
abstract class _$$ExtractTxError_SendingTooMuchImplCopyWith<$Res> {
  factory _$$ExtractTxError_SendingTooMuchImplCopyWith(
          _$ExtractTxError_SendingTooMuchImpl value,
          $Res Function(_$ExtractTxError_SendingTooMuchImpl) then) =
      __$$ExtractTxError_SendingTooMuchImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExtractTxError_SendingTooMuchImplCopyWithImpl<$Res>
    extends _$ExtractTxErrorCopyWithImpl<$Res,
        _$ExtractTxError_SendingTooMuchImpl>
    implements _$$ExtractTxError_SendingTooMuchImplCopyWith<$Res> {
  __$$ExtractTxError_SendingTooMuchImplCopyWithImpl(
      _$ExtractTxError_SendingTooMuchImpl _value,
      $Res Function(_$ExtractTxError_SendingTooMuchImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ExtractTxError_SendingTooMuchImpl
    extends ExtractTxError_SendingTooMuch {
  const _$ExtractTxError_SendingTooMuchImpl() : super._();

  @override
  String toString() {
    return 'ExtractTxError.sendingTooMuch()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtractTxError_SendingTooMuchImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt feeRate) absurdFeeRate,
    required TResult Function() missingInputValue,
    required TResult Function() sendingTooMuch,
    required TResult Function() otherExtractTxErr,
  }) {
    return sendingTooMuch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt feeRate)? absurdFeeRate,
    TResult? Function()? missingInputValue,
    TResult? Function()? sendingTooMuch,
    TResult? Function()? otherExtractTxErr,
  }) {
    return sendingTooMuch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt feeRate)? absurdFeeRate,
    TResult Function()? missingInputValue,
    TResult Function()? sendingTooMuch,
    TResult Function()? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (sendingTooMuch != null) {
      return sendingTooMuch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExtractTxError_AbsurdFeeRate value) absurdFeeRate,
    required TResult Function(ExtractTxError_MissingInputValue value)
        missingInputValue,
    required TResult Function(ExtractTxError_SendingTooMuch value)
        sendingTooMuch,
    required TResult Function(ExtractTxError_OtherExtractTxErr value)
        otherExtractTxErr,
  }) {
    return sendingTooMuch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult? Function(ExtractTxError_MissingInputValue value)?
        missingInputValue,
    TResult? Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult? Function(ExtractTxError_OtherExtractTxErr value)?
        otherExtractTxErr,
  }) {
    return sendingTooMuch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult Function(ExtractTxError_MissingInputValue value)? missingInputValue,
    TResult Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult Function(ExtractTxError_OtherExtractTxErr value)? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (sendingTooMuch != null) {
      return sendingTooMuch(this);
    }
    return orElse();
  }
}

abstract class ExtractTxError_SendingTooMuch extends ExtractTxError {
  const factory ExtractTxError_SendingTooMuch() =
      _$ExtractTxError_SendingTooMuchImpl;
  const ExtractTxError_SendingTooMuch._() : super._();
}

/// @nodoc
abstract class _$$ExtractTxError_OtherExtractTxErrImplCopyWith<$Res> {
  factory _$$ExtractTxError_OtherExtractTxErrImplCopyWith(
          _$ExtractTxError_OtherExtractTxErrImpl value,
          $Res Function(_$ExtractTxError_OtherExtractTxErrImpl) then) =
      __$$ExtractTxError_OtherExtractTxErrImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExtractTxError_OtherExtractTxErrImplCopyWithImpl<$Res>
    extends _$ExtractTxErrorCopyWithImpl<$Res,
        _$ExtractTxError_OtherExtractTxErrImpl>
    implements _$$ExtractTxError_OtherExtractTxErrImplCopyWith<$Res> {
  __$$ExtractTxError_OtherExtractTxErrImplCopyWithImpl(
      _$ExtractTxError_OtherExtractTxErrImpl _value,
      $Res Function(_$ExtractTxError_OtherExtractTxErrImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ExtractTxError_OtherExtractTxErrImpl
    extends ExtractTxError_OtherExtractTxErr {
  const _$ExtractTxError_OtherExtractTxErrImpl() : super._();

  @override
  String toString() {
    return 'ExtractTxError.otherExtractTxErr()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtractTxError_OtherExtractTxErrImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt feeRate) absurdFeeRate,
    required TResult Function() missingInputValue,
    required TResult Function() sendingTooMuch,
    required TResult Function() otherExtractTxErr,
  }) {
    return otherExtractTxErr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt feeRate)? absurdFeeRate,
    TResult? Function()? missingInputValue,
    TResult? Function()? sendingTooMuch,
    TResult? Function()? otherExtractTxErr,
  }) {
    return otherExtractTxErr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt feeRate)? absurdFeeRate,
    TResult Function()? missingInputValue,
    TResult Function()? sendingTooMuch,
    TResult Function()? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (otherExtractTxErr != null) {
      return otherExtractTxErr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExtractTxError_AbsurdFeeRate value) absurdFeeRate,
    required TResult Function(ExtractTxError_MissingInputValue value)
        missingInputValue,
    required TResult Function(ExtractTxError_SendingTooMuch value)
        sendingTooMuch,
    required TResult Function(ExtractTxError_OtherExtractTxErr value)
        otherExtractTxErr,
  }) {
    return otherExtractTxErr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult? Function(ExtractTxError_MissingInputValue value)?
        missingInputValue,
    TResult? Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult? Function(ExtractTxError_OtherExtractTxErr value)?
        otherExtractTxErr,
  }) {
    return otherExtractTxErr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExtractTxError_AbsurdFeeRate value)? absurdFeeRate,
    TResult Function(ExtractTxError_MissingInputValue value)? missingInputValue,
    TResult Function(ExtractTxError_SendingTooMuch value)? sendingTooMuch,
    TResult Function(ExtractTxError_OtherExtractTxErr value)? otherExtractTxErr,
    required TResult orElse(),
  }) {
    if (otherExtractTxErr != null) {
      return otherExtractTxErr(this);
    }
    return orElse();
  }
}

abstract class ExtractTxError_OtherExtractTxErr extends ExtractTxError {
  const factory ExtractTxError_OtherExtractTxErr() =
      _$ExtractTxError_OtherExtractTxErrImpl;
  const ExtractTxError_OtherExtractTxErr._() : super._();
}

/// @nodoc
mixin _$FromScriptError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unrecognizedScript,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function() otherFromScriptErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unrecognizedScript,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function()? otherFromScriptErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unrecognizedScript,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function()? otherFromScriptErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FromScriptError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(FromScriptError_WitnessProgram value)
        witnessProgram,
    required TResult Function(FromScriptError_WitnessVersion value)
        witnessVersion,
    required TResult Function(FromScriptError_OtherFromScriptErr value)
        otherFromScriptErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult? Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult? Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FromScriptErrorCopyWith<$Res> {
  factory $FromScriptErrorCopyWith(
          FromScriptError value, $Res Function(FromScriptError) then) =
      _$FromScriptErrorCopyWithImpl<$Res, FromScriptError>;
}

/// @nodoc
class _$FromScriptErrorCopyWithImpl<$Res, $Val extends FromScriptError>
    implements $FromScriptErrorCopyWith<$Res> {
  _$FromScriptErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FromScriptError_UnrecognizedScriptImplCopyWith<$Res> {
  factory _$$FromScriptError_UnrecognizedScriptImplCopyWith(
          _$FromScriptError_UnrecognizedScriptImpl value,
          $Res Function(_$FromScriptError_UnrecognizedScriptImpl) then) =
      __$$FromScriptError_UnrecognizedScriptImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FromScriptError_UnrecognizedScriptImplCopyWithImpl<$Res>
    extends _$FromScriptErrorCopyWithImpl<$Res,
        _$FromScriptError_UnrecognizedScriptImpl>
    implements _$$FromScriptError_UnrecognizedScriptImplCopyWith<$Res> {
  __$$FromScriptError_UnrecognizedScriptImplCopyWithImpl(
      _$FromScriptError_UnrecognizedScriptImpl _value,
      $Res Function(_$FromScriptError_UnrecognizedScriptImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FromScriptError_UnrecognizedScriptImpl
    extends FromScriptError_UnrecognizedScript {
  const _$FromScriptError_UnrecognizedScriptImpl() : super._();

  @override
  String toString() {
    return 'FromScriptError.unrecognizedScript()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FromScriptError_UnrecognizedScriptImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unrecognizedScript,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function() otherFromScriptErr,
  }) {
    return unrecognizedScript();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unrecognizedScript,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function()? otherFromScriptErr,
  }) {
    return unrecognizedScript?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unrecognizedScript,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function()? otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (unrecognizedScript != null) {
      return unrecognizedScript();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FromScriptError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(FromScriptError_WitnessProgram value)
        witnessProgram,
    required TResult Function(FromScriptError_WitnessVersion value)
        witnessVersion,
    required TResult Function(FromScriptError_OtherFromScriptErr value)
        otherFromScriptErr,
  }) {
    return unrecognizedScript(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult? Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult? Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
  }) {
    return unrecognizedScript?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (unrecognizedScript != null) {
      return unrecognizedScript(this);
    }
    return orElse();
  }
}

abstract class FromScriptError_UnrecognizedScript extends FromScriptError {
  const factory FromScriptError_UnrecognizedScript() =
      _$FromScriptError_UnrecognizedScriptImpl;
  const FromScriptError_UnrecognizedScript._() : super._();
}

/// @nodoc
abstract class _$$FromScriptError_WitnessProgramImplCopyWith<$Res> {
  factory _$$FromScriptError_WitnessProgramImplCopyWith(
          _$FromScriptError_WitnessProgramImpl value,
          $Res Function(_$FromScriptError_WitnessProgramImpl) then) =
      __$$FromScriptError_WitnessProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$FromScriptError_WitnessProgramImplCopyWithImpl<$Res>
    extends _$FromScriptErrorCopyWithImpl<$Res,
        _$FromScriptError_WitnessProgramImpl>
    implements _$$FromScriptError_WitnessProgramImplCopyWith<$Res> {
  __$$FromScriptError_WitnessProgramImplCopyWithImpl(
      _$FromScriptError_WitnessProgramImpl _value,
      $Res Function(_$FromScriptError_WitnessProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$FromScriptError_WitnessProgramImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FromScriptError_WitnessProgramImpl
    extends FromScriptError_WitnessProgram {
  const _$FromScriptError_WitnessProgramImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'FromScriptError.witnessProgram(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FromScriptError_WitnessProgramImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FromScriptError_WitnessProgramImplCopyWith<
          _$FromScriptError_WitnessProgramImpl>
      get copyWith => __$$FromScriptError_WitnessProgramImplCopyWithImpl<
          _$FromScriptError_WitnessProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unrecognizedScript,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function() otherFromScriptErr,
  }) {
    return witnessProgram(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unrecognizedScript,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function()? otherFromScriptErr,
  }) {
    return witnessProgram?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unrecognizedScript,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function()? otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FromScriptError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(FromScriptError_WitnessProgram value)
        witnessProgram,
    required TResult Function(FromScriptError_WitnessVersion value)
        witnessVersion,
    required TResult Function(FromScriptError_OtherFromScriptErr value)
        otherFromScriptErr,
  }) {
    return witnessProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult? Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult? Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
  }) {
    return witnessProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(this);
    }
    return orElse();
  }
}

abstract class FromScriptError_WitnessProgram extends FromScriptError {
  const factory FromScriptError_WitnessProgram(
          {required final String errorMessage}) =
      _$FromScriptError_WitnessProgramImpl;
  const FromScriptError_WitnessProgram._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$FromScriptError_WitnessProgramImplCopyWith<
          _$FromScriptError_WitnessProgramImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FromScriptError_WitnessVersionImplCopyWith<$Res> {
  factory _$$FromScriptError_WitnessVersionImplCopyWith(
          _$FromScriptError_WitnessVersionImpl value,
          $Res Function(_$FromScriptError_WitnessVersionImpl) then) =
      __$$FromScriptError_WitnessVersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$FromScriptError_WitnessVersionImplCopyWithImpl<$Res>
    extends _$FromScriptErrorCopyWithImpl<$Res,
        _$FromScriptError_WitnessVersionImpl>
    implements _$$FromScriptError_WitnessVersionImplCopyWith<$Res> {
  __$$FromScriptError_WitnessVersionImplCopyWithImpl(
      _$FromScriptError_WitnessVersionImpl _value,
      $Res Function(_$FromScriptError_WitnessVersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$FromScriptError_WitnessVersionImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FromScriptError_WitnessVersionImpl
    extends FromScriptError_WitnessVersion {
  const _$FromScriptError_WitnessVersionImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'FromScriptError.witnessVersion(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FromScriptError_WitnessVersionImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FromScriptError_WitnessVersionImplCopyWith<
          _$FromScriptError_WitnessVersionImpl>
      get copyWith => __$$FromScriptError_WitnessVersionImplCopyWithImpl<
          _$FromScriptError_WitnessVersionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unrecognizedScript,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function() otherFromScriptErr,
  }) {
    return witnessVersion(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unrecognizedScript,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function()? otherFromScriptErr,
  }) {
    return witnessVersion?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unrecognizedScript,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function()? otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (witnessVersion != null) {
      return witnessVersion(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FromScriptError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(FromScriptError_WitnessProgram value)
        witnessProgram,
    required TResult Function(FromScriptError_WitnessVersion value)
        witnessVersion,
    required TResult Function(FromScriptError_OtherFromScriptErr value)
        otherFromScriptErr,
  }) {
    return witnessVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult? Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult? Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
  }) {
    return witnessVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (witnessVersion != null) {
      return witnessVersion(this);
    }
    return orElse();
  }
}

abstract class FromScriptError_WitnessVersion extends FromScriptError {
  const factory FromScriptError_WitnessVersion(
          {required final String errorMessage}) =
      _$FromScriptError_WitnessVersionImpl;
  const FromScriptError_WitnessVersion._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$FromScriptError_WitnessVersionImplCopyWith<
          _$FromScriptError_WitnessVersionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FromScriptError_OtherFromScriptErrImplCopyWith<$Res> {
  factory _$$FromScriptError_OtherFromScriptErrImplCopyWith(
          _$FromScriptError_OtherFromScriptErrImpl value,
          $Res Function(_$FromScriptError_OtherFromScriptErrImpl) then) =
      __$$FromScriptError_OtherFromScriptErrImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FromScriptError_OtherFromScriptErrImplCopyWithImpl<$Res>
    extends _$FromScriptErrorCopyWithImpl<$Res,
        _$FromScriptError_OtherFromScriptErrImpl>
    implements _$$FromScriptError_OtherFromScriptErrImplCopyWith<$Res> {
  __$$FromScriptError_OtherFromScriptErrImplCopyWithImpl(
      _$FromScriptError_OtherFromScriptErrImpl _value,
      $Res Function(_$FromScriptError_OtherFromScriptErrImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FromScriptError_OtherFromScriptErrImpl
    extends FromScriptError_OtherFromScriptErr {
  const _$FromScriptError_OtherFromScriptErrImpl() : super._();

  @override
  String toString() {
    return 'FromScriptError.otherFromScriptErr()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FromScriptError_OtherFromScriptErrImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unrecognizedScript,
    required TResult Function(String errorMessage) witnessProgram,
    required TResult Function(String errorMessage) witnessVersion,
    required TResult Function() otherFromScriptErr,
  }) {
    return otherFromScriptErr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unrecognizedScript,
    TResult? Function(String errorMessage)? witnessProgram,
    TResult? Function(String errorMessage)? witnessVersion,
    TResult? Function()? otherFromScriptErr,
  }) {
    return otherFromScriptErr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unrecognizedScript,
    TResult Function(String errorMessage)? witnessProgram,
    TResult Function(String errorMessage)? witnessVersion,
    TResult Function()? otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (otherFromScriptErr != null) {
      return otherFromScriptErr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FromScriptError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(FromScriptError_WitnessProgram value)
        witnessProgram,
    required TResult Function(FromScriptError_WitnessVersion value)
        witnessVersion,
    required TResult Function(FromScriptError_OtherFromScriptErr value)
        otherFromScriptErr,
  }) {
    return otherFromScriptErr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult? Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult? Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
  }) {
    return otherFromScriptErr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FromScriptError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(FromScriptError_WitnessProgram value)? witnessProgram,
    TResult Function(FromScriptError_WitnessVersion value)? witnessVersion,
    TResult Function(FromScriptError_OtherFromScriptErr value)?
        otherFromScriptErr,
    required TResult orElse(),
  }) {
    if (otherFromScriptErr != null) {
      return otherFromScriptErr(this);
    }
    return orElse();
  }
}

abstract class FromScriptError_OtherFromScriptErr extends FromScriptError {
  const factory FromScriptError_OtherFromScriptErr() =
      _$FromScriptError_OtherFromScriptErrImpl;
  const FromScriptError_OtherFromScriptErr._() : super._();
}

/// @nodoc
mixin _$LoadWithPersistError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function(String errorMessage) invalidChangeSet,
    required TResult Function() couldNotLoad,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function(String errorMessage)? invalidChangeSet,
    TResult? Function()? couldNotLoad,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function(String errorMessage)? invalidChangeSet,
    TResult Function()? couldNotLoad,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadWithPersistError_Persist value) persist,
    required TResult Function(LoadWithPersistError_InvalidChangeSet value)
        invalidChangeSet,
    required TResult Function(LoadWithPersistError_CouldNotLoad value)
        couldNotLoad,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadWithPersistError_Persist value)? persist,
    TResult? Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult? Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadWithPersistError_Persist value)? persist,
    TResult Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoadWithPersistErrorCopyWith<$Res> {
  factory $LoadWithPersistErrorCopyWith(LoadWithPersistError value,
          $Res Function(LoadWithPersistError) then) =
      _$LoadWithPersistErrorCopyWithImpl<$Res, LoadWithPersistError>;
}

/// @nodoc
class _$LoadWithPersistErrorCopyWithImpl<$Res,
        $Val extends LoadWithPersistError>
    implements $LoadWithPersistErrorCopyWith<$Res> {
  _$LoadWithPersistErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadWithPersistError_PersistImplCopyWith<$Res> {
  factory _$$LoadWithPersistError_PersistImplCopyWith(
          _$LoadWithPersistError_PersistImpl value,
          $Res Function(_$LoadWithPersistError_PersistImpl) then) =
      __$$LoadWithPersistError_PersistImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$LoadWithPersistError_PersistImplCopyWithImpl<$Res>
    extends _$LoadWithPersistErrorCopyWithImpl<$Res,
        _$LoadWithPersistError_PersistImpl>
    implements _$$LoadWithPersistError_PersistImplCopyWith<$Res> {
  __$$LoadWithPersistError_PersistImplCopyWithImpl(
      _$LoadWithPersistError_PersistImpl _value,
      $Res Function(_$LoadWithPersistError_PersistImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$LoadWithPersistError_PersistImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadWithPersistError_PersistImpl extends LoadWithPersistError_Persist {
  const _$LoadWithPersistError_PersistImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'LoadWithPersistError.persist(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadWithPersistError_PersistImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadWithPersistError_PersistImplCopyWith<
          _$LoadWithPersistError_PersistImpl>
      get copyWith => __$$LoadWithPersistError_PersistImplCopyWithImpl<
          _$LoadWithPersistError_PersistImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function(String errorMessage) invalidChangeSet,
    required TResult Function() couldNotLoad,
  }) {
    return persist(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function(String errorMessage)? invalidChangeSet,
    TResult? Function()? couldNotLoad,
  }) {
    return persist?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function(String errorMessage)? invalidChangeSet,
    TResult Function()? couldNotLoad,
    required TResult orElse(),
  }) {
    if (persist != null) {
      return persist(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadWithPersistError_Persist value) persist,
    required TResult Function(LoadWithPersistError_InvalidChangeSet value)
        invalidChangeSet,
    required TResult Function(LoadWithPersistError_CouldNotLoad value)
        couldNotLoad,
  }) {
    return persist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadWithPersistError_Persist value)? persist,
    TResult? Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult? Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
  }) {
    return persist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadWithPersistError_Persist value)? persist,
    TResult Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
    required TResult orElse(),
  }) {
    if (persist != null) {
      return persist(this);
    }
    return orElse();
  }
}

abstract class LoadWithPersistError_Persist extends LoadWithPersistError {
  const factory LoadWithPersistError_Persist(
          {required final String errorMessage}) =
      _$LoadWithPersistError_PersistImpl;
  const LoadWithPersistError_Persist._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$LoadWithPersistError_PersistImplCopyWith<
          _$LoadWithPersistError_PersistImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadWithPersistError_InvalidChangeSetImplCopyWith<$Res> {
  factory _$$LoadWithPersistError_InvalidChangeSetImplCopyWith(
          _$LoadWithPersistError_InvalidChangeSetImpl value,
          $Res Function(_$LoadWithPersistError_InvalidChangeSetImpl) then) =
      __$$LoadWithPersistError_InvalidChangeSetImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$LoadWithPersistError_InvalidChangeSetImplCopyWithImpl<$Res>
    extends _$LoadWithPersistErrorCopyWithImpl<$Res,
        _$LoadWithPersistError_InvalidChangeSetImpl>
    implements _$$LoadWithPersistError_InvalidChangeSetImplCopyWith<$Res> {
  __$$LoadWithPersistError_InvalidChangeSetImplCopyWithImpl(
      _$LoadWithPersistError_InvalidChangeSetImpl _value,
      $Res Function(_$LoadWithPersistError_InvalidChangeSetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$LoadWithPersistError_InvalidChangeSetImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadWithPersistError_InvalidChangeSetImpl
    extends LoadWithPersistError_InvalidChangeSet {
  const _$LoadWithPersistError_InvalidChangeSetImpl(
      {required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'LoadWithPersistError.invalidChangeSet(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadWithPersistError_InvalidChangeSetImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadWithPersistError_InvalidChangeSetImplCopyWith<
          _$LoadWithPersistError_InvalidChangeSetImpl>
      get copyWith => __$$LoadWithPersistError_InvalidChangeSetImplCopyWithImpl<
          _$LoadWithPersistError_InvalidChangeSetImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function(String errorMessage) invalidChangeSet,
    required TResult Function() couldNotLoad,
  }) {
    return invalidChangeSet(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function(String errorMessage)? invalidChangeSet,
    TResult? Function()? couldNotLoad,
  }) {
    return invalidChangeSet?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function(String errorMessage)? invalidChangeSet,
    TResult Function()? couldNotLoad,
    required TResult orElse(),
  }) {
    if (invalidChangeSet != null) {
      return invalidChangeSet(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadWithPersistError_Persist value) persist,
    required TResult Function(LoadWithPersistError_InvalidChangeSet value)
        invalidChangeSet,
    required TResult Function(LoadWithPersistError_CouldNotLoad value)
        couldNotLoad,
  }) {
    return invalidChangeSet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadWithPersistError_Persist value)? persist,
    TResult? Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult? Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
  }) {
    return invalidChangeSet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadWithPersistError_Persist value)? persist,
    TResult Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
    required TResult orElse(),
  }) {
    if (invalidChangeSet != null) {
      return invalidChangeSet(this);
    }
    return orElse();
  }
}

abstract class LoadWithPersistError_InvalidChangeSet
    extends LoadWithPersistError {
  const factory LoadWithPersistError_InvalidChangeSet(
          {required final String errorMessage}) =
      _$LoadWithPersistError_InvalidChangeSetImpl;
  const LoadWithPersistError_InvalidChangeSet._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$LoadWithPersistError_InvalidChangeSetImplCopyWith<
          _$LoadWithPersistError_InvalidChangeSetImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadWithPersistError_CouldNotLoadImplCopyWith<$Res> {
  factory _$$LoadWithPersistError_CouldNotLoadImplCopyWith(
          _$LoadWithPersistError_CouldNotLoadImpl value,
          $Res Function(_$LoadWithPersistError_CouldNotLoadImpl) then) =
      __$$LoadWithPersistError_CouldNotLoadImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadWithPersistError_CouldNotLoadImplCopyWithImpl<$Res>
    extends _$LoadWithPersistErrorCopyWithImpl<$Res,
        _$LoadWithPersistError_CouldNotLoadImpl>
    implements _$$LoadWithPersistError_CouldNotLoadImplCopyWith<$Res> {
  __$$LoadWithPersistError_CouldNotLoadImplCopyWithImpl(
      _$LoadWithPersistError_CouldNotLoadImpl _value,
      $Res Function(_$LoadWithPersistError_CouldNotLoadImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadWithPersistError_CouldNotLoadImpl
    extends LoadWithPersistError_CouldNotLoad {
  const _$LoadWithPersistError_CouldNotLoadImpl() : super._();

  @override
  String toString() {
    return 'LoadWithPersistError.couldNotLoad()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadWithPersistError_CouldNotLoadImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) persist,
    required TResult Function(String errorMessage) invalidChangeSet,
    required TResult Function() couldNotLoad,
  }) {
    return couldNotLoad();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? persist,
    TResult? Function(String errorMessage)? invalidChangeSet,
    TResult? Function()? couldNotLoad,
  }) {
    return couldNotLoad?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? persist,
    TResult Function(String errorMessage)? invalidChangeSet,
    TResult Function()? couldNotLoad,
    required TResult orElse(),
  }) {
    if (couldNotLoad != null) {
      return couldNotLoad();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadWithPersistError_Persist value) persist,
    required TResult Function(LoadWithPersistError_InvalidChangeSet value)
        invalidChangeSet,
    required TResult Function(LoadWithPersistError_CouldNotLoad value)
        couldNotLoad,
  }) {
    return couldNotLoad(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadWithPersistError_Persist value)? persist,
    TResult? Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult? Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
  }) {
    return couldNotLoad?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadWithPersistError_Persist value)? persist,
    TResult Function(LoadWithPersistError_InvalidChangeSet value)?
        invalidChangeSet,
    TResult Function(LoadWithPersistError_CouldNotLoad value)? couldNotLoad,
    required TResult orElse(),
  }) {
    if (couldNotLoad != null) {
      return couldNotLoad(this);
    }
    return orElse();
  }
}

abstract class LoadWithPersistError_CouldNotLoad extends LoadWithPersistError {
  const factory LoadWithPersistError_CouldNotLoad() =
      _$LoadWithPersistError_CouldNotLoadImpl;
  const LoadWithPersistError_CouldNotLoad._() : super._();
}

/// @nodoc
mixin _$PsbtError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PsbtErrorCopyWith<$Res> {
  factory $PsbtErrorCopyWith(PsbtError value, $Res Function(PsbtError) then) =
      _$PsbtErrorCopyWithImpl<$Res, PsbtError>;
}

/// @nodoc
class _$PsbtErrorCopyWithImpl<$Res, $Val extends PsbtError>
    implements $PsbtErrorCopyWith<$Res> {
  _$PsbtErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PsbtError_InvalidMagicImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidMagicImplCopyWith(
          _$PsbtError_InvalidMagicImpl value,
          $Res Function(_$PsbtError_InvalidMagicImpl) then) =
      __$$PsbtError_InvalidMagicImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidMagicImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidMagicImpl>
    implements _$$PsbtError_InvalidMagicImplCopyWith<$Res> {
  __$$PsbtError_InvalidMagicImplCopyWithImpl(
      _$PsbtError_InvalidMagicImpl _value,
      $Res Function(_$PsbtError_InvalidMagicImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidMagicImpl extends PsbtError_InvalidMagic {
  const _$PsbtError_InvalidMagicImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidMagic()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidMagicImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidMagic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidMagic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidMagic != null) {
      return invalidMagic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidMagic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidMagic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidMagic != null) {
      return invalidMagic(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidMagic extends PsbtError {
  const factory PsbtError_InvalidMagic() = _$PsbtError_InvalidMagicImpl;
  const PsbtError_InvalidMagic._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_MissingUtxoImplCopyWith<$Res> {
  factory _$$PsbtError_MissingUtxoImplCopyWith(
          _$PsbtError_MissingUtxoImpl value,
          $Res Function(_$PsbtError_MissingUtxoImpl) then) =
      __$$PsbtError_MissingUtxoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_MissingUtxoImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_MissingUtxoImpl>
    implements _$$PsbtError_MissingUtxoImplCopyWith<$Res> {
  __$$PsbtError_MissingUtxoImplCopyWithImpl(_$PsbtError_MissingUtxoImpl _value,
      $Res Function(_$PsbtError_MissingUtxoImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_MissingUtxoImpl extends PsbtError_MissingUtxo {
  const _$PsbtError_MissingUtxoImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.missingUtxo()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_MissingUtxoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return missingUtxo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return missingUtxo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (missingUtxo != null) {
      return missingUtxo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return missingUtxo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return missingUtxo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (missingUtxo != null) {
      return missingUtxo(this);
    }
    return orElse();
  }
}

abstract class PsbtError_MissingUtxo extends PsbtError {
  const factory PsbtError_MissingUtxo() = _$PsbtError_MissingUtxoImpl;
  const PsbtError_MissingUtxo._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_InvalidSeparatorImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidSeparatorImplCopyWith(
          _$PsbtError_InvalidSeparatorImpl value,
          $Res Function(_$PsbtError_InvalidSeparatorImpl) then) =
      __$$PsbtError_InvalidSeparatorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidSeparatorImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidSeparatorImpl>
    implements _$$PsbtError_InvalidSeparatorImplCopyWith<$Res> {
  __$$PsbtError_InvalidSeparatorImplCopyWithImpl(
      _$PsbtError_InvalidSeparatorImpl _value,
      $Res Function(_$PsbtError_InvalidSeparatorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidSeparatorImpl extends PsbtError_InvalidSeparator {
  const _$PsbtError_InvalidSeparatorImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidSeparator()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidSeparatorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidSeparator();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidSeparator?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidSeparator != null) {
      return invalidSeparator();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidSeparator(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidSeparator?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidSeparator != null) {
      return invalidSeparator(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidSeparator extends PsbtError {
  const factory PsbtError_InvalidSeparator() = _$PsbtError_InvalidSeparatorImpl;
  const PsbtError_InvalidSeparator._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWith<$Res> {
  factory _$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWith(
          _$PsbtError_PsbtUtxoOutOfBoundsImpl value,
          $Res Function(_$PsbtError_PsbtUtxoOutOfBoundsImpl) then) =
      __$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_PsbtUtxoOutOfBoundsImpl>
    implements _$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWith<$Res> {
  __$$PsbtError_PsbtUtxoOutOfBoundsImplCopyWithImpl(
      _$PsbtError_PsbtUtxoOutOfBoundsImpl _value,
      $Res Function(_$PsbtError_PsbtUtxoOutOfBoundsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_PsbtUtxoOutOfBoundsImpl
    extends PsbtError_PsbtUtxoOutOfBounds {
  const _$PsbtError_PsbtUtxoOutOfBoundsImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.psbtUtxoOutOfBounds()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_PsbtUtxoOutOfBoundsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return psbtUtxoOutOfBounds();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return psbtUtxoOutOfBounds?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (psbtUtxoOutOfBounds != null) {
      return psbtUtxoOutOfBounds();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return psbtUtxoOutOfBounds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return psbtUtxoOutOfBounds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (psbtUtxoOutOfBounds != null) {
      return psbtUtxoOutOfBounds(this);
    }
    return orElse();
  }
}

abstract class PsbtError_PsbtUtxoOutOfBounds extends PsbtError {
  const factory PsbtError_PsbtUtxoOutOfBounds() =
      _$PsbtError_PsbtUtxoOutOfBoundsImpl;
  const PsbtError_PsbtUtxoOutOfBounds._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_InvalidKeyImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidKeyImplCopyWith(_$PsbtError_InvalidKeyImpl value,
          $Res Function(_$PsbtError_InvalidKeyImpl) then) =
      __$$PsbtError_InvalidKeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$PsbtError_InvalidKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidKeyImpl>
    implements _$$PsbtError_InvalidKeyImplCopyWith<$Res> {
  __$$PsbtError_InvalidKeyImplCopyWithImpl(_$PsbtError_InvalidKeyImpl _value,
      $Res Function(_$PsbtError_InvalidKeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$PsbtError_InvalidKeyImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidKeyImpl extends PsbtError_InvalidKey {
  const _$PsbtError_InvalidKeyImpl({required this.key}) : super._();

  @override
  final String key;

  @override
  String toString() {
    return 'PsbtError.invalidKey(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidKeyImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidKeyImplCopyWith<_$PsbtError_InvalidKeyImpl>
      get copyWith =>
          __$$PsbtError_InvalidKeyImplCopyWithImpl<_$PsbtError_InvalidKeyImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidKey(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidKey?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidKey != null) {
      return invalidKey(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidKey != null) {
      return invalidKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidKey extends PsbtError {
  const factory PsbtError_InvalidKey({required final String key}) =
      _$PsbtError_InvalidKeyImpl;
  const PsbtError_InvalidKey._() : super._();

  String get key;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidKeyImplCopyWith<_$PsbtError_InvalidKeyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidProprietaryKeyImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidProprietaryKeyImplCopyWith(
          _$PsbtError_InvalidProprietaryKeyImpl value,
          $Res Function(_$PsbtError_InvalidProprietaryKeyImpl) then) =
      __$$PsbtError_InvalidProprietaryKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidProprietaryKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidProprietaryKeyImpl>
    implements _$$PsbtError_InvalidProprietaryKeyImplCopyWith<$Res> {
  __$$PsbtError_InvalidProprietaryKeyImplCopyWithImpl(
      _$PsbtError_InvalidProprietaryKeyImpl _value,
      $Res Function(_$PsbtError_InvalidProprietaryKeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidProprietaryKeyImpl
    extends PsbtError_InvalidProprietaryKey {
  const _$PsbtError_InvalidProprietaryKeyImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidProprietaryKey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidProprietaryKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidProprietaryKey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidProprietaryKey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidProprietaryKey != null) {
      return invalidProprietaryKey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidProprietaryKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidProprietaryKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidProprietaryKey != null) {
      return invalidProprietaryKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidProprietaryKey extends PsbtError {
  const factory PsbtError_InvalidProprietaryKey() =
      _$PsbtError_InvalidProprietaryKeyImpl;
  const PsbtError_InvalidProprietaryKey._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_DuplicateKeyImplCopyWith<$Res> {
  factory _$$PsbtError_DuplicateKeyImplCopyWith(
          _$PsbtError_DuplicateKeyImpl value,
          $Res Function(_$PsbtError_DuplicateKeyImpl) then) =
      __$$PsbtError_DuplicateKeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$PsbtError_DuplicateKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_DuplicateKeyImpl>
    implements _$$PsbtError_DuplicateKeyImplCopyWith<$Res> {
  __$$PsbtError_DuplicateKeyImplCopyWithImpl(
      _$PsbtError_DuplicateKeyImpl _value,
      $Res Function(_$PsbtError_DuplicateKeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$PsbtError_DuplicateKeyImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_DuplicateKeyImpl extends PsbtError_DuplicateKey {
  const _$PsbtError_DuplicateKeyImpl({required this.key}) : super._();

  @override
  final String key;

  @override
  String toString() {
    return 'PsbtError.duplicateKey(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_DuplicateKeyImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_DuplicateKeyImplCopyWith<_$PsbtError_DuplicateKeyImpl>
      get copyWith => __$$PsbtError_DuplicateKeyImplCopyWithImpl<
          _$PsbtError_DuplicateKeyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return duplicateKey(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return duplicateKey?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (duplicateKey != null) {
      return duplicateKey(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return duplicateKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return duplicateKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (duplicateKey != null) {
      return duplicateKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_DuplicateKey extends PsbtError {
  const factory PsbtError_DuplicateKey({required final String key}) =
      _$PsbtError_DuplicateKeyImpl;
  const PsbtError_DuplicateKey._() : super._();

  String get key;
  @JsonKey(ignore: true)
  _$$PsbtError_DuplicateKeyImplCopyWith<_$PsbtError_DuplicateKeyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_UnsignedTxHasScriptSigsImplCopyWith<$Res> {
  factory _$$PsbtError_UnsignedTxHasScriptSigsImplCopyWith(
          _$PsbtError_UnsignedTxHasScriptSigsImpl value,
          $Res Function(_$PsbtError_UnsignedTxHasScriptSigsImpl) then) =
      __$$PsbtError_UnsignedTxHasScriptSigsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_UnsignedTxHasScriptSigsImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_UnsignedTxHasScriptSigsImpl>
    implements _$$PsbtError_UnsignedTxHasScriptSigsImplCopyWith<$Res> {
  __$$PsbtError_UnsignedTxHasScriptSigsImplCopyWithImpl(
      _$PsbtError_UnsignedTxHasScriptSigsImpl _value,
      $Res Function(_$PsbtError_UnsignedTxHasScriptSigsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_UnsignedTxHasScriptSigsImpl
    extends PsbtError_UnsignedTxHasScriptSigs {
  const _$PsbtError_UnsignedTxHasScriptSigsImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.unsignedTxHasScriptSigs()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_UnsignedTxHasScriptSigsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return unsignedTxHasScriptSigs();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return unsignedTxHasScriptSigs?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unsignedTxHasScriptSigs != null) {
      return unsignedTxHasScriptSigs();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return unsignedTxHasScriptSigs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return unsignedTxHasScriptSigs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unsignedTxHasScriptSigs != null) {
      return unsignedTxHasScriptSigs(this);
    }
    return orElse();
  }
}

abstract class PsbtError_UnsignedTxHasScriptSigs extends PsbtError {
  const factory PsbtError_UnsignedTxHasScriptSigs() =
      _$PsbtError_UnsignedTxHasScriptSigsImpl;
  const PsbtError_UnsignedTxHasScriptSigs._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWith<$Res> {
  factory _$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWith(
          _$PsbtError_UnsignedTxHasScriptWitnessesImpl value,
          $Res Function(_$PsbtError_UnsignedTxHasScriptWitnessesImpl) then) =
      __$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_UnsignedTxHasScriptWitnessesImpl>
    implements _$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWith<$Res> {
  __$$PsbtError_UnsignedTxHasScriptWitnessesImplCopyWithImpl(
      _$PsbtError_UnsignedTxHasScriptWitnessesImpl _value,
      $Res Function(_$PsbtError_UnsignedTxHasScriptWitnessesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_UnsignedTxHasScriptWitnessesImpl
    extends PsbtError_UnsignedTxHasScriptWitnesses {
  const _$PsbtError_UnsignedTxHasScriptWitnessesImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.unsignedTxHasScriptWitnesses()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_UnsignedTxHasScriptWitnessesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return unsignedTxHasScriptWitnesses();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return unsignedTxHasScriptWitnesses?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unsignedTxHasScriptWitnesses != null) {
      return unsignedTxHasScriptWitnesses();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return unsignedTxHasScriptWitnesses(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return unsignedTxHasScriptWitnesses?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unsignedTxHasScriptWitnesses != null) {
      return unsignedTxHasScriptWitnesses(this);
    }
    return orElse();
  }
}

abstract class PsbtError_UnsignedTxHasScriptWitnesses extends PsbtError {
  const factory PsbtError_UnsignedTxHasScriptWitnesses() =
      _$PsbtError_UnsignedTxHasScriptWitnessesImpl;
  const PsbtError_UnsignedTxHasScriptWitnesses._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_MustHaveUnsignedTxImplCopyWith<$Res> {
  factory _$$PsbtError_MustHaveUnsignedTxImplCopyWith(
          _$PsbtError_MustHaveUnsignedTxImpl value,
          $Res Function(_$PsbtError_MustHaveUnsignedTxImpl) then) =
      __$$PsbtError_MustHaveUnsignedTxImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_MustHaveUnsignedTxImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_MustHaveUnsignedTxImpl>
    implements _$$PsbtError_MustHaveUnsignedTxImplCopyWith<$Res> {
  __$$PsbtError_MustHaveUnsignedTxImplCopyWithImpl(
      _$PsbtError_MustHaveUnsignedTxImpl _value,
      $Res Function(_$PsbtError_MustHaveUnsignedTxImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_MustHaveUnsignedTxImpl extends PsbtError_MustHaveUnsignedTx {
  const _$PsbtError_MustHaveUnsignedTxImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.mustHaveUnsignedTx()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_MustHaveUnsignedTxImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return mustHaveUnsignedTx();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return mustHaveUnsignedTx?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (mustHaveUnsignedTx != null) {
      return mustHaveUnsignedTx();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return mustHaveUnsignedTx(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return mustHaveUnsignedTx?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (mustHaveUnsignedTx != null) {
      return mustHaveUnsignedTx(this);
    }
    return orElse();
  }
}

abstract class PsbtError_MustHaveUnsignedTx extends PsbtError {
  const factory PsbtError_MustHaveUnsignedTx() =
      _$PsbtError_MustHaveUnsignedTxImpl;
  const PsbtError_MustHaveUnsignedTx._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_NoMorePairsImplCopyWith<$Res> {
  factory _$$PsbtError_NoMorePairsImplCopyWith(
          _$PsbtError_NoMorePairsImpl value,
          $Res Function(_$PsbtError_NoMorePairsImpl) then) =
      __$$PsbtError_NoMorePairsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_NoMorePairsImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_NoMorePairsImpl>
    implements _$$PsbtError_NoMorePairsImplCopyWith<$Res> {
  __$$PsbtError_NoMorePairsImplCopyWithImpl(_$PsbtError_NoMorePairsImpl _value,
      $Res Function(_$PsbtError_NoMorePairsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_NoMorePairsImpl extends PsbtError_NoMorePairs {
  const _$PsbtError_NoMorePairsImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.noMorePairs()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_NoMorePairsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return noMorePairs();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return noMorePairs?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (noMorePairs != null) {
      return noMorePairs();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return noMorePairs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return noMorePairs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (noMorePairs != null) {
      return noMorePairs(this);
    }
    return orElse();
  }
}

abstract class PsbtError_NoMorePairs extends PsbtError {
  const factory PsbtError_NoMorePairs() = _$PsbtError_NoMorePairsImpl;
  const PsbtError_NoMorePairs._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_UnexpectedUnsignedTxImplCopyWith<$Res> {
  factory _$$PsbtError_UnexpectedUnsignedTxImplCopyWith(
          _$PsbtError_UnexpectedUnsignedTxImpl value,
          $Res Function(_$PsbtError_UnexpectedUnsignedTxImpl) then) =
      __$$PsbtError_UnexpectedUnsignedTxImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_UnexpectedUnsignedTxImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_UnexpectedUnsignedTxImpl>
    implements _$$PsbtError_UnexpectedUnsignedTxImplCopyWith<$Res> {
  __$$PsbtError_UnexpectedUnsignedTxImplCopyWithImpl(
      _$PsbtError_UnexpectedUnsignedTxImpl _value,
      $Res Function(_$PsbtError_UnexpectedUnsignedTxImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_UnexpectedUnsignedTxImpl
    extends PsbtError_UnexpectedUnsignedTx {
  const _$PsbtError_UnexpectedUnsignedTxImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.unexpectedUnsignedTx()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_UnexpectedUnsignedTxImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return unexpectedUnsignedTx();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return unexpectedUnsignedTx?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unexpectedUnsignedTx != null) {
      return unexpectedUnsignedTx();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return unexpectedUnsignedTx(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return unexpectedUnsignedTx?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (unexpectedUnsignedTx != null) {
      return unexpectedUnsignedTx(this);
    }
    return orElse();
  }
}

abstract class PsbtError_UnexpectedUnsignedTx extends PsbtError {
  const factory PsbtError_UnexpectedUnsignedTx() =
      _$PsbtError_UnexpectedUnsignedTxImpl;
  const PsbtError_UnexpectedUnsignedTx._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_NonStandardSighashTypeImplCopyWith<$Res> {
  factory _$$PsbtError_NonStandardSighashTypeImplCopyWith(
          _$PsbtError_NonStandardSighashTypeImpl value,
          $Res Function(_$PsbtError_NonStandardSighashTypeImpl) then) =
      __$$PsbtError_NonStandardSighashTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int sighash});
}

/// @nodoc
class __$$PsbtError_NonStandardSighashTypeImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_NonStandardSighashTypeImpl>
    implements _$$PsbtError_NonStandardSighashTypeImplCopyWith<$Res> {
  __$$PsbtError_NonStandardSighashTypeImplCopyWithImpl(
      _$PsbtError_NonStandardSighashTypeImpl _value,
      $Res Function(_$PsbtError_NonStandardSighashTypeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sighash = null,
  }) {
    return _then(_$PsbtError_NonStandardSighashTypeImpl(
      sighash: null == sighash
          ? _value.sighash
          : sighash // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PsbtError_NonStandardSighashTypeImpl
    extends PsbtError_NonStandardSighashType {
  const _$PsbtError_NonStandardSighashTypeImpl({required this.sighash})
      : super._();

  @override
  final int sighash;

  @override
  String toString() {
    return 'PsbtError.nonStandardSighashType(sighash: $sighash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_NonStandardSighashTypeImpl &&
            (identical(other.sighash, sighash) || other.sighash == sighash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, sighash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_NonStandardSighashTypeImplCopyWith<
          _$PsbtError_NonStandardSighashTypeImpl>
      get copyWith => __$$PsbtError_NonStandardSighashTypeImplCopyWithImpl<
          _$PsbtError_NonStandardSighashTypeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return nonStandardSighashType(sighash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return nonStandardSighashType?.call(sighash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (nonStandardSighashType != null) {
      return nonStandardSighashType(sighash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return nonStandardSighashType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return nonStandardSighashType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (nonStandardSighashType != null) {
      return nonStandardSighashType(this);
    }
    return orElse();
  }
}

abstract class PsbtError_NonStandardSighashType extends PsbtError {
  const factory PsbtError_NonStandardSighashType({required final int sighash}) =
      _$PsbtError_NonStandardSighashTypeImpl;
  const PsbtError_NonStandardSighashType._() : super._();

  int get sighash;
  @JsonKey(ignore: true)
  _$$PsbtError_NonStandardSighashTypeImplCopyWith<
          _$PsbtError_NonStandardSighashTypeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidHashImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidHashImplCopyWith(
          _$PsbtError_InvalidHashImpl value,
          $Res Function(_$PsbtError_InvalidHashImpl) then) =
      __$$PsbtError_InvalidHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String hash});
}

/// @nodoc
class __$$PsbtError_InvalidHashImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidHashImpl>
    implements _$$PsbtError_InvalidHashImplCopyWith<$Res> {
  __$$PsbtError_InvalidHashImplCopyWithImpl(_$PsbtError_InvalidHashImpl _value,
      $Res Function(_$PsbtError_InvalidHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
  }) {
    return _then(_$PsbtError_InvalidHashImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidHashImpl extends PsbtError_InvalidHash {
  const _$PsbtError_InvalidHashImpl({required this.hash}) : super._();

  @override
  final String hash;

  @override
  String toString() {
    return 'PsbtError.invalidHash(hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidHashImpl &&
            (identical(other.hash, hash) || other.hash == hash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidHashImplCopyWith<_$PsbtError_InvalidHashImpl>
      get copyWith => __$$PsbtError_InvalidHashImplCopyWithImpl<
          _$PsbtError_InvalidHashImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidHash(hash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidHash?.call(hash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidHash != null) {
      return invalidHash(hash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidHash != null) {
      return invalidHash(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidHash extends PsbtError {
  const factory PsbtError_InvalidHash({required final String hash}) =
      _$PsbtError_InvalidHashImpl;
  const PsbtError_InvalidHash._() : super._();

  String get hash;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidHashImplCopyWith<_$PsbtError_InvalidHashImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidPreimageHashPairImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidPreimageHashPairImplCopyWith(
          _$PsbtError_InvalidPreimageHashPairImpl value,
          $Res Function(_$PsbtError_InvalidPreimageHashPairImpl) then) =
      __$$PsbtError_InvalidPreimageHashPairImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidPreimageHashPairImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_InvalidPreimageHashPairImpl>
    implements _$$PsbtError_InvalidPreimageHashPairImplCopyWith<$Res> {
  __$$PsbtError_InvalidPreimageHashPairImplCopyWithImpl(
      _$PsbtError_InvalidPreimageHashPairImpl _value,
      $Res Function(_$PsbtError_InvalidPreimageHashPairImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidPreimageHashPairImpl
    extends PsbtError_InvalidPreimageHashPair {
  const _$PsbtError_InvalidPreimageHashPairImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidPreimageHashPair()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidPreimageHashPairImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidPreimageHashPair();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidPreimageHashPair?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidPreimageHashPair != null) {
      return invalidPreimageHashPair();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidPreimageHashPair(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidPreimageHashPair?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidPreimageHashPair != null) {
      return invalidPreimageHashPair(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidPreimageHashPair extends PsbtError {
  const factory PsbtError_InvalidPreimageHashPair() =
      _$PsbtError_InvalidPreimageHashPairImpl;
  const PsbtError_InvalidPreimageHashPair._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_CombineInconsistentKeySourcesImplCopyWith<$Res> {
  factory _$$PsbtError_CombineInconsistentKeySourcesImplCopyWith(
          _$PsbtError_CombineInconsistentKeySourcesImpl value,
          $Res Function(_$PsbtError_CombineInconsistentKeySourcesImpl) then) =
      __$$PsbtError_CombineInconsistentKeySourcesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String xpub});
}

/// @nodoc
class __$$PsbtError_CombineInconsistentKeySourcesImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_CombineInconsistentKeySourcesImpl>
    implements _$$PsbtError_CombineInconsistentKeySourcesImplCopyWith<$Res> {
  __$$PsbtError_CombineInconsistentKeySourcesImplCopyWithImpl(
      _$PsbtError_CombineInconsistentKeySourcesImpl _value,
      $Res Function(_$PsbtError_CombineInconsistentKeySourcesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xpub = null,
  }) {
    return _then(_$PsbtError_CombineInconsistentKeySourcesImpl(
      xpub: null == xpub
          ? _value.xpub
          : xpub // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_CombineInconsistentKeySourcesImpl
    extends PsbtError_CombineInconsistentKeySources {
  const _$PsbtError_CombineInconsistentKeySourcesImpl({required this.xpub})
      : super._();

  @override
  final String xpub;

  @override
  String toString() {
    return 'PsbtError.combineInconsistentKeySources(xpub: $xpub)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_CombineInconsistentKeySourcesImpl &&
            (identical(other.xpub, xpub) || other.xpub == xpub));
  }

  @override
  int get hashCode => Object.hash(runtimeType, xpub);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_CombineInconsistentKeySourcesImplCopyWith<
          _$PsbtError_CombineInconsistentKeySourcesImpl>
      get copyWith =>
          __$$PsbtError_CombineInconsistentKeySourcesImplCopyWithImpl<
              _$PsbtError_CombineInconsistentKeySourcesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return combineInconsistentKeySources(xpub);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return combineInconsistentKeySources?.call(xpub);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (combineInconsistentKeySources != null) {
      return combineInconsistentKeySources(xpub);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return combineInconsistentKeySources(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return combineInconsistentKeySources?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (combineInconsistentKeySources != null) {
      return combineInconsistentKeySources(this);
    }
    return orElse();
  }
}

abstract class PsbtError_CombineInconsistentKeySources extends PsbtError {
  const factory PsbtError_CombineInconsistentKeySources(
          {required final String xpub}) =
      _$PsbtError_CombineInconsistentKeySourcesImpl;
  const PsbtError_CombineInconsistentKeySources._() : super._();

  String get xpub;
  @JsonKey(ignore: true)
  _$$PsbtError_CombineInconsistentKeySourcesImplCopyWith<
          _$PsbtError_CombineInconsistentKeySourcesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_ConsensusEncodingImplCopyWith<$Res> {
  factory _$$PsbtError_ConsensusEncodingImplCopyWith(
          _$PsbtError_ConsensusEncodingImpl value,
          $Res Function(_$PsbtError_ConsensusEncodingImpl) then) =
      __$$PsbtError_ConsensusEncodingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String encodingError});
}

/// @nodoc
class __$$PsbtError_ConsensusEncodingImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_ConsensusEncodingImpl>
    implements _$$PsbtError_ConsensusEncodingImplCopyWith<$Res> {
  __$$PsbtError_ConsensusEncodingImplCopyWithImpl(
      _$PsbtError_ConsensusEncodingImpl _value,
      $Res Function(_$PsbtError_ConsensusEncodingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? encodingError = null,
  }) {
    return _then(_$PsbtError_ConsensusEncodingImpl(
      encodingError: null == encodingError
          ? _value.encodingError
          : encodingError // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_ConsensusEncodingImpl extends PsbtError_ConsensusEncoding {
  const _$PsbtError_ConsensusEncodingImpl({required this.encodingError})
      : super._();

  @override
  final String encodingError;

  @override
  String toString() {
    return 'PsbtError.consensusEncoding(encodingError: $encodingError)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_ConsensusEncodingImpl &&
            (identical(other.encodingError, encodingError) ||
                other.encodingError == encodingError));
  }

  @override
  int get hashCode => Object.hash(runtimeType, encodingError);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_ConsensusEncodingImplCopyWith<_$PsbtError_ConsensusEncodingImpl>
      get copyWith => __$$PsbtError_ConsensusEncodingImplCopyWithImpl<
          _$PsbtError_ConsensusEncodingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return consensusEncoding(encodingError);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return consensusEncoding?.call(encodingError);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (consensusEncoding != null) {
      return consensusEncoding(encodingError);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return consensusEncoding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return consensusEncoding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (consensusEncoding != null) {
      return consensusEncoding(this);
    }
    return orElse();
  }
}

abstract class PsbtError_ConsensusEncoding extends PsbtError {
  const factory PsbtError_ConsensusEncoding(
          {required final String encodingError}) =
      _$PsbtError_ConsensusEncodingImpl;
  const PsbtError_ConsensusEncoding._() : super._();

  String get encodingError;
  @JsonKey(ignore: true)
  _$$PsbtError_ConsensusEncodingImplCopyWith<_$PsbtError_ConsensusEncodingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_NegativeFeeImplCopyWith<$Res> {
  factory _$$PsbtError_NegativeFeeImplCopyWith(
          _$PsbtError_NegativeFeeImpl value,
          $Res Function(_$PsbtError_NegativeFeeImpl) then) =
      __$$PsbtError_NegativeFeeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_NegativeFeeImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_NegativeFeeImpl>
    implements _$$PsbtError_NegativeFeeImplCopyWith<$Res> {
  __$$PsbtError_NegativeFeeImplCopyWithImpl(_$PsbtError_NegativeFeeImpl _value,
      $Res Function(_$PsbtError_NegativeFeeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_NegativeFeeImpl extends PsbtError_NegativeFee {
  const _$PsbtError_NegativeFeeImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.negativeFee()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_NegativeFeeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return negativeFee();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return negativeFee?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (negativeFee != null) {
      return negativeFee();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return negativeFee(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return negativeFee?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (negativeFee != null) {
      return negativeFee(this);
    }
    return orElse();
  }
}

abstract class PsbtError_NegativeFee extends PsbtError {
  const factory PsbtError_NegativeFee() = _$PsbtError_NegativeFeeImpl;
  const PsbtError_NegativeFee._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_FeeOverflowImplCopyWith<$Res> {
  factory _$$PsbtError_FeeOverflowImplCopyWith(
          _$PsbtError_FeeOverflowImpl value,
          $Res Function(_$PsbtError_FeeOverflowImpl) then) =
      __$$PsbtError_FeeOverflowImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_FeeOverflowImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_FeeOverflowImpl>
    implements _$$PsbtError_FeeOverflowImplCopyWith<$Res> {
  __$$PsbtError_FeeOverflowImplCopyWithImpl(_$PsbtError_FeeOverflowImpl _value,
      $Res Function(_$PsbtError_FeeOverflowImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_FeeOverflowImpl extends PsbtError_FeeOverflow {
  const _$PsbtError_FeeOverflowImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.feeOverflow()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_FeeOverflowImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return feeOverflow();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return feeOverflow?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (feeOverflow != null) {
      return feeOverflow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return feeOverflow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return feeOverflow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (feeOverflow != null) {
      return feeOverflow(this);
    }
    return orElse();
  }
}

abstract class PsbtError_FeeOverflow extends PsbtError {
  const factory PsbtError_FeeOverflow() = _$PsbtError_FeeOverflowImpl;
  const PsbtError_FeeOverflow._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_InvalidPublicKeyImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidPublicKeyImplCopyWith(
          _$PsbtError_InvalidPublicKeyImpl value,
          $Res Function(_$PsbtError_InvalidPublicKeyImpl) then) =
      __$$PsbtError_InvalidPublicKeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_InvalidPublicKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidPublicKeyImpl>
    implements _$$PsbtError_InvalidPublicKeyImplCopyWith<$Res> {
  __$$PsbtError_InvalidPublicKeyImplCopyWithImpl(
      _$PsbtError_InvalidPublicKeyImpl _value,
      $Res Function(_$PsbtError_InvalidPublicKeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_InvalidPublicKeyImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidPublicKeyImpl extends PsbtError_InvalidPublicKey {
  const _$PsbtError_InvalidPublicKeyImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.invalidPublicKey(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidPublicKeyImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidPublicKeyImplCopyWith<_$PsbtError_InvalidPublicKeyImpl>
      get copyWith => __$$PsbtError_InvalidPublicKeyImplCopyWithImpl<
          _$PsbtError_InvalidPublicKeyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidPublicKey(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidPublicKey?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidPublicKey != null) {
      return invalidPublicKey(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidPublicKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidPublicKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidPublicKey != null) {
      return invalidPublicKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidPublicKey extends PsbtError {
  const factory PsbtError_InvalidPublicKey(
      {required final String errorMessage}) = _$PsbtError_InvalidPublicKeyImpl;
  const PsbtError_InvalidPublicKey._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidPublicKeyImplCopyWith<_$PsbtError_InvalidPublicKeyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWith(
          _$PsbtError_InvalidSecp256k1PublicKeyImpl value,
          $Res Function(_$PsbtError_InvalidSecp256k1PublicKeyImpl) then) =
      __$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String secp256K1Error});
}

/// @nodoc
class __$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_InvalidSecp256k1PublicKeyImpl>
    implements _$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWith<$Res> {
  __$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWithImpl(
      _$PsbtError_InvalidSecp256k1PublicKeyImpl _value,
      $Res Function(_$PsbtError_InvalidSecp256k1PublicKeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secp256K1Error = null,
  }) {
    return _then(_$PsbtError_InvalidSecp256k1PublicKeyImpl(
      secp256K1Error: null == secp256K1Error
          ? _value.secp256K1Error
          : secp256K1Error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidSecp256k1PublicKeyImpl
    extends PsbtError_InvalidSecp256k1PublicKey {
  const _$PsbtError_InvalidSecp256k1PublicKeyImpl(
      {required this.secp256K1Error})
      : super._();

  @override
  final String secp256K1Error;

  @override
  String toString() {
    return 'PsbtError.invalidSecp256K1PublicKey(secp256K1Error: $secp256K1Error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidSecp256k1PublicKeyImpl &&
            (identical(other.secp256K1Error, secp256K1Error) ||
                other.secp256K1Error == secp256K1Error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, secp256K1Error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWith<
          _$PsbtError_InvalidSecp256k1PublicKeyImpl>
      get copyWith => __$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWithImpl<
          _$PsbtError_InvalidSecp256k1PublicKeyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidSecp256K1PublicKey(secp256K1Error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidSecp256K1PublicKey?.call(secp256K1Error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidSecp256K1PublicKey != null) {
      return invalidSecp256K1PublicKey(secp256K1Error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidSecp256K1PublicKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidSecp256K1PublicKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidSecp256K1PublicKey != null) {
      return invalidSecp256K1PublicKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidSecp256k1PublicKey extends PsbtError {
  const factory PsbtError_InvalidSecp256k1PublicKey(
          {required final String secp256K1Error}) =
      _$PsbtError_InvalidSecp256k1PublicKeyImpl;
  const PsbtError_InvalidSecp256k1PublicKey._() : super._();

  String get secp256K1Error;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidSecp256k1PublicKeyImplCopyWith<
          _$PsbtError_InvalidSecp256k1PublicKeyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidXOnlyPublicKeyImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidXOnlyPublicKeyImplCopyWith(
          _$PsbtError_InvalidXOnlyPublicKeyImpl value,
          $Res Function(_$PsbtError_InvalidXOnlyPublicKeyImpl) then) =
      __$$PsbtError_InvalidXOnlyPublicKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidXOnlyPublicKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidXOnlyPublicKeyImpl>
    implements _$$PsbtError_InvalidXOnlyPublicKeyImplCopyWith<$Res> {
  __$$PsbtError_InvalidXOnlyPublicKeyImplCopyWithImpl(
      _$PsbtError_InvalidXOnlyPublicKeyImpl _value,
      $Res Function(_$PsbtError_InvalidXOnlyPublicKeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidXOnlyPublicKeyImpl
    extends PsbtError_InvalidXOnlyPublicKey {
  const _$PsbtError_InvalidXOnlyPublicKeyImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidXOnlyPublicKey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidXOnlyPublicKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidXOnlyPublicKey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidXOnlyPublicKey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidXOnlyPublicKey != null) {
      return invalidXOnlyPublicKey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidXOnlyPublicKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidXOnlyPublicKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidXOnlyPublicKey != null) {
      return invalidXOnlyPublicKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidXOnlyPublicKey extends PsbtError {
  const factory PsbtError_InvalidXOnlyPublicKey() =
      _$PsbtError_InvalidXOnlyPublicKeyImpl;
  const PsbtError_InvalidXOnlyPublicKey._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_InvalidEcdsaSignatureImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidEcdsaSignatureImplCopyWith(
          _$PsbtError_InvalidEcdsaSignatureImpl value,
          $Res Function(_$PsbtError_InvalidEcdsaSignatureImpl) then) =
      __$$PsbtError_InvalidEcdsaSignatureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_InvalidEcdsaSignatureImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidEcdsaSignatureImpl>
    implements _$$PsbtError_InvalidEcdsaSignatureImplCopyWith<$Res> {
  __$$PsbtError_InvalidEcdsaSignatureImplCopyWithImpl(
      _$PsbtError_InvalidEcdsaSignatureImpl _value,
      $Res Function(_$PsbtError_InvalidEcdsaSignatureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_InvalidEcdsaSignatureImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidEcdsaSignatureImpl
    extends PsbtError_InvalidEcdsaSignature {
  const _$PsbtError_InvalidEcdsaSignatureImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.invalidEcdsaSignature(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidEcdsaSignatureImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidEcdsaSignatureImplCopyWith<
          _$PsbtError_InvalidEcdsaSignatureImpl>
      get copyWith => __$$PsbtError_InvalidEcdsaSignatureImplCopyWithImpl<
          _$PsbtError_InvalidEcdsaSignatureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidEcdsaSignature(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidEcdsaSignature?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidEcdsaSignature != null) {
      return invalidEcdsaSignature(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidEcdsaSignature(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidEcdsaSignature?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidEcdsaSignature != null) {
      return invalidEcdsaSignature(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidEcdsaSignature extends PsbtError {
  const factory PsbtError_InvalidEcdsaSignature(
          {required final String errorMessage}) =
      _$PsbtError_InvalidEcdsaSignatureImpl;
  const PsbtError_InvalidEcdsaSignature._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidEcdsaSignatureImplCopyWith<
          _$PsbtError_InvalidEcdsaSignatureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidTaprootSignatureImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidTaprootSignatureImplCopyWith(
          _$PsbtError_InvalidTaprootSignatureImpl value,
          $Res Function(_$PsbtError_InvalidTaprootSignatureImpl) then) =
      __$$PsbtError_InvalidTaprootSignatureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_InvalidTaprootSignatureImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_InvalidTaprootSignatureImpl>
    implements _$$PsbtError_InvalidTaprootSignatureImplCopyWith<$Res> {
  __$$PsbtError_InvalidTaprootSignatureImplCopyWithImpl(
      _$PsbtError_InvalidTaprootSignatureImpl _value,
      $Res Function(_$PsbtError_InvalidTaprootSignatureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_InvalidTaprootSignatureImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_InvalidTaprootSignatureImpl
    extends PsbtError_InvalidTaprootSignature {
  const _$PsbtError_InvalidTaprootSignatureImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.invalidTaprootSignature(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidTaprootSignatureImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_InvalidTaprootSignatureImplCopyWith<
          _$PsbtError_InvalidTaprootSignatureImpl>
      get copyWith => __$$PsbtError_InvalidTaprootSignatureImplCopyWithImpl<
          _$PsbtError_InvalidTaprootSignatureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidTaprootSignature(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidTaprootSignature?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidTaprootSignature != null) {
      return invalidTaprootSignature(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidTaprootSignature(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidTaprootSignature?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidTaprootSignature != null) {
      return invalidTaprootSignature(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidTaprootSignature extends PsbtError {
  const factory PsbtError_InvalidTaprootSignature(
          {required final String errorMessage}) =
      _$PsbtError_InvalidTaprootSignatureImpl;
  const PsbtError_InvalidTaprootSignature._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_InvalidTaprootSignatureImplCopyWith<
          _$PsbtError_InvalidTaprootSignatureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_InvalidControlBlockImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidControlBlockImplCopyWith(
          _$PsbtError_InvalidControlBlockImpl value,
          $Res Function(_$PsbtError_InvalidControlBlockImpl) then) =
      __$$PsbtError_InvalidControlBlockImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidControlBlockImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidControlBlockImpl>
    implements _$$PsbtError_InvalidControlBlockImplCopyWith<$Res> {
  __$$PsbtError_InvalidControlBlockImplCopyWithImpl(
      _$PsbtError_InvalidControlBlockImpl _value,
      $Res Function(_$PsbtError_InvalidControlBlockImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidControlBlockImpl
    extends PsbtError_InvalidControlBlock {
  const _$PsbtError_InvalidControlBlockImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidControlBlock()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidControlBlockImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidControlBlock();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidControlBlock?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidControlBlock != null) {
      return invalidControlBlock();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidControlBlock(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidControlBlock?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidControlBlock != null) {
      return invalidControlBlock(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidControlBlock extends PsbtError {
  const factory PsbtError_InvalidControlBlock() =
      _$PsbtError_InvalidControlBlockImpl;
  const PsbtError_InvalidControlBlock._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_InvalidLeafVersionImplCopyWith<$Res> {
  factory _$$PsbtError_InvalidLeafVersionImplCopyWith(
          _$PsbtError_InvalidLeafVersionImpl value,
          $Res Function(_$PsbtError_InvalidLeafVersionImpl) then) =
      __$$PsbtError_InvalidLeafVersionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_InvalidLeafVersionImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_InvalidLeafVersionImpl>
    implements _$$PsbtError_InvalidLeafVersionImplCopyWith<$Res> {
  __$$PsbtError_InvalidLeafVersionImplCopyWithImpl(
      _$PsbtError_InvalidLeafVersionImpl _value,
      $Res Function(_$PsbtError_InvalidLeafVersionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_InvalidLeafVersionImpl extends PsbtError_InvalidLeafVersion {
  const _$PsbtError_InvalidLeafVersionImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.invalidLeafVersion()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_InvalidLeafVersionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return invalidLeafVersion();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return invalidLeafVersion?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidLeafVersion != null) {
      return invalidLeafVersion();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return invalidLeafVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return invalidLeafVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (invalidLeafVersion != null) {
      return invalidLeafVersion(this);
    }
    return orElse();
  }
}

abstract class PsbtError_InvalidLeafVersion extends PsbtError {
  const factory PsbtError_InvalidLeafVersion() =
      _$PsbtError_InvalidLeafVersionImpl;
  const PsbtError_InvalidLeafVersion._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_TaprootImplCopyWith<$Res> {
  factory _$$PsbtError_TaprootImplCopyWith(_$PsbtError_TaprootImpl value,
          $Res Function(_$PsbtError_TaprootImpl) then) =
      __$$PsbtError_TaprootImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_TaprootImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_TaprootImpl>
    implements _$$PsbtError_TaprootImplCopyWith<$Res> {
  __$$PsbtError_TaprootImplCopyWithImpl(_$PsbtError_TaprootImpl _value,
      $Res Function(_$PsbtError_TaprootImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_TaprootImpl extends PsbtError_Taproot {
  const _$PsbtError_TaprootImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.taproot()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PsbtError_TaprootImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return taproot();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return taproot?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (taproot != null) {
      return taproot();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return taproot(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return taproot?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (taproot != null) {
      return taproot(this);
    }
    return orElse();
  }
}

abstract class PsbtError_Taproot extends PsbtError {
  const factory PsbtError_Taproot() = _$PsbtError_TaprootImpl;
  const PsbtError_Taproot._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_TapTreeImplCopyWith<$Res> {
  factory _$$PsbtError_TapTreeImplCopyWith(_$PsbtError_TapTreeImpl value,
          $Res Function(_$PsbtError_TapTreeImpl) then) =
      __$$PsbtError_TapTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_TapTreeImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_TapTreeImpl>
    implements _$$PsbtError_TapTreeImplCopyWith<$Res> {
  __$$PsbtError_TapTreeImplCopyWithImpl(_$PsbtError_TapTreeImpl _value,
      $Res Function(_$PsbtError_TapTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_TapTreeImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_TapTreeImpl extends PsbtError_TapTree {
  const _$PsbtError_TapTreeImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.tapTree(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_TapTreeImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_TapTreeImplCopyWith<_$PsbtError_TapTreeImpl> get copyWith =>
      __$$PsbtError_TapTreeImplCopyWithImpl<_$PsbtError_TapTreeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return tapTree(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return tapTree?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (tapTree != null) {
      return tapTree(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return tapTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return tapTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (tapTree != null) {
      return tapTree(this);
    }
    return orElse();
  }
}

abstract class PsbtError_TapTree extends PsbtError {
  const factory PsbtError_TapTree({required final String errorMessage}) =
      _$PsbtError_TapTreeImpl;
  const PsbtError_TapTree._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_TapTreeImplCopyWith<_$PsbtError_TapTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_XPubKeyImplCopyWith<$Res> {
  factory _$$PsbtError_XPubKeyImplCopyWith(_$PsbtError_XPubKeyImpl value,
          $Res Function(_$PsbtError_XPubKeyImpl) then) =
      __$$PsbtError_XPubKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_XPubKeyImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_XPubKeyImpl>
    implements _$$PsbtError_XPubKeyImplCopyWith<$Res> {
  __$$PsbtError_XPubKeyImplCopyWithImpl(_$PsbtError_XPubKeyImpl _value,
      $Res Function(_$PsbtError_XPubKeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_XPubKeyImpl extends PsbtError_XPubKey {
  const _$PsbtError_XPubKeyImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.xPubKey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PsbtError_XPubKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return xPubKey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return xPubKey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (xPubKey != null) {
      return xPubKey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return xPubKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return xPubKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (xPubKey != null) {
      return xPubKey(this);
    }
    return orElse();
  }
}

abstract class PsbtError_XPubKey extends PsbtError {
  const factory PsbtError_XPubKey() = _$PsbtError_XPubKeyImpl;
  const PsbtError_XPubKey._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_VersionImplCopyWith<$Res> {
  factory _$$PsbtError_VersionImplCopyWith(_$PsbtError_VersionImpl value,
          $Res Function(_$PsbtError_VersionImpl) then) =
      __$$PsbtError_VersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_VersionImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_VersionImpl>
    implements _$$PsbtError_VersionImplCopyWith<$Res> {
  __$$PsbtError_VersionImplCopyWithImpl(_$PsbtError_VersionImpl _value,
      $Res Function(_$PsbtError_VersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_VersionImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_VersionImpl extends PsbtError_Version {
  const _$PsbtError_VersionImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.version(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_VersionImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_VersionImplCopyWith<_$PsbtError_VersionImpl> get copyWith =>
      __$$PsbtError_VersionImplCopyWithImpl<_$PsbtError_VersionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return version(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return version?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (version != null) {
      return version(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return version(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return version?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (version != null) {
      return version(this);
    }
    return orElse();
  }
}

abstract class PsbtError_Version extends PsbtError {
  const factory PsbtError_Version({required final String errorMessage}) =
      _$PsbtError_VersionImpl;
  const PsbtError_Version._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_VersionImplCopyWith<_$PsbtError_VersionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_PartialDataConsumptionImplCopyWith<$Res> {
  factory _$$PsbtError_PartialDataConsumptionImplCopyWith(
          _$PsbtError_PartialDataConsumptionImpl value,
          $Res Function(_$PsbtError_PartialDataConsumptionImpl) then) =
      __$$PsbtError_PartialDataConsumptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_PartialDataConsumptionImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res,
        _$PsbtError_PartialDataConsumptionImpl>
    implements _$$PsbtError_PartialDataConsumptionImplCopyWith<$Res> {
  __$$PsbtError_PartialDataConsumptionImplCopyWithImpl(
      _$PsbtError_PartialDataConsumptionImpl _value,
      $Res Function(_$PsbtError_PartialDataConsumptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_PartialDataConsumptionImpl
    extends PsbtError_PartialDataConsumption {
  const _$PsbtError_PartialDataConsumptionImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.partialDataConsumption()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_PartialDataConsumptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return partialDataConsumption();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return partialDataConsumption?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (partialDataConsumption != null) {
      return partialDataConsumption();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return partialDataConsumption(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return partialDataConsumption?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (partialDataConsumption != null) {
      return partialDataConsumption(this);
    }
    return orElse();
  }
}

abstract class PsbtError_PartialDataConsumption extends PsbtError {
  const factory PsbtError_PartialDataConsumption() =
      _$PsbtError_PartialDataConsumptionImpl;
  const PsbtError_PartialDataConsumption._() : super._();
}

/// @nodoc
abstract class _$$PsbtError_IoImplCopyWith<$Res> {
  factory _$$PsbtError_IoImplCopyWith(
          _$PsbtError_IoImpl value, $Res Function(_$PsbtError_IoImpl) then) =
      __$$PsbtError_IoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtError_IoImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_IoImpl>
    implements _$$PsbtError_IoImplCopyWith<$Res> {
  __$$PsbtError_IoImplCopyWithImpl(
      _$PsbtError_IoImpl _value, $Res Function(_$PsbtError_IoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtError_IoImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtError_IoImpl extends PsbtError_Io {
  const _$PsbtError_IoImpl({required this.errorMessage}) : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtError.io(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_IoImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtError_IoImplCopyWith<_$PsbtError_IoImpl> get copyWith =>
      __$$PsbtError_IoImplCopyWithImpl<_$PsbtError_IoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return io(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return io?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return io(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return io?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io(this);
    }
    return orElse();
  }
}

abstract class PsbtError_Io extends PsbtError {
  const factory PsbtError_Io({required final String errorMessage}) =
      _$PsbtError_IoImpl;
  const PsbtError_Io._() : super._();

  String get errorMessage;
  @JsonKey(ignore: true)
  _$$PsbtError_IoImplCopyWith<_$PsbtError_IoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtError_OtherPsbtErrImplCopyWith<$Res> {
  factory _$$PsbtError_OtherPsbtErrImplCopyWith(
          _$PsbtError_OtherPsbtErrImpl value,
          $Res Function(_$PsbtError_OtherPsbtErrImpl) then) =
      __$$PsbtError_OtherPsbtErrImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PsbtError_OtherPsbtErrImplCopyWithImpl<$Res>
    extends _$PsbtErrorCopyWithImpl<$Res, _$PsbtError_OtherPsbtErrImpl>
    implements _$$PsbtError_OtherPsbtErrImplCopyWith<$Res> {
  __$$PsbtError_OtherPsbtErrImplCopyWithImpl(
      _$PsbtError_OtherPsbtErrImpl _value,
      $Res Function(_$PsbtError_OtherPsbtErrImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PsbtError_OtherPsbtErrImpl extends PsbtError_OtherPsbtErr {
  const _$PsbtError_OtherPsbtErrImpl() : super._();

  @override
  String toString() {
    return 'PsbtError.otherPsbtErr()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtError_OtherPsbtErrImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidMagic,
    required TResult Function() missingUtxo,
    required TResult Function() invalidSeparator,
    required TResult Function() psbtUtxoOutOfBounds,
    required TResult Function(String key) invalidKey,
    required TResult Function() invalidProprietaryKey,
    required TResult Function(String key) duplicateKey,
    required TResult Function() unsignedTxHasScriptSigs,
    required TResult Function() unsignedTxHasScriptWitnesses,
    required TResult Function() mustHaveUnsignedTx,
    required TResult Function() noMorePairs,
    required TResult Function() unexpectedUnsignedTx,
    required TResult Function(int sighash) nonStandardSighashType,
    required TResult Function(String hash) invalidHash,
    required TResult Function() invalidPreimageHashPair,
    required TResult Function(String xpub) combineInconsistentKeySources,
    required TResult Function(String encodingError) consensusEncoding,
    required TResult Function() negativeFee,
    required TResult Function() feeOverflow,
    required TResult Function(String errorMessage) invalidPublicKey,
    required TResult Function(String secp256K1Error) invalidSecp256K1PublicKey,
    required TResult Function() invalidXOnlyPublicKey,
    required TResult Function(String errorMessage) invalidEcdsaSignature,
    required TResult Function(String errorMessage) invalidTaprootSignature,
    required TResult Function() invalidControlBlock,
    required TResult Function() invalidLeafVersion,
    required TResult Function() taproot,
    required TResult Function(String errorMessage) tapTree,
    required TResult Function() xPubKey,
    required TResult Function(String errorMessage) version,
    required TResult Function() partialDataConsumption,
    required TResult Function(String errorMessage) io,
    required TResult Function() otherPsbtErr,
  }) {
    return otherPsbtErr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidMagic,
    TResult? Function()? missingUtxo,
    TResult? Function()? invalidSeparator,
    TResult? Function()? psbtUtxoOutOfBounds,
    TResult? Function(String key)? invalidKey,
    TResult? Function()? invalidProprietaryKey,
    TResult? Function(String key)? duplicateKey,
    TResult? Function()? unsignedTxHasScriptSigs,
    TResult? Function()? unsignedTxHasScriptWitnesses,
    TResult? Function()? mustHaveUnsignedTx,
    TResult? Function()? noMorePairs,
    TResult? Function()? unexpectedUnsignedTx,
    TResult? Function(int sighash)? nonStandardSighashType,
    TResult? Function(String hash)? invalidHash,
    TResult? Function()? invalidPreimageHashPair,
    TResult? Function(String xpub)? combineInconsistentKeySources,
    TResult? Function(String encodingError)? consensusEncoding,
    TResult? Function()? negativeFee,
    TResult? Function()? feeOverflow,
    TResult? Function(String errorMessage)? invalidPublicKey,
    TResult? Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult? Function()? invalidXOnlyPublicKey,
    TResult? Function(String errorMessage)? invalidEcdsaSignature,
    TResult? Function(String errorMessage)? invalidTaprootSignature,
    TResult? Function()? invalidControlBlock,
    TResult? Function()? invalidLeafVersion,
    TResult? Function()? taproot,
    TResult? Function(String errorMessage)? tapTree,
    TResult? Function()? xPubKey,
    TResult? Function(String errorMessage)? version,
    TResult? Function()? partialDataConsumption,
    TResult? Function(String errorMessage)? io,
    TResult? Function()? otherPsbtErr,
  }) {
    return otherPsbtErr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidMagic,
    TResult Function()? missingUtxo,
    TResult Function()? invalidSeparator,
    TResult Function()? psbtUtxoOutOfBounds,
    TResult Function(String key)? invalidKey,
    TResult Function()? invalidProprietaryKey,
    TResult Function(String key)? duplicateKey,
    TResult Function()? unsignedTxHasScriptSigs,
    TResult Function()? unsignedTxHasScriptWitnesses,
    TResult Function()? mustHaveUnsignedTx,
    TResult Function()? noMorePairs,
    TResult Function()? unexpectedUnsignedTx,
    TResult Function(int sighash)? nonStandardSighashType,
    TResult Function(String hash)? invalidHash,
    TResult Function()? invalidPreimageHashPair,
    TResult Function(String xpub)? combineInconsistentKeySources,
    TResult Function(String encodingError)? consensusEncoding,
    TResult Function()? negativeFee,
    TResult Function()? feeOverflow,
    TResult Function(String errorMessage)? invalidPublicKey,
    TResult Function(String secp256K1Error)? invalidSecp256K1PublicKey,
    TResult Function()? invalidXOnlyPublicKey,
    TResult Function(String errorMessage)? invalidEcdsaSignature,
    TResult Function(String errorMessage)? invalidTaprootSignature,
    TResult Function()? invalidControlBlock,
    TResult Function()? invalidLeafVersion,
    TResult Function()? taproot,
    TResult Function(String errorMessage)? tapTree,
    TResult Function()? xPubKey,
    TResult Function(String errorMessage)? version,
    TResult Function()? partialDataConsumption,
    TResult Function(String errorMessage)? io,
    TResult Function()? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (otherPsbtErr != null) {
      return otherPsbtErr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtError_InvalidMagic value) invalidMagic,
    required TResult Function(PsbtError_MissingUtxo value) missingUtxo,
    required TResult Function(PsbtError_InvalidSeparator value)
        invalidSeparator,
    required TResult Function(PsbtError_PsbtUtxoOutOfBounds value)
        psbtUtxoOutOfBounds,
    required TResult Function(PsbtError_InvalidKey value) invalidKey,
    required TResult Function(PsbtError_InvalidProprietaryKey value)
        invalidProprietaryKey,
    required TResult Function(PsbtError_DuplicateKey value) duplicateKey,
    required TResult Function(PsbtError_UnsignedTxHasScriptSigs value)
        unsignedTxHasScriptSigs,
    required TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)
        unsignedTxHasScriptWitnesses,
    required TResult Function(PsbtError_MustHaveUnsignedTx value)
        mustHaveUnsignedTx,
    required TResult Function(PsbtError_NoMorePairs value) noMorePairs,
    required TResult Function(PsbtError_UnexpectedUnsignedTx value)
        unexpectedUnsignedTx,
    required TResult Function(PsbtError_NonStandardSighashType value)
        nonStandardSighashType,
    required TResult Function(PsbtError_InvalidHash value) invalidHash,
    required TResult Function(PsbtError_InvalidPreimageHashPair value)
        invalidPreimageHashPair,
    required TResult Function(PsbtError_CombineInconsistentKeySources value)
        combineInconsistentKeySources,
    required TResult Function(PsbtError_ConsensusEncoding value)
        consensusEncoding,
    required TResult Function(PsbtError_NegativeFee value) negativeFee,
    required TResult Function(PsbtError_FeeOverflow value) feeOverflow,
    required TResult Function(PsbtError_InvalidPublicKey value)
        invalidPublicKey,
    required TResult Function(PsbtError_InvalidSecp256k1PublicKey value)
        invalidSecp256K1PublicKey,
    required TResult Function(PsbtError_InvalidXOnlyPublicKey value)
        invalidXOnlyPublicKey,
    required TResult Function(PsbtError_InvalidEcdsaSignature value)
        invalidEcdsaSignature,
    required TResult Function(PsbtError_InvalidTaprootSignature value)
        invalidTaprootSignature,
    required TResult Function(PsbtError_InvalidControlBlock value)
        invalidControlBlock,
    required TResult Function(PsbtError_InvalidLeafVersion value)
        invalidLeafVersion,
    required TResult Function(PsbtError_Taproot value) taproot,
    required TResult Function(PsbtError_TapTree value) tapTree,
    required TResult Function(PsbtError_XPubKey value) xPubKey,
    required TResult Function(PsbtError_Version value) version,
    required TResult Function(PsbtError_PartialDataConsumption value)
        partialDataConsumption,
    required TResult Function(PsbtError_Io value) io,
    required TResult Function(PsbtError_OtherPsbtErr value) otherPsbtErr,
  }) {
    return otherPsbtErr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult? Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult? Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult? Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult? Function(PsbtError_InvalidKey value)? invalidKey,
    TResult? Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult? Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult? Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult? Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult? Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult? Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult? Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult? Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult? Function(PsbtError_InvalidHash value)? invalidHash,
    TResult? Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult? Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult? Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult? Function(PsbtError_NegativeFee value)? negativeFee,
    TResult? Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult? Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult? Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult? Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult? Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult? Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult? Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult? Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult? Function(PsbtError_Taproot value)? taproot,
    TResult? Function(PsbtError_TapTree value)? tapTree,
    TResult? Function(PsbtError_XPubKey value)? xPubKey,
    TResult? Function(PsbtError_Version value)? version,
    TResult? Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult? Function(PsbtError_Io value)? io,
    TResult? Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
  }) {
    return otherPsbtErr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtError_InvalidMagic value)? invalidMagic,
    TResult Function(PsbtError_MissingUtxo value)? missingUtxo,
    TResult Function(PsbtError_InvalidSeparator value)? invalidSeparator,
    TResult Function(PsbtError_PsbtUtxoOutOfBounds value)? psbtUtxoOutOfBounds,
    TResult Function(PsbtError_InvalidKey value)? invalidKey,
    TResult Function(PsbtError_InvalidProprietaryKey value)?
        invalidProprietaryKey,
    TResult Function(PsbtError_DuplicateKey value)? duplicateKey,
    TResult Function(PsbtError_UnsignedTxHasScriptSigs value)?
        unsignedTxHasScriptSigs,
    TResult Function(PsbtError_UnsignedTxHasScriptWitnesses value)?
        unsignedTxHasScriptWitnesses,
    TResult Function(PsbtError_MustHaveUnsignedTx value)? mustHaveUnsignedTx,
    TResult Function(PsbtError_NoMorePairs value)? noMorePairs,
    TResult Function(PsbtError_UnexpectedUnsignedTx value)?
        unexpectedUnsignedTx,
    TResult Function(PsbtError_NonStandardSighashType value)?
        nonStandardSighashType,
    TResult Function(PsbtError_InvalidHash value)? invalidHash,
    TResult Function(PsbtError_InvalidPreimageHashPair value)?
        invalidPreimageHashPair,
    TResult Function(PsbtError_CombineInconsistentKeySources value)?
        combineInconsistentKeySources,
    TResult Function(PsbtError_ConsensusEncoding value)? consensusEncoding,
    TResult Function(PsbtError_NegativeFee value)? negativeFee,
    TResult Function(PsbtError_FeeOverflow value)? feeOverflow,
    TResult Function(PsbtError_InvalidPublicKey value)? invalidPublicKey,
    TResult Function(PsbtError_InvalidSecp256k1PublicKey value)?
        invalidSecp256K1PublicKey,
    TResult Function(PsbtError_InvalidXOnlyPublicKey value)?
        invalidXOnlyPublicKey,
    TResult Function(PsbtError_InvalidEcdsaSignature value)?
        invalidEcdsaSignature,
    TResult Function(PsbtError_InvalidTaprootSignature value)?
        invalidTaprootSignature,
    TResult Function(PsbtError_InvalidControlBlock value)? invalidControlBlock,
    TResult Function(PsbtError_InvalidLeafVersion value)? invalidLeafVersion,
    TResult Function(PsbtError_Taproot value)? taproot,
    TResult Function(PsbtError_TapTree value)? tapTree,
    TResult Function(PsbtError_XPubKey value)? xPubKey,
    TResult Function(PsbtError_Version value)? version,
    TResult Function(PsbtError_PartialDataConsumption value)?
        partialDataConsumption,
    TResult Function(PsbtError_Io value)? io,
    TResult Function(PsbtError_OtherPsbtErr value)? otherPsbtErr,
    required TResult orElse(),
  }) {
    if (otherPsbtErr != null) {
      return otherPsbtErr(this);
    }
    return orElse();
  }
}

abstract class PsbtError_OtherPsbtErr extends PsbtError {
  const factory PsbtError_OtherPsbtErr() = _$PsbtError_OtherPsbtErrImpl;
  const PsbtError_OtherPsbtErr._() : super._();
}

/// @nodoc
mixin _$PsbtParseError {
  String get errorMessage => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) psbtEncoding,
    required TResult Function(String errorMessage) base64Encoding,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? psbtEncoding,
    TResult? Function(String errorMessage)? base64Encoding,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? psbtEncoding,
    TResult Function(String errorMessage)? base64Encoding,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtParseError_PsbtEncoding value) psbtEncoding,
    required TResult Function(PsbtParseError_Base64Encoding value)
        base64Encoding,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult? Function(PsbtParseError_Base64Encoding value)? base64Encoding,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult Function(PsbtParseError_Base64Encoding value)? base64Encoding,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PsbtParseErrorCopyWith<PsbtParseError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PsbtParseErrorCopyWith<$Res> {
  factory $PsbtParseErrorCopyWith(
          PsbtParseError value, $Res Function(PsbtParseError) then) =
      _$PsbtParseErrorCopyWithImpl<$Res, PsbtParseError>;
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class _$PsbtParseErrorCopyWithImpl<$Res, $Val extends PsbtParseError>
    implements $PsbtParseErrorCopyWith<$Res> {
  _$PsbtParseErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_value.copyWith(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PsbtParseError_PsbtEncodingImplCopyWith<$Res>
    implements $PsbtParseErrorCopyWith<$Res> {
  factory _$$PsbtParseError_PsbtEncodingImplCopyWith(
          _$PsbtParseError_PsbtEncodingImpl value,
          $Res Function(_$PsbtParseError_PsbtEncodingImpl) then) =
      __$$PsbtParseError_PsbtEncodingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtParseError_PsbtEncodingImplCopyWithImpl<$Res>
    extends _$PsbtParseErrorCopyWithImpl<$Res,
        _$PsbtParseError_PsbtEncodingImpl>
    implements _$$PsbtParseError_PsbtEncodingImplCopyWith<$Res> {
  __$$PsbtParseError_PsbtEncodingImplCopyWithImpl(
      _$PsbtParseError_PsbtEncodingImpl _value,
      $Res Function(_$PsbtParseError_PsbtEncodingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtParseError_PsbtEncodingImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtParseError_PsbtEncodingImpl extends PsbtParseError_PsbtEncoding {
  const _$PsbtParseError_PsbtEncodingImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtParseError.psbtEncoding(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtParseError_PsbtEncodingImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtParseError_PsbtEncodingImplCopyWith<_$PsbtParseError_PsbtEncodingImpl>
      get copyWith => __$$PsbtParseError_PsbtEncodingImplCopyWithImpl<
          _$PsbtParseError_PsbtEncodingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) psbtEncoding,
    required TResult Function(String errorMessage) base64Encoding,
  }) {
    return psbtEncoding(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? psbtEncoding,
    TResult? Function(String errorMessage)? base64Encoding,
  }) {
    return psbtEncoding?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? psbtEncoding,
    TResult Function(String errorMessage)? base64Encoding,
    required TResult orElse(),
  }) {
    if (psbtEncoding != null) {
      return psbtEncoding(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtParseError_PsbtEncoding value) psbtEncoding,
    required TResult Function(PsbtParseError_Base64Encoding value)
        base64Encoding,
  }) {
    return psbtEncoding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult? Function(PsbtParseError_Base64Encoding value)? base64Encoding,
  }) {
    return psbtEncoding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult Function(PsbtParseError_Base64Encoding value)? base64Encoding,
    required TResult orElse(),
  }) {
    if (psbtEncoding != null) {
      return psbtEncoding(this);
    }
    return orElse();
  }
}

abstract class PsbtParseError_PsbtEncoding extends PsbtParseError {
  const factory PsbtParseError_PsbtEncoding(
      {required final String errorMessage}) = _$PsbtParseError_PsbtEncodingImpl;
  const PsbtParseError_PsbtEncoding._() : super._();

  @override
  String get errorMessage;
  @override
  @JsonKey(ignore: true)
  _$$PsbtParseError_PsbtEncodingImplCopyWith<_$PsbtParseError_PsbtEncodingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PsbtParseError_Base64EncodingImplCopyWith<$Res>
    implements $PsbtParseErrorCopyWith<$Res> {
  factory _$$PsbtParseError_Base64EncodingImplCopyWith(
          _$PsbtParseError_Base64EncodingImpl value,
          $Res Function(_$PsbtParseError_Base64EncodingImpl) then) =
      __$$PsbtParseError_Base64EncodingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String errorMessage});
}

/// @nodoc
class __$$PsbtParseError_Base64EncodingImplCopyWithImpl<$Res>
    extends _$PsbtParseErrorCopyWithImpl<$Res,
        _$PsbtParseError_Base64EncodingImpl>
    implements _$$PsbtParseError_Base64EncodingImplCopyWith<$Res> {
  __$$PsbtParseError_Base64EncodingImplCopyWithImpl(
      _$PsbtParseError_Base64EncodingImpl _value,
      $Res Function(_$PsbtParseError_Base64EncodingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = null,
  }) {
    return _then(_$PsbtParseError_Base64EncodingImpl(
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PsbtParseError_Base64EncodingImpl
    extends PsbtParseError_Base64Encoding {
  const _$PsbtParseError_Base64EncodingImpl({required this.errorMessage})
      : super._();

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'PsbtParseError.base64Encoding(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PsbtParseError_Base64EncodingImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PsbtParseError_Base64EncodingImplCopyWith<
          _$PsbtParseError_Base64EncodingImpl>
      get copyWith => __$$PsbtParseError_Base64EncodingImplCopyWithImpl<
          _$PsbtParseError_Base64EncodingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String errorMessage) psbtEncoding,
    required TResult Function(String errorMessage) base64Encoding,
  }) {
    return base64Encoding(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String errorMessage)? psbtEncoding,
    TResult? Function(String errorMessage)? base64Encoding,
  }) {
    return base64Encoding?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String errorMessage)? psbtEncoding,
    TResult Function(String errorMessage)? base64Encoding,
    required TResult orElse(),
  }) {
    if (base64Encoding != null) {
      return base64Encoding(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PsbtParseError_PsbtEncoding value) psbtEncoding,
    required TResult Function(PsbtParseError_Base64Encoding value)
        base64Encoding,
  }) {
    return base64Encoding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult? Function(PsbtParseError_Base64Encoding value)? base64Encoding,
  }) {
    return base64Encoding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PsbtParseError_PsbtEncoding value)? psbtEncoding,
    TResult Function(PsbtParseError_Base64Encoding value)? base64Encoding,
    required TResult orElse(),
  }) {
    if (base64Encoding != null) {
      return base64Encoding(this);
    }
    return orElse();
  }
}

abstract class PsbtParseError_Base64Encoding extends PsbtParseError {
  const factory PsbtParseError_Base64Encoding(
          {required final String errorMessage}) =
      _$PsbtParseError_Base64EncodingImpl;
  const PsbtParseError_Base64Encoding._() : super._();

  @override
  String get errorMessage;
  @override
  @JsonKey(ignore: true)
  _$$PsbtParseError_Base64EncodingImplCopyWith<
          _$PsbtParseError_Base64EncodingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SqliteError {
  String get rusqliteError => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String rusqliteError) sqlite,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String rusqliteError)? sqlite,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String rusqliteError)? sqlite,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SqliteError_Sqlite value) sqlite,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SqliteError_Sqlite value)? sqlite,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SqliteError_Sqlite value)? sqlite,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SqliteErrorCopyWith<SqliteError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SqliteErrorCopyWith<$Res> {
  factory $SqliteErrorCopyWith(
          SqliteError value, $Res Function(SqliteError) then) =
      _$SqliteErrorCopyWithImpl<$Res, SqliteError>;
  @useResult
  $Res call({String rusqliteError});
}

/// @nodoc
class _$SqliteErrorCopyWithImpl<$Res, $Val extends SqliteError>
    implements $SqliteErrorCopyWith<$Res> {
  _$SqliteErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rusqliteError = null,
  }) {
    return _then(_value.copyWith(
      rusqliteError: null == rusqliteError
          ? _value.rusqliteError
          : rusqliteError // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SqliteError_SqliteImplCopyWith<$Res>
    implements $SqliteErrorCopyWith<$Res> {
  factory _$$SqliteError_SqliteImplCopyWith(_$SqliteError_SqliteImpl value,
          $Res Function(_$SqliteError_SqliteImpl) then) =
      __$$SqliteError_SqliteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String rusqliteError});
}

/// @nodoc
class __$$SqliteError_SqliteImplCopyWithImpl<$Res>
    extends _$SqliteErrorCopyWithImpl<$Res, _$SqliteError_SqliteImpl>
    implements _$$SqliteError_SqliteImplCopyWith<$Res> {
  __$$SqliteError_SqliteImplCopyWithImpl(_$SqliteError_SqliteImpl _value,
      $Res Function(_$SqliteError_SqliteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rusqliteError = null,
  }) {
    return _then(_$SqliteError_SqliteImpl(
      rusqliteError: null == rusqliteError
          ? _value.rusqliteError
          : rusqliteError // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SqliteError_SqliteImpl extends SqliteError_Sqlite {
  const _$SqliteError_SqliteImpl({required this.rusqliteError}) : super._();

  @override
  final String rusqliteError;

  @override
  String toString() {
    return 'SqliteError.sqlite(rusqliteError: $rusqliteError)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SqliteError_SqliteImpl &&
            (identical(other.rusqliteError, rusqliteError) ||
                other.rusqliteError == rusqliteError));
  }

  @override
  int get hashCode => Object.hash(runtimeType, rusqliteError);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SqliteError_SqliteImplCopyWith<_$SqliteError_SqliteImpl> get copyWith =>
      __$$SqliteError_SqliteImplCopyWithImpl<_$SqliteError_SqliteImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String rusqliteError) sqlite,
  }) {
    return sqlite(rusqliteError);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String rusqliteError)? sqlite,
  }) {
    return sqlite?.call(rusqliteError);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String rusqliteError)? sqlite,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(rusqliteError);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SqliteError_Sqlite value) sqlite,
  }) {
    return sqlite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SqliteError_Sqlite value)? sqlite,
  }) {
    return sqlite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SqliteError_Sqlite value)? sqlite,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(this);
    }
    return orElse();
  }
}

abstract class SqliteError_Sqlite extends SqliteError {
  const factory SqliteError_Sqlite({required final String rusqliteError}) =
      _$SqliteError_SqliteImpl;
  const SqliteError_Sqlite._() : super._();

  @override
  String get rusqliteError;
  @override
  @JsonKey(ignore: true)
  _$$SqliteError_SqliteImplCopyWith<_$SqliteError_SqliteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TransactionError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransactionErrorCopyWith<$Res> {
  factory $TransactionErrorCopyWith(
          TransactionError value, $Res Function(TransactionError) then) =
      _$TransactionErrorCopyWithImpl<$Res, TransactionError>;
}

/// @nodoc
class _$TransactionErrorCopyWithImpl<$Res, $Val extends TransactionError>
    implements $TransactionErrorCopyWith<$Res> {
  _$TransactionErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TransactionError_IoImplCopyWith<$Res> {
  factory _$$TransactionError_IoImplCopyWith(_$TransactionError_IoImpl value,
          $Res Function(_$TransactionError_IoImpl) then) =
      __$$TransactionError_IoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TransactionError_IoImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res, _$TransactionError_IoImpl>
    implements _$$TransactionError_IoImplCopyWith<$Res> {
  __$$TransactionError_IoImplCopyWithImpl(_$TransactionError_IoImpl _value,
      $Res Function(_$TransactionError_IoImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TransactionError_IoImpl extends TransactionError_Io {
  const _$TransactionError_IoImpl() : super._();

  @override
  String toString() {
    return 'TransactionError.io()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_IoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return io();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return io?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return io(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return io?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io(this);
    }
    return orElse();
  }
}

abstract class TransactionError_Io extends TransactionError {
  const factory TransactionError_Io() = _$TransactionError_IoImpl;
  const TransactionError_Io._() : super._();
}

/// @nodoc
abstract class _$$TransactionError_OversizedVectorAllocationImplCopyWith<$Res> {
  factory _$$TransactionError_OversizedVectorAllocationImplCopyWith(
          _$TransactionError_OversizedVectorAllocationImpl value,
          $Res Function(_$TransactionError_OversizedVectorAllocationImpl)
              then) =
      __$$TransactionError_OversizedVectorAllocationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TransactionError_OversizedVectorAllocationImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_OversizedVectorAllocationImpl>
    implements _$$TransactionError_OversizedVectorAllocationImplCopyWith<$Res> {
  __$$TransactionError_OversizedVectorAllocationImplCopyWithImpl(
      _$TransactionError_OversizedVectorAllocationImpl _value,
      $Res Function(_$TransactionError_OversizedVectorAllocationImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TransactionError_OversizedVectorAllocationImpl
    extends TransactionError_OversizedVectorAllocation {
  const _$TransactionError_OversizedVectorAllocationImpl() : super._();

  @override
  String toString() {
    return 'TransactionError.oversizedVectorAllocation()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_OversizedVectorAllocationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return oversizedVectorAllocation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return oversizedVectorAllocation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (oversizedVectorAllocation != null) {
      return oversizedVectorAllocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return oversizedVectorAllocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return oversizedVectorAllocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (oversizedVectorAllocation != null) {
      return oversizedVectorAllocation(this);
    }
    return orElse();
  }
}

abstract class TransactionError_OversizedVectorAllocation
    extends TransactionError {
  const factory TransactionError_OversizedVectorAllocation() =
      _$TransactionError_OversizedVectorAllocationImpl;
  const TransactionError_OversizedVectorAllocation._() : super._();
}

/// @nodoc
abstract class _$$TransactionError_InvalidChecksumImplCopyWith<$Res> {
  factory _$$TransactionError_InvalidChecksumImplCopyWith(
          _$TransactionError_InvalidChecksumImpl value,
          $Res Function(_$TransactionError_InvalidChecksumImpl) then) =
      __$$TransactionError_InvalidChecksumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String expected, String actual});
}

/// @nodoc
class __$$TransactionError_InvalidChecksumImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_InvalidChecksumImpl>
    implements _$$TransactionError_InvalidChecksumImplCopyWith<$Res> {
  __$$TransactionError_InvalidChecksumImplCopyWithImpl(
      _$TransactionError_InvalidChecksumImpl _value,
      $Res Function(_$TransactionError_InvalidChecksumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$TransactionError_InvalidChecksumImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as String,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TransactionError_InvalidChecksumImpl
    extends TransactionError_InvalidChecksum {
  const _$TransactionError_InvalidChecksumImpl(
      {required this.expected, required this.actual})
      : super._();

  @override
  final String expected;
  @override
  final String actual;

  @override
  String toString() {
    return 'TransactionError.invalidChecksum(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_InvalidChecksumImpl &&
            (identical(other.expected, expected) ||
                other.expected == expected) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, actual);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TransactionError_InvalidChecksumImplCopyWith<
          _$TransactionError_InvalidChecksumImpl>
      get copyWith => __$$TransactionError_InvalidChecksumImplCopyWithImpl<
          _$TransactionError_InvalidChecksumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return invalidChecksum(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return invalidChecksum?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return invalidChecksum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return invalidChecksum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum(this);
    }
    return orElse();
  }
}

abstract class TransactionError_InvalidChecksum extends TransactionError {
  const factory TransactionError_InvalidChecksum(
      {required final String expected,
      required final String actual}) = _$TransactionError_InvalidChecksumImpl;
  const TransactionError_InvalidChecksum._() : super._();

  String get expected;
  String get actual;
  @JsonKey(ignore: true)
  _$$TransactionError_InvalidChecksumImplCopyWith<
          _$TransactionError_InvalidChecksumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TransactionError_NonMinimalVarIntImplCopyWith<$Res> {
  factory _$$TransactionError_NonMinimalVarIntImplCopyWith(
          _$TransactionError_NonMinimalVarIntImpl value,
          $Res Function(_$TransactionError_NonMinimalVarIntImpl) then) =
      __$$TransactionError_NonMinimalVarIntImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TransactionError_NonMinimalVarIntImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_NonMinimalVarIntImpl>
    implements _$$TransactionError_NonMinimalVarIntImplCopyWith<$Res> {
  __$$TransactionError_NonMinimalVarIntImplCopyWithImpl(
      _$TransactionError_NonMinimalVarIntImpl _value,
      $Res Function(_$TransactionError_NonMinimalVarIntImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TransactionError_NonMinimalVarIntImpl
    extends TransactionError_NonMinimalVarInt {
  const _$TransactionError_NonMinimalVarIntImpl() : super._();

  @override
  String toString() {
    return 'TransactionError.nonMinimalVarInt()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_NonMinimalVarIntImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return nonMinimalVarInt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return nonMinimalVarInt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (nonMinimalVarInt != null) {
      return nonMinimalVarInt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return nonMinimalVarInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return nonMinimalVarInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (nonMinimalVarInt != null) {
      return nonMinimalVarInt(this);
    }
    return orElse();
  }
}

abstract class TransactionError_NonMinimalVarInt extends TransactionError {
  const factory TransactionError_NonMinimalVarInt() =
      _$TransactionError_NonMinimalVarIntImpl;
  const TransactionError_NonMinimalVarInt._() : super._();
}

/// @nodoc
abstract class _$$TransactionError_ParseFailedImplCopyWith<$Res> {
  factory _$$TransactionError_ParseFailedImplCopyWith(
          _$TransactionError_ParseFailedImpl value,
          $Res Function(_$TransactionError_ParseFailedImpl) then) =
      __$$TransactionError_ParseFailedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TransactionError_ParseFailedImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_ParseFailedImpl>
    implements _$$TransactionError_ParseFailedImplCopyWith<$Res> {
  __$$TransactionError_ParseFailedImplCopyWithImpl(
      _$TransactionError_ParseFailedImpl _value,
      $Res Function(_$TransactionError_ParseFailedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TransactionError_ParseFailedImpl extends TransactionError_ParseFailed {
  const _$TransactionError_ParseFailedImpl() : super._();

  @override
  String toString() {
    return 'TransactionError.parseFailed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_ParseFailedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return parseFailed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return parseFailed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (parseFailed != null) {
      return parseFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return parseFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return parseFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (parseFailed != null) {
      return parseFailed(this);
    }
    return orElse();
  }
}

abstract class TransactionError_ParseFailed extends TransactionError {
  const factory TransactionError_ParseFailed() =
      _$TransactionError_ParseFailedImpl;
  const TransactionError_ParseFailed._() : super._();
}

/// @nodoc
abstract class _$$TransactionError_UnsupportedSegwitFlagImplCopyWith<$Res> {
  factory _$$TransactionError_UnsupportedSegwitFlagImplCopyWith(
          _$TransactionError_UnsupportedSegwitFlagImpl value,
          $Res Function(_$TransactionError_UnsupportedSegwitFlagImpl) then) =
      __$$TransactionError_UnsupportedSegwitFlagImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int flag});
}

/// @nodoc
class __$$TransactionError_UnsupportedSegwitFlagImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_UnsupportedSegwitFlagImpl>
    implements _$$TransactionError_UnsupportedSegwitFlagImplCopyWith<$Res> {
  __$$TransactionError_UnsupportedSegwitFlagImplCopyWithImpl(
      _$TransactionError_UnsupportedSegwitFlagImpl _value,
      $Res Function(_$TransactionError_UnsupportedSegwitFlagImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flag = null,
  }) {
    return _then(_$TransactionError_UnsupportedSegwitFlagImpl(
      flag: null == flag
          ? _value.flag
          : flag // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TransactionError_UnsupportedSegwitFlagImpl
    extends TransactionError_UnsupportedSegwitFlag {
  const _$TransactionError_UnsupportedSegwitFlagImpl({required this.flag})
      : super._();

  @override
  final int flag;

  @override
  String toString() {
    return 'TransactionError.unsupportedSegwitFlag(flag: $flag)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_UnsupportedSegwitFlagImpl &&
            (identical(other.flag, flag) || other.flag == flag));
  }

  @override
  int get hashCode => Object.hash(runtimeType, flag);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TransactionError_UnsupportedSegwitFlagImplCopyWith<
          _$TransactionError_UnsupportedSegwitFlagImpl>
      get copyWith =>
          __$$TransactionError_UnsupportedSegwitFlagImplCopyWithImpl<
              _$TransactionError_UnsupportedSegwitFlagImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return unsupportedSegwitFlag(flag);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return unsupportedSegwitFlag?.call(flag);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (unsupportedSegwitFlag != null) {
      return unsupportedSegwitFlag(flag);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return unsupportedSegwitFlag(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return unsupportedSegwitFlag?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (unsupportedSegwitFlag != null) {
      return unsupportedSegwitFlag(this);
    }
    return orElse();
  }
}

abstract class TransactionError_UnsupportedSegwitFlag extends TransactionError {
  const factory TransactionError_UnsupportedSegwitFlag(
      {required final int flag}) = _$TransactionError_UnsupportedSegwitFlagImpl;
  const TransactionError_UnsupportedSegwitFlag._() : super._();

  int get flag;
  @JsonKey(ignore: true)
  _$$TransactionError_UnsupportedSegwitFlagImplCopyWith<
          _$TransactionError_UnsupportedSegwitFlagImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TransactionError_OtherTransactionErrImplCopyWith<$Res> {
  factory _$$TransactionError_OtherTransactionErrImplCopyWith(
          _$TransactionError_OtherTransactionErrImpl value,
          $Res Function(_$TransactionError_OtherTransactionErrImpl) then) =
      __$$TransactionError_OtherTransactionErrImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TransactionError_OtherTransactionErrImplCopyWithImpl<$Res>
    extends _$TransactionErrorCopyWithImpl<$Res,
        _$TransactionError_OtherTransactionErrImpl>
    implements _$$TransactionError_OtherTransactionErrImplCopyWith<$Res> {
  __$$TransactionError_OtherTransactionErrImplCopyWithImpl(
      _$TransactionError_OtherTransactionErrImpl _value,
      $Res Function(_$TransactionError_OtherTransactionErrImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TransactionError_OtherTransactionErrImpl
    extends TransactionError_OtherTransactionErr {
  const _$TransactionError_OtherTransactionErrImpl() : super._();

  @override
  String toString() {
    return 'TransactionError.otherTransactionErr()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionError_OtherTransactionErrImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() io,
    required TResult Function() oversizedVectorAllocation,
    required TResult Function(String expected, String actual) invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function() parseFailed,
    required TResult Function(int flag) unsupportedSegwitFlag,
    required TResult Function() otherTransactionErr,
  }) {
    return otherTransactionErr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? io,
    TResult? Function()? oversizedVectorAllocation,
    TResult? Function(String expected, String actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function()? parseFailed,
    TResult? Function(int flag)? unsupportedSegwitFlag,
    TResult? Function()? otherTransactionErr,
  }) {
    return otherTransactionErr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? io,
    TResult Function()? oversizedVectorAllocation,
    TResult Function(String expected, String actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function()? parseFailed,
    TResult Function(int flag)? unsupportedSegwitFlag,
    TResult Function()? otherTransactionErr,
    required TResult orElse(),
  }) {
    if (otherTransactionErr != null) {
      return otherTransactionErr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransactionError_Io value) io,
    required TResult Function(TransactionError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(TransactionError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(TransactionError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(TransactionError_ParseFailed value) parseFailed,
    required TResult Function(TransactionError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
    required TResult Function(TransactionError_OtherTransactionErr value)
        otherTransactionErr,
  }) {
    return otherTransactionErr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TransactionError_Io value)? io,
    TResult? Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult? Function(TransactionError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(TransactionError_ParseFailed value)? parseFailed,
    TResult? Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult? Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
  }) {
    return otherTransactionErr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransactionError_Io value)? io,
    TResult Function(TransactionError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(TransactionError_InvalidChecksum value)? invalidChecksum,
    TResult Function(TransactionError_NonMinimalVarInt value)? nonMinimalVarInt,
    TResult Function(TransactionError_ParseFailed value)? parseFailed,
    TResult Function(TransactionError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    TResult Function(TransactionError_OtherTransactionErr value)?
        otherTransactionErr,
    required TResult orElse(),
  }) {
    if (otherTransactionErr != null) {
      return otherTransactionErr(this);
    }
    return orElse();
  }
}

abstract class TransactionError_OtherTransactionErr extends TransactionError {
  const factory TransactionError_OtherTransactionErr() =
      _$TransactionError_OtherTransactionErrImpl;
  const TransactionError_OtherTransactionErr._() : super._();
}

/// @nodoc
mixin _$TxidParseError {
  String get txid => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String txid) invalidTxid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String txid)? invalidTxid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String txid)? invalidTxid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxidParseError_InvalidTxid value) invalidTxid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxidParseError_InvalidTxid value)? invalidTxid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxidParseError_InvalidTxid value)? invalidTxid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TxidParseErrorCopyWith<TxidParseError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TxidParseErrorCopyWith<$Res> {
  factory $TxidParseErrorCopyWith(
          TxidParseError value, $Res Function(TxidParseError) then) =
      _$TxidParseErrorCopyWithImpl<$Res, TxidParseError>;
  @useResult
  $Res call({String txid});
}

/// @nodoc
class _$TxidParseErrorCopyWithImpl<$Res, $Val extends TxidParseError>
    implements $TxidParseErrorCopyWith<$Res> {
  _$TxidParseErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? txid = null,
  }) {
    return _then(_value.copyWith(
      txid: null == txid
          ? _value.txid
          : txid // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TxidParseError_InvalidTxidImplCopyWith<$Res>
    implements $TxidParseErrorCopyWith<$Res> {
  factory _$$TxidParseError_InvalidTxidImplCopyWith(
          _$TxidParseError_InvalidTxidImpl value,
          $Res Function(_$TxidParseError_InvalidTxidImpl) then) =
      __$$TxidParseError_InvalidTxidImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String txid});
}

/// @nodoc
class __$$TxidParseError_InvalidTxidImplCopyWithImpl<$Res>
    extends _$TxidParseErrorCopyWithImpl<$Res, _$TxidParseError_InvalidTxidImpl>
    implements _$$TxidParseError_InvalidTxidImplCopyWith<$Res> {
  __$$TxidParseError_InvalidTxidImplCopyWithImpl(
      _$TxidParseError_InvalidTxidImpl _value,
      $Res Function(_$TxidParseError_InvalidTxidImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? txid = null,
  }) {
    return _then(_$TxidParseError_InvalidTxidImpl(
      txid: null == txid
          ? _value.txid
          : txid // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TxidParseError_InvalidTxidImpl extends TxidParseError_InvalidTxid {
  const _$TxidParseError_InvalidTxidImpl({required this.txid}) : super._();

  @override
  final String txid;

  @override
  String toString() {
    return 'TxidParseError.invalidTxid(txid: $txid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxidParseError_InvalidTxidImpl &&
            (identical(other.txid, txid) || other.txid == txid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, txid);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TxidParseError_InvalidTxidImplCopyWith<_$TxidParseError_InvalidTxidImpl>
      get copyWith => __$$TxidParseError_InvalidTxidImplCopyWithImpl<
          _$TxidParseError_InvalidTxidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String txid) invalidTxid,
  }) {
    return invalidTxid(txid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String txid)? invalidTxid,
  }) {
    return invalidTxid?.call(txid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String txid)? invalidTxid,
    required TResult orElse(),
  }) {
    if (invalidTxid != null) {
      return invalidTxid(txid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxidParseError_InvalidTxid value) invalidTxid,
  }) {
    return invalidTxid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxidParseError_InvalidTxid value)? invalidTxid,
  }) {
    return invalidTxid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxidParseError_InvalidTxid value)? invalidTxid,
    required TResult orElse(),
  }) {
    if (invalidTxid != null) {
      return invalidTxid(this);
    }
    return orElse();
  }
}

abstract class TxidParseError_InvalidTxid extends TxidParseError {
  const factory TxidParseError_InvalidTxid({required final String txid}) =
      _$TxidParseError_InvalidTxidImpl;
  const TxidParseError_InvalidTxid._() : super._();

  @override
  String get txid;
  @override
  @JsonKey(ignore: true)
  _$$TxidParseError_InvalidTxidImplCopyWith<_$TxidParseError_InvalidTxidImpl>
      get copyWith => throw _privateConstructorUsedError;
}
